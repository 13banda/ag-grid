{
  "version": 3,
  "sources": ["../../src/serverSideRowModelModule.ts", "../../src/serverSideRowModel/serverSideRowModel.ts", "../../src/serverSideRowModel/stores/fullStore.ts", "../../src/serverSideRowModel/stores/lazy/lazyStore.ts", "../../src/serverSideRowModel/stores/lazy/lazyCache.ts", "../../src/serverSideRowModel/stores/lazy/multiIndexMap.ts", "../../src/serverSideRowModel/stores/lazy/lazyBlockLoadingService.ts", "../../src/serverSideRowModel/stores/storeUtils.ts", "../../src/serverSideRowModel/blocks/blockUtils.ts", "../../src/serverSideRowModel/nodeManager.ts", "../../src/serverSideRowModel/transactionManager.ts", "../../src/serverSideRowModel/listeners/expandListener.ts", "../../src/serverSideRowModel/listeners/sortListener.ts", "../../src/serverSideRowModel/listeners/filterListener.ts", "../../src/serverSideRowModel/stores/storeFactory.ts", "../../src/serverSideRowModel/listeners/listenerUtils.ts", "../../src/serverSideRowModel/services/serverSideSelectionService.ts", "../../src/serverSideRowModel/services/selection/strategies/defaultStrategy.ts", "../../src/serverSideRowModel/services/selection/strategies/groupSelectsChildrenStrategy.ts", "../../src/version.ts", "../../src/serverSideRowModel/services/serverSideExpansionService.ts"],
  "sourcesContent": ["import { Module, ModuleNames } from \"@ag-grid-community/core\";\nimport { EnterpriseCoreModule } from \"@ag-grid-enterprise/core\";\nimport { ServerSideRowModel } from \"./serverSideRowModel/serverSideRowModel\";\nimport { StoreUtils } from \"./serverSideRowModel/stores/storeUtils\";\nimport { BlockUtils } from \"./serverSideRowModel/blocks/blockUtils\";\nimport { NodeManager } from \"./serverSideRowModel/nodeManager\";\nimport { TransactionManager } from \"./serverSideRowModel/transactionManager\";\nimport { ExpandListener } from \"./serverSideRowModel/listeners/expandListener\";\nimport { SortListener } from \"./serverSideRowModel/listeners/sortListener\";\nimport { FilterListener } from \"./serverSideRowModel/listeners/filterListener\";\nimport { StoreFactory } from \"./serverSideRowModel/stores/storeFactory\";\nimport { ListenerUtils } from \"./serverSideRowModel/listeners/listenerUtils\";\nimport { ServerSideSelectionService } from \"./serverSideRowModel/services/serverSideSelectionService\";\nimport { VERSION } from \"./version\";\nimport { ServerSideExpansionService } from \"./serverSideRowModel/services/serverSideExpansionService\";\nimport { LazyBlockLoadingService } from \"./serverSideRowModel/stores/lazy/lazyBlockLoadingService\";\n\nexport const ServerSideRowModelModule: Module = {\n    version: VERSION,\n    moduleName: ModuleNames.ServerSideRowModelModule,\n    rowModel: 'serverSide',\n    beans: [ServerSideRowModel, ExpandListener, SortListener, StoreUtils, BlockUtils, NodeManager, TransactionManager,\n        FilterListener, StoreFactory, ListenerUtils, ServerSideSelectionService, ServerSideExpansionService, LazyBlockLoadingService],\n    dependantModules: [\n        EnterpriseCoreModule\n    ]\n};\n", "import {\n    _,\n    Autowired,\n    Bean,\n    BeanStub,\n    Column,\n    ColumnModel,\n    ColumnVO,\n    Events,\n    FilterManager,\n    IServerSideDatasource,\n    IServerSideRowModel,\n    IServerSideStore,\n    ModelUpdatedEvent,\n    NumberSequence,\n    PostConstruct,\n    PreDestroy,\n    RowBounds,\n    RowNode,\n    RowRenderer,\n    StoreRefreshAfterParams,\n    RefreshServerSideParams,\n    ServerSideGroupLevelState,\n    Beans,\n    SortModelItem,\n    WithoutGridCommon,\n    RowModelType,\n    Optional,\n    IPivotColDefService,\n    LoadSuccessParams,\n    SortController,\n    FilterModel,\n    AdvancedFilterModel,\n} from \"@ag-grid-community/core\";\n\nimport { NodeManager } from \"./nodeManager\";\nimport { SortListener } from \"./listeners/sortListener\";\nimport { StoreFactory } from \"./stores/storeFactory\";\nimport { FullStore } from \"./stores/fullStore\";\nimport { LazyStore } from \"./stores/lazy/lazyStore\";\n\nexport interface SSRMParams {\n    sortModel: SortModelItem[];\n    filterModel: FilterModel | AdvancedFilterModel | null;\n    lastAccessedSequence: NumberSequence;\n    dynamicRowHeight: boolean;\n    rowGroupCols: ColumnVO[];\n    valueCols: ColumnVO[];\n    pivotCols: ColumnVO[];\n    pivotMode: boolean;\n    datasource?: IServerSideDatasource;\n}\n\n@Bean('rowModel')\nexport class ServerSideRowModel extends BeanStub implements IServerSideRowModel {\n\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('filterManager') private filterManager: FilterManager;\n    @Autowired('sortController') private sortController: SortController;\n    @Autowired('rowRenderer') private rowRenderer: RowRenderer;\n    @Autowired('ssrmNodeManager') private nodeManager: NodeManager;\n    @Autowired('ssrmStoreFactory') private storeFactory: StoreFactory;\n    @Autowired('beans') private beans: Beans;\n    @Optional('pivotColDefService') private pivotColDefService: IPivotColDefService;\n\n    private onRowHeightChanged_debounced = _.debounce(this.onRowHeightChanged.bind(this), 100);\n\n    private rootNode: RowNode;\n    private datasource: IServerSideDatasource | undefined;\n\n    private storeParams: SSRMParams;\n\n    private pauseStoreUpdateListening = false;\n\n    private started = false;\n\n    private managingPivotResultColumns = false;\n\n    // we don't implement as lazy row heights is not supported in this row model\n    public ensureRowHeightsValid(): boolean { return false; }\n\n    public start(): void {\n        this.started = true;\n        this.updateDatasource();\n    }\n\n    @PreDestroy\n    private destroyDatasource(): void {\n        if (!this.datasource) { return; }\n\n        if (this.datasource.destroy) {\n            this.datasource.destroy();\n        }\n\n        this.rowRenderer.datasourceChanged();\n        this.datasource = undefined;\n    }\n\n    @PostConstruct\n    private addEventListeners(): void {\n        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverything.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_STORE_UPDATED, this.onStoreUpdated.bind(this));\n\n        const resetListener = this.resetRootStore.bind(this);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, resetListener);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, resetListener);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, resetListener);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, resetListener);\n        this.addManagedPropertyListeners([\n            /**\n             * Following properties omitted as they are likely to come with undesired  side effects.\n             * 'getRowId', 'isRowMaster', 'getRowHeight', 'isServerSideGroup', 'getServerSideGroupKey',\n             * */\n            'masterDetail', 'treeData', 'removePivotHeaderRowWhenSingleValueColumn',\n            'suppressServerSideInfiniteScroll', 'cacheBlockSize',\n        ], resetListener);\n        this.addManagedPropertyListener('rowHeight', () => this.resetRowHeights());\n        this.verifyProps();\n\n        this.addManagedPropertyListener('serverSideDatasource', () => this.updateDatasource());\n    }\n\n    private updateDatasource(): void {\n        const datasource = this.gridOptionsService.get('serverSideDatasource');\n\n        if (datasource) {\n            this.setDatasource(datasource);\n        }\n    }\n\n    private verifyProps(): void {\n        if (this.gridOptionsService.exists('initialGroupOrderComparator')) {\n            _.warnOnce(`initialGroupOrderComparator cannot be used with Server Side Row Model.`);\n        }\n        if (this.gridOptionsService.isRowSelection() && !this.gridOptionsService.exists('getRowId')) {\n            _.warnOnce(`getRowId callback must be provided for Server Side Row Model selection to work correctly.`);\n        }\n    }\n\n    public setDatasource(datasource: IServerSideDatasource): void {\n        // sometimes React, due to async, can call gridApi.setDatasource() before we have started.\n        // this happens when React app does this:\n        //      useEffect(() => setDatasource(ds), []);\n        // thus if we set the datasource before the grid UI has finished initialising, we do not set it,\n        // and the ssrm.start() method will set the datasoure when the grid is ready.\n        if (!this.started) { return; }\n\n        this.destroyDatasource();\n        this.datasource = datasource;\n        this.resetRootStore();\n    }\n\n    public applyRowData(rowDataParams: LoadSuccessParams, startRow: number, route: string[]) {\n        const rootStore = this.getRootStore();\n        if (!rootStore) { return; }\n\n        const storeToExecuteOn = rootStore.getChildStore(route);\n\n        if (!storeToExecuteOn) { return };\n    \n        if (storeToExecuteOn instanceof LazyStore) {\n            storeToExecuteOn.applyRowData(rowDataParams, startRow, rowDataParams.rowData.length);\n        } else if (storeToExecuteOn instanceof FullStore) {\n            storeToExecuteOn.processServerResult(rowDataParams);\n        }\n    }\n\n    public isLastRowIndexKnown(): boolean {\n        const cache = this.getRootStore();\n        if (!cache) { return false; }\n        return cache.isLastRowIndexKnown();\n    }\n\n    private onColumnEverything(): void {\n        // if first time, always reset\n        if (!this.storeParams) {\n            this.resetRootStore();\n            return;\n        }\n\n        // check if anything pertaining to fetching data has changed, and if it has, reset, but if\n        // it has not, don't reset\n        const rowGroupColumnVos = this.columnsToValueObjects(this.columnModel.getRowGroupColumns());\n        const valueColumnVos = this.columnsToValueObjects(this.columnModel.getValueColumns());\n        const pivotColumnVos = this.columnsToValueObjects(this.columnModel.getPivotColumns());\n\n        // compares two sets of columns, ensuring no columns have been added or removed (unless specified via allowRemovedColumns)\n        // if the columns are found, also ensures the field and aggFunc properties have not been changed.\n        const areColsSame = (params: { oldCols: ColumnVO[], newCols: ColumnVO[], allowRemovedColumns?: boolean }) => {\n            const oldColsMap: { [key: string]: ColumnVO } = {};\n            params.oldCols.forEach(col => oldColsMap[col.id] = col);\n\n            const allColsUnchanged = params.newCols.every(col => {\n                const equivalentCol = oldColsMap[col.id];\n                if (equivalentCol) {\n                    delete oldColsMap[col.id];\n                }\n                return equivalentCol && equivalentCol.field === col.field && equivalentCol.aggFunc === col.aggFunc;\n            });\n\n            const missingCols = !params.allowRemovedColumns && !!Object.values(oldColsMap).length;\n            return allColsUnchanged && !missingCols;\n        }\n\n        const sortModelDifferent = !_.jsonEquals(this.storeParams.sortModel, this.sortController.getSortModel());\n        const rowGroupDifferent = !areColsSame({\n            oldCols: this.storeParams.rowGroupCols,\n            newCols: rowGroupColumnVos,\n        });\n        const pivotDifferent = !areColsSame({\n            oldCols: this.storeParams.pivotCols,\n            newCols: pivotColumnVos,\n        });\n        const valuesDifferent = !!rowGroupColumnVos?.length && !areColsSame({\n            oldCols: this.storeParams.valueCols,\n            newCols: valueColumnVos,\n            allowRemovedColumns: true,\n        });\n\n        const resetRequired = sortModelDifferent || rowGroupDifferent || pivotDifferent || valuesDifferent;\n\n        if (resetRequired) {\n            this.resetRootStore();\n        } else {\n            // cols may have changed even if we didn't do a reset. storeParams ref will be provided when getRows\n            // is called, so it's important to keep it up to date.\n            const newParams = this.createStoreParams();\n            this.storeParams.rowGroupCols = newParams.rowGroupCols;\n            this.storeParams.pivotCols = newParams.pivotCols;\n            this.storeParams.valueCols = newParams.valueCols;\n        }\n    }\n\n    @PreDestroy\n    private destroyRootStore(): void {\n        if (!this.rootNode || !this.rootNode.childStore) { return; }\n        this.rootNode.childStore = this.destroyBean(this.rootNode.childStore)!;\n        this.nodeManager.clear();\n    }\n\n    public refreshAfterSort(newSortModel: SortModelItem[], params: StoreRefreshAfterParams): void {\n        if (this.storeParams) {\n            this.storeParams.sortModel = newSortModel;\n        }\n\n        const rootStore = this.getRootStore();\n        if (!rootStore) { return; }\n\n        rootStore.refreshAfterSort(params);\n\n        this.onStoreUpdated();\n    }\n\n    public generateSecondaryColumns(pivotFields: string[]) {\n        const pivotColumnGroupDefs = this.pivotColDefService.createColDefsFromFields(pivotFields);\n        this.managingPivotResultColumns = true;\n        this.columnModel.setSecondaryColumns(pivotColumnGroupDefs, \"rowModelUpdated\");\n    };\n\n    public resetRowHeights(): void {\n        const atLeastOne = this.resetRowHeightsForAllRowNodes();\n\n        const rootNodeHeight = this.gridOptionsService.getRowHeightForNode(this.rootNode);\n        this.rootNode.setRowHeight(rootNodeHeight.height, rootNodeHeight.estimated);\n        if (this.rootNode.sibling) {\n            const rootNodeSibling = this.gridOptionsService.getRowHeightForNode(this.rootNode.sibling);\n            this.rootNode.sibling.setRowHeight(rootNodeSibling.height, rootNodeSibling.estimated);\n        }\n\n        // when pivotMode but pivot not active, root node is displayed on its own\n        // because it's only ever displayed alone, refreshing the model (onRowHeightChanged) is not required\n        if (atLeastOne) {\n            this.onRowHeightChanged();\n        }\n    }\n\n    private resetRowHeightsForAllRowNodes(): boolean {\n        let atLeastOne = false;\n        this.forEachNode(rowNode => {\n            const rowHeightForNode = this.gridOptionsService.getRowHeightForNode(rowNode);\n            rowNode.setRowHeight(rowHeightForNode.height, rowHeightForNode.estimated);\n            // we keep the height each row is at, however we set estimated=true rather than clear the height.\n            // this means the grid will not reset the row heights back to defaults, rather it will re-calc\n            // the height for each row as the row is displayed. otherwise the scroll will jump when heights are reset.\n            const detailNode = rowNode.detailNode;\n            if (detailNode) {\n                const detailRowHeight = this.gridOptionsService.getRowHeightForNode(detailNode);\n                detailNode.setRowHeight(detailRowHeight.height, detailRowHeight.estimated);\n            }\n\n            if (rowNode.sibling) {\n                const siblingRowHeight = this.gridOptionsService.getRowHeightForNode(rowNode.sibling);\n                detailNode.setRowHeight(siblingRowHeight.height, siblingRowHeight.estimated);\n            }\n            atLeastOne = true;\n        });\n\n        return atLeastOne;\n    }\n\n    public resetRootStore(): void {\n        this.destroyRootStore();\n\n        this.rootNode = new RowNode(this.beans);\n        this.rootNode.group = true;\n        this.rootNode.level = -1;\n\n        if (this.datasource) {\n            this.storeParams = this.createStoreParams();\n            this.rootNode.childStore = this.createBean(this.storeFactory.createStore(this.storeParams, this.rootNode));\n            this.updateRowIndexesAndBounds();\n        }\n\n        if (this.managingPivotResultColumns) {\n            // if managing pivot columns, also reset secondary columns.\n            this.columnModel.setSecondaryColumns(null, 'api');\n            this.managingPivotResultColumns = false;\n        }\n\n        // this gets the row to render rows (or remove the previously rendered rows, as it's blank to start).\n        // important to NOT pass in an event with keepRenderedRows or animate, as we want the renderer\n        // to treat the rows as new rows, as it's all new data\n        this.dispatchModelUpdated(true);\n    }\n\n    public columnsToValueObjects(columns: Column[]): ColumnVO[] {\n        return columns.map(col => ({\n            id: col.getId(),\n            aggFunc: col.getAggFunc(),\n            displayName: this.columnModel.getDisplayNameForColumn(col, 'model'),\n            field: col.getColDef().field\n        }) as ColumnVO);\n    }\n\n    private createStoreParams(): SSRMParams {\n\n        const rowGroupColumnVos = this.columnsToValueObjects(this.columnModel.getRowGroupColumns());\n        const valueColumnVos = this.columnsToValueObjects(this.columnModel.getValueColumns());\n        const pivotColumnVos = this.columnsToValueObjects(this.columnModel.getPivotColumns());\n\n        const dynamicRowHeight = this.gridOptionsService.isGetRowHeightFunction();\n\n        const params: SSRMParams = {\n            // the columns the user has grouped and aggregated by\n            valueCols: valueColumnVos,\n            rowGroupCols: rowGroupColumnVos,\n            pivotCols: pivotColumnVos,\n            pivotMode: this.columnModel.isPivotMode(),\n\n            // sort and filter model\n            filterModel: this.filterManager.isAdvancedFilterEnabled()\n                ? this.filterManager.getAdvancedFilterModel()\n                : this.filterManager.getFilterModel(),\n            sortModel: this.sortController.getSortModel(),\n\n            datasource: this.datasource,\n            lastAccessedSequence: new NumberSequence(),\n            // blockSize: blockSize == null ? 100 : blockSize,\n            dynamicRowHeight: dynamicRowHeight\n        };\n\n        return params;\n    }\n\n    public getParams(): SSRMParams {\n        return this.storeParams;\n    }\n\n    private dispatchModelUpdated(reset = false): void {\n        const modelUpdatedEvent: WithoutGridCommon<ModelUpdatedEvent> = {\n            type: Events.EVENT_MODEL_UPDATED,\n            animate: !reset,\n            keepRenderedRows: !reset,\n            newPage: false,\n            newData: false\n        };\n        this.eventService.dispatchEvent(modelUpdatedEvent);\n    }\n\n    private onStoreUpdated(): void {\n        // sometimes if doing a batch update, we do the batch first,\n        // then call onStoreUpdated manually. eg expandAll() method.\n        if (this.pauseStoreUpdateListening) { return; }\n\n        this.updateRowIndexesAndBounds();\n        this.dispatchModelUpdated();\n    }\n\n    /** This method is debounced. It is used for row auto-height. If we don't debounce,\n     * then the Row Models will end up recalculating each row position\n     * for each row height change and result in the Row Renderer laying out rows.\n     * This is particularly bad if using print layout, and showing eg 1,000 rows,\n     * each row will change it's height, causing Row Model to update 1,000 times.\n     */\n    public onRowHeightChangedDebounced(): void {\n        this.onRowHeightChanged_debounced();\n    }\n\n    public onRowHeightChanged(): void {\n        this.updateRowIndexesAndBounds();\n        this.dispatchModelUpdated();\n    }\n\n    public updateRowIndexesAndBounds(): void {\n        const rootStore = this.getRootStore();\n        if (!rootStore) { return; }\n        rootStore.setDisplayIndexes(new NumberSequence(), { value: 0 });\n    }\n\n    public retryLoads(): void {\n        const rootStore = this.getRootStore();\n        if (!rootStore) { return; }\n        rootStore.retryLoads();\n        this.onStoreUpdated();\n    }\n\n    public getRow(index: number): RowNode | undefined {\n        const rootStore = this.getRootStore();\n        if (!rootStore) { return undefined; }\n        return rootStore.getRowUsingDisplayIndex(index) as RowNode;\n    }\n\n    /**\n     * Pauses the store, to prevent it updating the UI. This is used when doing batch updates to the store.\n     */\n    public setPaused(paused: boolean): void {\n        this.pauseStoreUpdateListening = paused;\n    }\n\n    public expandAll(value: boolean): void {\n        // if we don't pause store updating, we are needlessly\n        // recalculating row-indexes etc, and also getting rendering\n        // engine to re-render (listens on ModelUpdated event)\n        this.pauseStoreUpdateListening = true;\n        this.forEachNode(node => {\n            if (node.stub) {\n                return;\n            }\n\n            if (node.hasChildren()) {\n                node.setExpanded(value);\n            }\n        });\n        this.pauseStoreUpdateListening = false;\n        this.onStoreUpdated();\n    }\n\n    public refreshAfterFilter(newFilterModel: FilterModel | AdvancedFilterModel | null, params: StoreRefreshAfterParams): void {\n        if (this.storeParams) {\n            this.storeParams.filterModel = newFilterModel;\n        }\n        const rootStore = this.getRootStore();\n        if (!rootStore) { return; }\n        rootStore.refreshAfterFilter(params);\n\n        this.onStoreUpdated();\n    }\n\n    public getRootStore(): IServerSideStore | undefined {\n        if (this.rootNode && this.rootNode.childStore) {\n            return this.rootNode.childStore;\n        }\n    }\n\n    public getRowCount(): number {\n        const rootStore = this.getRootStore();\n        if (!rootStore) { return 0; }\n\n        return rootStore.getDisplayIndexEnd()!;\n    }\n\n    public getTopLevelRowCount(): number {\n        const rootStore = this.getRootStore();\n        if (!rootStore) { return 1; }\n        return rootStore.getRowCount();\n    }\n\n    public getTopLevelRowDisplayedIndex(topLevelIndex: number): number {\n        const rootStore = this.getRootStore();\n        if (!rootStore) { return topLevelIndex; }\n        return rootStore.getTopLevelRowDisplayedIndex(topLevelIndex);\n    }\n\n    public getRowBounds(index: number): RowBounds {\n        const rootStore = this.getRootStore();\n        if (!rootStore) {\n            const rowHeight = this.gridOptionsService.getRowHeightAsNumber();\n            return {\n                rowTop: 0,\n                rowHeight: rowHeight\n            };\n        }\n        return rootStore.getRowBounds(index)!;\n    }\n\n    public getBlockStates() {\n        const root = this.getRootStore();\n        if (!root) {\n            return undefined;\n        }\n        \n        const states: any = {};\n        root.forEachStoreDeep(store => {\n            if (store instanceof FullStore) {\n                const { id, state } = store.getBlockStateJson();\n                states[id] = state;\n            } else if (store instanceof LazyStore) {\n                Object.entries(store.getBlockStates()).forEach(([block, state]) => {\n                    states[block] = state;\n                });\n            } else {\n                throw new Error('AG Grid: Unsupported store type');\n            }\n        });\n        return states;\n    }\n\n    public getRowIndexAtPixel(pixel: number): number {\n        const rootStore = this.getRootStore();\n        if (pixel <= 0 || !rootStore) { return 0; }\n\n        return rootStore.getRowIndexAtPixel(pixel)!;\n    }\n\n    public isEmpty(): boolean {\n        return false;\n    }\n\n    public isRowsToRender(): boolean {\n        return this.getRootStore() != null && this.getRowCount() > 0;\n    }\n\n    public getType(): RowModelType {\n        return 'serverSide';\n    }\n\n    public forEachNode(callback: (rowNode: RowNode, index: number) => void): void {\n        const rootStore = this.getRootStore();\n        if (!rootStore) { return; }\n        rootStore.forEachNodeDeep(callback);\n    }\n\n    public forEachNodeAfterFilterAndSort(callback: (node: RowNode, index: number) => void, includeFooterNodes = false): void {\n        const rootStore = this.getRootStore();\n        if (!rootStore) { return; }\n        rootStore.forEachNodeDeepAfterFilterAndSort(callback, undefined, includeFooterNodes);\n    }\n\n    /** @return false if store hasn't started */\n    public executeOnStore(route: string[], callback: (cache: IServerSideStore) => void): boolean {\n        if (!this.started) { return false; }\n        const rootStore = this.getRootStore();\n        if (!rootStore) { return true; }\n\n        const storeToExecuteOn = rootStore.getChildStore(route);\n\n        if (storeToExecuteOn) {\n            callback(storeToExecuteOn);\n        }\n        return true;\n    }\n\n    public refreshStore(params: RefreshServerSideParams = {}): void {\n        const route = params.route ? params.route : [];\n        this.executeOnStore(route, store => store.refreshStore(params.purge == true));\n    }\n\n    public getStoreState(): ServerSideGroupLevelState[] {\n        const res: ServerSideGroupLevelState[] = [];\n        const rootStore = this.getRootStore();\n        if (rootStore) {\n            rootStore.addStoreStates(res);\n        }\n        return res;\n    }\n\n    public getNodesInRangeForSelection(firstInRange: RowNode, lastInRange: RowNode | null): RowNode[] {\n        if (!_.exists(firstInRange)) {\n            return [];   \n        }\n\n        if (!lastInRange) {\n            return [firstInRange];\n        }\n\n        const startIndex = firstInRange.rowIndex;\n        const endIndex = lastInRange.rowIndex;\n        if (startIndex === null || endIndex === null) {\n            return [firstInRange];\n        }\n\n        const nodeRange: RowNode[] = [];\n        const [firstIndex, lastIndex] = [startIndex, endIndex].sort((a,b) => a - b);\n        this.forEachNode((node) => {\n            const thisRowIndex = node.rowIndex;\n            if (thisRowIndex == null || node.stub) {\n                return;\n            }\n\n            if (thisRowIndex >= firstIndex && thisRowIndex <= lastIndex) {\n                nodeRange.push(node);\n            }\n        });\n\n        // don't allow range selection if we don't have the full range of rows\n        if (nodeRange.length !== (lastIndex - firstIndex + 1)) {\n            return [firstInRange];\n        }\n\n        return nodeRange;\n    }\n\n    public getRowNode(id: string): RowNode | undefined {\n        let result: RowNode | undefined;\n        this.forEachNode(rowNode => {\n            if (rowNode.id === id) {\n                result = rowNode;\n            }\n            if (rowNode.detailNode && rowNode.detailNode.id === id) {\n                result = rowNode.detailNode;\n            }\n        });\n        return result;\n    }\n\n    public isRowPresent(rowNode: RowNode): boolean {\n        const foundRowNode = this.getRowNode(rowNode.id!);\n        return !!foundRowNode;\n    }\n\n    public setRowCount(rowCount: number, lastRowIndexKnown?: boolean): void {\n        const rootStore = this.getRootStore();\n        if (rootStore) {\n            if (rootStore instanceof LazyStore) {\n                rootStore.setRowCount(rowCount, lastRowIndexKnown);\n                return;\n            }\n            console.error('AG Grid: Infinite scrolling must be enabled in order to set the row count.');\n        }\n    }\n}\n", "import {\n    _,\n    Autowired,\n    Column,\n    ColumnModel,\n    Events,\n    FilterManager,\n    IServerSideStore,\n    LoadSuccessParams,\n    NumberSequence,\n    PostConstruct,\n    PostSortRowsParams,\n    PreDestroy,\n    RowBounds,\n    RowNode,\n    RowNodeBlock,\n    RowNodeBlockLoader,\n    RowNodeSorter,\n    SelectionChangedEvent,\n    ServerSideGroupLevelParams,\n    ServerSideGroupLevelState,\n    ServerSideTransaction,\n    ServerSideTransactionResult,\n    ServerSideTransactionResultStatus,\n    SortController,\n    StoreRefreshAfterParams,\n    StoreUpdatedEvent,\n    WithoutGridCommon,\n    IsApplyServerSideTransactionParams,\n    IRowNode,\n    ISelectionService,\n} from \"@ag-grid-community/core\";\nimport { SSRMParams, ServerSideRowModel } from \"../serverSideRowModel\";\nimport { StoreUtils } from \"./storeUtils\";\nimport { BlockUtils } from \"../blocks/blockUtils\";\nimport { NodeManager } from \"../nodeManager\";\nimport { TransactionManager } from \"../transactionManager\";\n\nexport class FullStore extends RowNodeBlock implements IServerSideStore {\n\n    @Autowired('ssrmStoreUtils') private storeUtils: StoreUtils;\n    @Autowired('ssrmBlockUtils') private blockUtils: BlockUtils;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('rowNodeBlockLoader') private rowNodeBlockLoader: RowNodeBlockLoader;\n    @Autowired('rowNodeSorter') private rowNodeSorter: RowNodeSorter;\n    @Autowired('sortController') private sortController: SortController;\n    @Autowired('selectionService') private selectionService: ISelectionService;\n    @Autowired('ssrmNodeManager') private nodeManager: NodeManager;\n    @Autowired('filterManager') private filterManager: FilterManager;\n    @Autowired('ssrmTransactionManager') private transactionManager: TransactionManager;\n    @Autowired('rowModel') private serverSideRowModel: ServerSideRowModel;\n\n    private readonly level: number;\n    private readonly groupLevel: boolean | undefined;\n    private readonly leafGroup: boolean;\n    private readonly ssrmParams: SSRMParams;\n    private readonly parentRowNode: RowNode;\n\n    private nodeIdSequence: NumberSequence = new NumberSequence();\n\n    private usingTreeData: boolean;\n\n    private allRowNodes: RowNode[];\n    private nodesAfterFilter: RowNode[];\n    private nodesAfterSort: RowNode[];\n\n    // when user is provide the id's, we also keep a map of ids to row nodes for convenience\n    private allNodesMap: { [id: string]: RowNode };\n\n    private groupField: string;\n    private rowGroupColumn: Column;\n    private nodeIdPrefix: string | undefined;\n\n    private displayIndexStart: number | undefined;\n    private displayIndexEnd: number | undefined;\n\n    private topPx: number;\n    private heightPx: number;\n\n    private info: any = {};\n\n    private postSortFunc: ((params: WithoutGridCommon<PostSortRowsParams>) => void) | undefined;\n\n    constructor(ssrmParams: SSRMParams, storeParams: ServerSideGroupLevelParams, parentRowNode: RowNode) {\n        // finite block represents a cache with just one block, thus 0 is the id, it's the first block\n        super(0);\n        this.ssrmParams = ssrmParams;\n        this.parentRowNode = parentRowNode;\n        this.level = parentRowNode.level + 1;\n        this.groupLevel = ssrmParams.rowGroupCols ? this.level < ssrmParams.rowGroupCols.length : undefined;\n        this.leafGroup = ssrmParams.rowGroupCols ? this.level === ssrmParams.rowGroupCols.length - 1 : false;\n    }\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.usingTreeData = this.gridOptionsService.get('treeData');\n        this.nodeIdPrefix = this.blockUtils.createNodeIdPrefix(this.parentRowNode);\n\n        if (!this.usingTreeData && this.groupLevel) {\n            const groupColVo = this.ssrmParams.rowGroupCols[this.level];\n            this.groupField = groupColVo.field!;\n            this.rowGroupColumn = this.columnModel.getRowGroupColumns()[this.level];\n        }\n\n\n        let initialRowCount = 1;\n        const isRootStore = this.parentRowNode.level === -1;\n        const userInitialRowCount = this.storeUtils.getServerSideInitialRowCount();\n        if (isRootStore && userInitialRowCount != null) {\n            initialRowCount = userInitialRowCount;\n        }\n        this.initialiseRowNodes(initialRowCount);\n\n        this.rowNodeBlockLoader.addBlock(this);\n        this.addDestroyFunc(() => this.rowNodeBlockLoader.removeBlock(this));\n\n\n        this.postSortFunc = this.gridOptionsService.getCallback('postSortRows');\n\n        if (userInitialRowCount != null) {\n            this.eventService.dispatchEventOnce({\n                type: Events.EVENT_ROW_COUNT_READY\n            });\n        }\n    }\n\n    @PreDestroy\n    private destroyRowNodes(): void {\n        this.blockUtils.destroyRowNodes(this.allRowNodes);\n\n        this.allRowNodes = [];\n        this.nodesAfterSort = [];\n        this.nodesAfterFilter = [];\n        this.allNodesMap = {};\n    }\n\n    private initialiseRowNodes(loadingRowsCount: number, failedLoad = false): void {\n        this.destroyRowNodes();\n        for (let i = 0; i < loadingRowsCount; i++) {\n            const loadingRowNode = this.blockUtils.createRowNode(\n                {\n                    field: this.groupField, group: this.groupLevel!, leafGroup: this.leafGroup,\n                    level: this.level, parent: this.parentRowNode, rowGroupColumn: this.rowGroupColumn\n                }\n            );\n            if (failedLoad) {\n                loadingRowNode.failedLoad = true;\n            }\n            this.allRowNodes.push(loadingRowNode);\n            this.nodesAfterFilter.push(loadingRowNode);\n            this.nodesAfterSort.push(loadingRowNode);\n        }\n    }\n\n    public getBlockStateJson(): { id: string, state: any } {\n        return {\n            id: this.nodeIdPrefix ? this.nodeIdPrefix : '',\n            state: this.getState()\n        };\n    }\n\n    protected loadFromDatasource(): void {\n        this.storeUtils.loadFromDatasource({\n            startRow: undefined,\n            endRow: undefined,\n            parentBlock: this,\n            parentNode: this.parentRowNode,\n            storeParams: this.ssrmParams,\n            success: this.success.bind(this, this.getVersion()),\n            fail: this.pageLoadFailed.bind(this, this.getVersion())\n        });\n    }\n\n    public getStartRow(): number {\n        return 0; // always zero as not in a cache\n    }\n\n    public getEndRow(): number {\n        return this.nodesAfterSort.length;\n    }\n\n    private createDataNode(data: any, index?: number): RowNode {\n        const rowNode = this.blockUtils.createRowNode(\n            {\n                field: this.groupField, group: this.groupLevel!, leafGroup: this.leafGroup,\n                level: this.level, parent: this.parentRowNode, rowGroupColumn: this.rowGroupColumn\n            }\n        );\n\n        if (index != null) {\n            _.insertIntoArray(this.allRowNodes, rowNode, index);\n        } else {\n            this.allRowNodes.push(rowNode);\n        }\n\n        const defaultId = this.prefixId(this.nodeIdSequence.next());\n        this.blockUtils.setDataIntoRowNode(rowNode, data, defaultId, undefined);\n        this.nodeManager.addRowNode(rowNode);\n\n        this.blockUtils.checkOpenByDefault(rowNode);\n\n        this.allNodesMap[rowNode.id!] = rowNode;\n\n        return rowNode;\n    }\n\n    private prefixId(id: number): string {\n        if (this.nodeIdPrefix) {\n            return this.nodeIdPrefix + '-' + id;\n        } else {\n            return id.toString();\n        }\n    }\n\n    protected processServerFail(): void {\n        this.initialiseRowNodes(1, true);\n        this.fireStoreUpdatedEvent();\n        this.flushAsyncTransactions();\n    }\n\n    public processServerResult(params: LoadSuccessParams): void {\n        if (!this.isAlive()) { return; }\n\n        const info = params.groupLevelInfo;\n        if (info) {\n            Object.assign(this.info, info);\n        }\n\n        if (params.pivotResultFields) {\n            this.serverSideRowModel.generateSecondaryColumns(params.pivotResultFields);\n        }\n\n        const nodesToRecycle = this.allRowNodes.length > 0 ? this.allNodesMap : undefined;\n\n        this.allRowNodes = [];\n        this.nodesAfterSort = [];\n        this.nodesAfterFilter = [];\n        this.allNodesMap = {};\n\n        if (!params.rowData) {\n            _.warnOnce('\"params.data\" is missing from Server-Side Row Model success() callback. Please use the \"data\" attribute. If no data is returned, set an empty list.');\n        }\n\n        this.createOrRecycleNodes(nodesToRecycle, params.rowData);\n\n        if (nodesToRecycle) {\n            this.blockUtils.destroyRowNodes(_.getAllValuesInObject(nodesToRecycle));\n        }\n\n        if (this.level === 0) {\n            this.eventService.dispatchEventOnce({\n                type: Events.EVENT_ROW_COUNT_READY\n            });\n        }\n\n        this.filterAndSortNodes();\n        this.fireStoreUpdatedEvent();\n        this.flushAsyncTransactions();\n    }\n\n    private createOrRecycleNodes(nodesToRecycle?: { [id: string]: RowNode }, rowData?: any[]): void {\n        if (!rowData) { return; }\n\n        const lookupNodeToRecycle = (data: any): RowNode | undefined => {\n            if (!nodesToRecycle) { return undefined; }\n\n            const getRowIdFunc = this.gridOptionsService.getCallback('getRowId');\n            if (!getRowIdFunc) { return undefined; }\n\n            const parentKeys = this.parentRowNode.getGroupKeys();\n            const level = this.level;\n            const id = getRowIdFunc({\n                data,\n                parentKeys: parentKeys.length > 0 ? parentKeys : undefined,\n                level,\n            });\n            const foundNode = nodesToRecycle[id];\n            if (!foundNode) { return undefined; }\n\n            delete nodesToRecycle[id];\n            return foundNode;\n        };\n\n        const recycleNode = (rowNode: RowNode, dataItem: any) => {\n            this.allNodesMap[rowNode.id!] = rowNode;\n            this.blockUtils.updateDataIntoRowNode(rowNode, dataItem);\n            this.allRowNodes.push(rowNode);\n        };\n\n        rowData.forEach(dataItem => {\n            const nodeToRecycle = lookupNodeToRecycle(dataItem);\n            if (nodeToRecycle) {\n                recycleNode(nodeToRecycle, dataItem);\n            } else {\n                this.createDataNode(dataItem);\n            }\n        });\n    }\n\n    private flushAsyncTransactions(): void {\n        // we want to update the store with any outstanding transactions straight away,\n        // as otherwise if waitTimeMillis is large (eg 5s), then the user could be looking\n        // at old data for a few seconds before the transactions is applied, which isn't what\n        // you would expect when we advertise 'transaction is applied when data is loaded'.\n        // we do this in a timeout as flushAsyncTransactions expects the grid to be in a settled\n        // state, not in the middle of loading rows! keeps the VM Turns more simple and deterministic.\n        window.setTimeout(() => this.transactionManager.flushAsyncTransactions(), 0);\n    }\n\n    private filterAndSortNodes(): void {\n        this.filterRowNodes();\n        this.sortRowNodes();\n    }\n\n    private sortRowNodes(): void {\n        const serverIsSorting = this.storeUtils.isServerSideSortAllLevels() || this.storeUtils.isServerSideSortOnServer();\n        const sortOptions = this.sortController.getSortOptions();\n        const noSortApplied = !sortOptions || sortOptions.length == 0;\n        if (serverIsSorting || noSortApplied) {\n            this.nodesAfterSort = this.nodesAfterFilter;\n            return;\n        }\n\n        this.nodesAfterSort = this.rowNodeSorter.doFullSort(this.nodesAfterFilter, sortOptions);\n        if (this.postSortFunc) {\n            const params: WithoutGridCommon<PostSortRowsParams> = { nodes: this.nodesAfterSort };\n            this.postSortFunc(params);\n        }\n    }\n\n    private filterRowNodes(): void {\n        const serverIsFiltering = !this.storeUtils.isServerSideOnlyRefreshFilteredGroups() || this.storeUtils.isServerSideFilterOnServer();\n        // filtering for InFullStore only works at lowest level details.\n        // reason is the logic for group filtering was to difficult to work out how it should work at time of writing.\n        const groupLevel = this.groupLevel;\n\n        if (serverIsFiltering || groupLevel) {\n            this.nodesAfterFilter = this.allRowNodes;\n            return;\n        }\n\n        this.nodesAfterFilter = this.allRowNodes.filter(\n            rowNode => this.filterManager.doesRowPassFilter({ rowNode: rowNode })\n        );\n    }\n\n    public clearDisplayIndexes(): void {\n        this.displayIndexStart = undefined;\n        this.displayIndexEnd = undefined;\n        this.allRowNodes.forEach(rowNode => this.blockUtils.clearDisplayIndex(rowNode));\n    }\n\n    public getDisplayIndexEnd(): number | undefined {\n        return this.displayIndexEnd;\n    }\n\n    public isDisplayIndexInStore(displayIndex: number): boolean {\n        if (this.getRowCount() === 0) {\n            return false;\n        }\n        return displayIndex >= this.displayIndexStart! && displayIndex < this.displayIndexEnd!;\n    }\n\n    public setDisplayIndexes(displayIndexSeq: NumberSequence, nextRowTop: { value: number }): void {\n        this.displayIndexStart = displayIndexSeq.peek();\n        this.topPx = nextRowTop.value;\n\n        const visibleNodeIds: { [id: string]: boolean } = {};\n\n        // set on all visible nodes\n        this.nodesAfterSort.forEach(rowNode => {\n            this.blockUtils.setDisplayIndex(rowNode, displayIndexSeq, nextRowTop);\n            visibleNodeIds[rowNode.id!] = true;\n        });\n\n        // and clear on all non-visible nodes\n        this.allRowNodes.forEach(rowNode => {\n            if (!visibleNodeIds[rowNode.id!]) {\n                this.blockUtils.clearDisplayIndex(rowNode);\n            }\n        });\n\n        this.displayIndexEnd = displayIndexSeq.peek();\n        this.heightPx = nextRowTop.value - this.topPx;\n    }\n\n    public forEachStoreDeep(callback: (store: IServerSideStore, index: number) => void, sequence = new NumberSequence()): void {\n        callback(this, sequence.next());\n        this.allRowNodes.forEach(rowNode => {\n            const childCache = rowNode.childStore;\n            if (childCache) {\n                childCache.forEachStoreDeep(callback, sequence);\n            }\n        });\n    }\n\n    public forEachNodeDeep(callback: (rowNode: RowNode, index: number) => void, sequence = new NumberSequence()): void {\n        this.allRowNodes.forEach(rowNode => {\n            callback(rowNode, sequence.next());\n            const childCache = rowNode.childStore;\n            if (childCache) {\n                childCache.forEachNodeDeep(callback, sequence);\n            }\n        });\n    }\n\n    public forEachNodeDeepAfterFilterAndSort(callback: (rowNode: RowNode, index: number) => void, sequence = new NumberSequence(), includeFooterNodes = false): void {\n        this.nodesAfterSort.forEach(rowNode => {\n            callback(rowNode, sequence.next());\n            const childCache = rowNode.childStore;\n            if (childCache) {\n                childCache.forEachNodeDeepAfterFilterAndSort(callback, sequence, includeFooterNodes);\n            }\n        });\n\n        if (includeFooterNodes && this.parentRowNode.sibling) {\n            callback(this.parentRowNode.sibling, sequence.next());\n        }\n    }\n\n    public getRowUsingDisplayIndex(displayRowIndex: number): IRowNode | undefined {\n        // this can happen if asking for a row that doesn't exist in the model,\n        // eg if a cell range is selected, and the user filters so rows no longer exists\n        if (!this.isDisplayIndexInStore(displayRowIndex)) { return undefined; }\n\n        const res = this.blockUtils.binarySearchForDisplayIndex(displayRowIndex, this.nodesAfterSort);\n        return res;\n    }\n\n    public getRowBounds(index: number): RowBounds | null {\n        for (let i = 0; i < this.nodesAfterSort.length; i++) {\n            const rowNode = this.nodesAfterSort[i];\n            const res = this.blockUtils.extractRowBounds(rowNode, index);\n            if (res) { return res; }\n        }\n\n        return null;\n    }\n\n    public isPixelInRange(pixel: number): boolean {\n        return pixel >= this.topPx && pixel < (this.topPx + this.heightPx);\n    }\n\n    public getRowIndexAtPixel(pixel: number): number | null {\n\n        // if pixel before block, return first row\n        const pixelBeforeThisStore = pixel <= this.topPx;\n        if (pixelBeforeThisStore) {\n            const firstNode = this.nodesAfterSort[0];\n            return firstNode.rowIndex!;\n        }\n        // if pixel after store, return last row, however the last\n        // row could be a child store\n        const pixelAfterThisStore = pixel >= (this.topPx + this.heightPx);\n        if (pixelAfterThisStore) {\n            const lastRowNode = this.nodesAfterSort[this.nodesAfterSort.length - 1];\n            const lastRowNodeBottomPx = lastRowNode.rowTop! + lastRowNode.rowHeight!;\n\n            if (pixel >= lastRowNodeBottomPx && lastRowNode.expanded) {\n                if (lastRowNode.childStore && lastRowNode.childStore.getRowCount() > 0) {\n                    return lastRowNode.childStore.getRowIndexAtPixel(pixel);\n                }\n                if (lastRowNode.detailNode) {\n                    return lastRowNode.detailNode.rowIndex;\n                }\n            }\n\n            return lastRowNode.rowIndex;\n        }\n\n        let res: number | null = null;\n        this.nodesAfterSort.forEach(rowNode => {\n            const res2 = this.blockUtils.getIndexAtPixel(rowNode, pixel);\n            if (res2 != null) {\n                res = res2;\n            }\n        });\n\n        const pixelIsPastLastRow = res == null;\n\n        if (pixelIsPastLastRow) {\n            return this.displayIndexEnd! - 1;\n        }\n\n        return res;\n    }\n\n    public getChildStore(keys: string[]): IServerSideStore | null {\n        return this.storeUtils.getChildStore(keys, this, (key: string) => {\n            const rowNode = this.allRowNodes.find(currentRowNode => {\n                return currentRowNode.key == key;\n            });\n\n            return rowNode!;\n        });\n    }\n\n    private forEachChildStoreShallow(callback: (childStore: IServerSideStore) => void): void {\n        this.allRowNodes.forEach(rowNode => {\n            const childStore = rowNode.childStore;\n            if (childStore) {\n                callback(childStore);\n            }\n        });\n    }\n\n    public refreshAfterFilter(params: StoreRefreshAfterParams): void {\n        const serverIsFiltering = this.storeUtils.isServerSideFilterOnServer();\n        const storeIsImpacted = this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, params);\n        const serverIsFilteringAllLevels = !this.storeUtils.isServerSideOnlyRefreshFilteredGroups();\n        if (serverIsFilteringAllLevels || (serverIsFiltering && storeIsImpacted)) {\n            this.refreshStore(true);\n            this.sortRowNodes();\n            return;\n        }\n\n        this.filterRowNodes();\n        this.sortRowNodes();\n        this.forEachChildStoreShallow(store => store.refreshAfterFilter(params));\n    }\n\n    public refreshAfterSort(params: StoreRefreshAfterParams): void {\n        const serverIsSorting = this.storeUtils.isServerSideSortOnServer();\n        const storeIsImpacted = this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, params);\n        const serverIsSortingAllLevels = this.storeUtils.isServerSideSortAllLevels();\n        if (serverIsSortingAllLevels || (serverIsSorting && storeIsImpacted)) {\n            this.refreshStore(true);\n            this.filterRowNodes();\n            return;\n        }\n\n        this.filterRowNodes();\n        this.sortRowNodes();\n        this.forEachChildStoreShallow(store => store.refreshAfterSort(params));\n    }\n\n    public applyTransaction(transaction: ServerSideTransaction): ServerSideTransactionResult {\n\n        // we only apply transactions to loaded state\n        switch (this.getState()) {\n            case RowNodeBlock.STATE_FAILED:\n                return { status: ServerSideTransactionResultStatus.StoreLoadingFailed };\n            case RowNodeBlock.STATE_LOADING:\n                return { status: ServerSideTransactionResultStatus.StoreLoading };\n            case RowNodeBlock.STATE_WAITING_TO_LOAD:\n                return { status: ServerSideTransactionResultStatus.StoreWaitingToLoad };\n        }\n\n        const applyCallback = this.gridOptionsService.getCallback('isApplyServerSideTransaction');\n        if (applyCallback) {\n            const params: WithoutGridCommon<IsApplyServerSideTransactionParams> = {\n                transaction: transaction,\n                parentNode: this.parentRowNode,\n                groupLevelInfo: this.info\n            };\n            const apply = applyCallback(params);\n            if (!apply) {\n                return { status: ServerSideTransactionResultStatus.Cancelled };\n            }\n        }\n\n        const res: ServerSideTransactionResult = {\n            status: ServerSideTransactionResultStatus.Applied,\n            remove: [],\n            update: [],\n            add: []\n        };\n\n        const nodesToUnselect: RowNode[] = [];\n\n        this.executeAdd(transaction, res);\n        this.executeRemove(transaction, res, nodesToUnselect);\n        this.executeUpdate(transaction, res, nodesToUnselect);\n\n        this.filterAndSortNodes();\n\n        this.updateSelection(nodesToUnselect);\n\n        return res;\n    }\n\n    private updateSelection(nodesToUnselect: RowNode[]): void {\n        const selectionChanged = nodesToUnselect.length > 0;\n        if (selectionChanged) {\n            this.selectionService.setNodesSelected({\n                newValue: false,\n                nodes: nodesToUnselect,\n                suppressFinishActions: true,\n                clearSelection: false,\n                source: 'rowDataChanged',\n            });\n\n            const event: WithoutGridCommon<SelectionChangedEvent> = {\n                type: Events.EVENT_SELECTION_CHANGED,\n                source: 'rowDataChanged'\n            };\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    private executeAdd(rowDataTran: ServerSideTransaction, rowNodeTransaction: ServerSideTransactionResult): void {\n        const { add, addIndex } = rowDataTran;\n        if (_.missingOrEmpty(add)) { return; }\n\n        const useIndex = typeof addIndex === 'number' && addIndex >= 0;\n        if (useIndex) {\n            // items get inserted in reverse order for index insertion\n            add!.reverse().forEach(item => {\n                const newRowNode: RowNode = this.createDataNode(item, addIndex);\n                rowNodeTransaction.add!.push(newRowNode);\n            });\n        } else {\n            add!.forEach(item => {\n                const newRowNode: RowNode = this.createDataNode(item);\n                rowNodeTransaction.add!.push(newRowNode);\n            });\n        }\n    }\n\n    private executeRemove(rowDataTran: ServerSideTransaction, rowNodeTransaction: ServerSideTransactionResult, nodesToUnselect: RowNode[]): void {\n        const { remove } = rowDataTran;\n\n        if (remove == null) { return; }\n\n        const rowIdsRemoved: { [key: string]: boolean } = {};\n\n        remove.forEach(item => {\n            const rowNode = this.lookupRowNode(item);\n\n            if (!rowNode) { return; }\n\n            // do delete - setting 'suppressFinishActions = true' to ensure EVENT_SELECTION_CHANGED is not raised for\n            // each row node updated, instead it is raised once by the calling code if any selected nodes exist.\n            if (rowNode.isSelected()) {\n                nodesToUnselect.push(rowNode);\n            }\n\n            // so row renderer knows to fade row out (and not reposition it)\n            rowNode.clearRowTopAndRowIndex();\n\n            // NOTE: were we could remove from allLeaveChildren, however _.removeFromArray() is expensive, especially\n            // if called multiple times (eg deleting lots of rows) and if allLeafChildren is a large list\n            rowIdsRemoved[rowNode.id!] = true;\n            // _.removeFromArray(this.rootNode.allLeafChildren, rowNode);\n            delete this.allNodesMap[rowNode.id!];\n\n            rowNodeTransaction.remove!.push(rowNode);\n\n            this.nodeManager.removeNode(rowNode);\n        });\n\n        this.allRowNodes = this.allRowNodes.filter(rowNode => !rowIdsRemoved[rowNode.id!]);\n    }\n\n    private executeUpdate(rowDataTran: ServerSideTransaction, rowNodeTransaction: ServerSideTransactionResult, nodesToUnselect: RowNode[]): void {\n        const { update } = rowDataTran;\n        if (update == null) { return; }\n\n        update.forEach(item => {\n            const rowNode = this.lookupRowNode(item);\n\n            if (!rowNode) { return; }\n\n            this.blockUtils.updateDataIntoRowNode(rowNode, item);\n            if (!rowNode.selectable && rowNode.isSelected()) {\n                nodesToUnselect.push(rowNode);\n            }\n\n            rowNodeTransaction.update!.push(rowNode);\n        });\n    }\n\n    private lookupRowNode(data: any): RowNode | null {\n        const getRowIdFunc = this.gridOptionsService.getCallback('getRowId');\n\n        let rowNode: RowNode;\n        if (getRowIdFunc != null) {\n            // find rowNode using id\n            const level = this.level;\n            const parentKeys = this.parentRowNode.getGroupKeys();\n            const id: string = getRowIdFunc({\n                data,\n                parentKeys: parentKeys.length > 0 ? parentKeys : undefined,\n                level,\n            });\n            rowNode = this.allNodesMap[id];\n            if (!rowNode) {\n                console.error(`AG Grid: could not find row id=${id}, data item was not found for this id`);\n                return null;\n            }\n        } else {\n            // find rowNode using object references\n            rowNode = this.allRowNodes.find(currentRowNode => currentRowNode.data === data)!;\n            if (!rowNode) {\n                console.error(`AG Grid: could not find data item as object was not found`, data);\n                return null;\n            }\n        }\n\n        return rowNode;\n    }\n\n    public addStoreStates(result: ServerSideGroupLevelState[]): void {\n        result.push({\n            suppressInfiniteScroll: true,\n            route: this.parentRowNode.getGroupKeys(),\n            rowCount: this.allRowNodes.length,\n            info: this.info\n        });\n        this.forEachChildStoreShallow(childStore => childStore.addStoreStates(result));\n    }\n\n    public refreshStore(purge: boolean): void {\n        if (purge) {\n            const loadingRowsToShow = this.nodesAfterSort ? this.nodesAfterSort.length : 1;\n            this.initialiseRowNodes(loadingRowsToShow);\n        }\n        this.scheduleLoad();\n        this.fireStoreUpdatedEvent();\n    }\n\n    public retryLoads(): void {\n        if (this.getState() === RowNodeBlock.STATE_FAILED) {\n            this.initialiseRowNodes(1);\n            this.scheduleLoad();\n        }\n\n        this.forEachChildStoreShallow(store => store.retryLoads());\n    }\n\n    private scheduleLoad(): void {\n        this.setStateWaitingToLoad();\n        this.rowNodeBlockLoader.checkBlockToLoad();\n    }\n\n    // gets called 1) row count changed 2) cache purged 3) items inserted\n    private fireStoreUpdatedEvent(): void {\n        // this results in row model firing ModelUpdated.\n        // server side row model also updates the row indexes first\n        const event: WithoutGridCommon<StoreUpdatedEvent> = {\n            type: Events.EVENT_STORE_UPDATED\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    public getRowCount(): number {\n        return this.nodesAfterSort.length;\n    }\n\n    public getTopLevelRowDisplayedIndex(topLevelIndex: number): number {\n        const rowNode = this.nodesAfterSort[topLevelIndex];\n        return rowNode.rowIndex!;\n    }\n\n    public isLastRowIndexKnown(): boolean {\n        return this.getState() == RowNodeBlock.STATE_LOADED;\n    }\n\n    public getRowNodesInRange(firstInRange: RowNode, lastInRange: RowNode): RowNode[] {\n        const result: RowNode[] = [];\n\n        let inActiveRange = false;\n\n        // if only one node passed, we start the selection at the top\n        if (_.missing(firstInRange)) {\n            inActiveRange = true;\n        }\n\n        this.nodesAfterSort.forEach(rowNode => {\n            const hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\n            if (inActiveRange || hitFirstOrLast) {\n                result.push(rowNode);\n            }\n\n            if (hitFirstOrLast) {\n                inActiveRange = !inActiveRange;\n            }\n        });\n\n        // inActiveRange will be still true if we never hit the second rowNode\n        const invalidRange = inActiveRange;\n        return invalidRange ? [] : result;\n    }\n\n    public getStoreBounds() {\n        return {\n            topPx: this.topPx,\n            heightPx: this.heightPx,\n        }\n    }\n}", "import {\n    _,\n    Autowired,\n    BeanStub,\n    Events,\n    IServerSideStore,\n    NumberSequence,\n    PostConstruct,\n    PreDestroy,\n    RowBounds,\n    RowNode,\n    ServerSideGroupLevelParams,\n    ServerSideGroupLevelState,\n    ServerSideTransaction,\n    ServerSideTransactionResult,\n    ServerSideTransactionResultStatus,\n    StoreRefreshAfterParams,\n    StoreUpdatedEvent,\n    WithoutGridCommon,\n    Column,\n    ColumnModel,\n    IsApplyServerSideTransactionParams,\n    SelectionChangedEvent,\n    IRowNode,\n    StoreRefreshedEvent,\n    ISelectionService,\n    LoadSuccessParams\n} from \"@ag-grid-community/core\";\nimport { SSRMParams } from \"../../serverSideRowModel\";\nimport { StoreUtils } from \"../storeUtils\";\nimport { BlockUtils } from \"../../blocks/blockUtils\";\nimport { LazyCache } from \"./lazyCache\";\n\nexport class LazyStore extends BeanStub implements IServerSideStore {\n\n    @Autowired('ssrmBlockUtils') private blockUtils: BlockUtils;\n    @Autowired('ssrmStoreUtils') private storeUtils: StoreUtils;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('selectionService') private selectionService: ISelectionService;\n\n    // display indexes\n    private displayIndexStart: number | undefined;\n    private displayIndexEnd: number | undefined;\n\n    // group positioning\n    private topPx: number;\n    private heightPx: number;\n\n    // group details\n    private readonly level: number;\n    private readonly group: boolean;\n    private readonly leafGroup: boolean;\n    private readonly ssrmParams: SSRMParams;\n    private readonly storeParams: ServerSideGroupLevelParams;\n    private readonly parentRowNode: RowNode;\n    private groupField: string | undefined;\n    private rowGroupColumn: Column;\n\n    private idSequence = new NumberSequence();\n    private cache: LazyCache;\n    private info: any;\n\n    constructor(ssrmParams: SSRMParams, storeParams: ServerSideGroupLevelParams, parentRowNode: RowNode) {\n        super();\n        this.ssrmParams = ssrmParams;\n        this.parentRowNode = parentRowNode;\n        this.storeParams = storeParams;\n        this.level = parentRowNode.level + 1;\n        this.group = ssrmParams.rowGroupCols ? this.level < ssrmParams.rowGroupCols.length : false;\n        this.leafGroup = ssrmParams.rowGroupCols ? this.level === ssrmParams.rowGroupCols.length - 1 : false;\n        this.info = {};\n    }\n\n\n    @PostConstruct\n    private init() {\n        let numberOfRows = 1;\n        if (this.level === 0) {\n            numberOfRows = this.storeUtils.getServerSideInitialRowCount() ?? 1;\n\n            this.eventService.dispatchEventOnce({\n                type: Events.EVENT_ROW_COUNT_READY\n            });\n        }\n        this.cache = this.createManagedBean(new LazyCache(this, numberOfRows, this.storeParams));\n\n        const usingTreeData = this.gridOptionsService.get('treeData');\n\n        if (!usingTreeData && this.group) {\n            const groupColVo = this.ssrmParams.rowGroupCols[this.level];\n            this.groupField = groupColVo.field!;\n            this.rowGroupColumn = this.columnModel.getRowGroupColumns()[this.level];\n        }\n    }\n\n    @PreDestroy\n    private destroyRowNodes(): void {\n        this.displayIndexStart = undefined;\n        this.displayIndexEnd = undefined;\n        this.destroyBean(this.cache);\n    }\n\n    /**\n     * Given a server response, ingest the rows outside of the data source lifecycle.\n     * \n     * @param rowDataParams the server response containing the rows to ingest\n     * @param startRow the index to start ingesting rows\n     * @param expectedRows the expected number of rows in the response (used to determine if the last row index is known)\n     */\n    applyRowData(rowDataParams: LoadSuccessParams, startRow: number, expectedRows: number) {\n        this.cache.onLoadSuccess(startRow, expectedRows, rowDataParams);\n    }\n\n    /**\n     * Applies a given transaction to the data set within this store\n     * \n     * @param transaction an object containing delta instructions determining the changes to apply to this store\n     * @returns an object determining the status of this transaction and effected nodes\n     */\n    applyTransaction(transaction: ServerSideTransaction): ServerSideTransactionResult {\n        const idFunc = this.gridOptionsService.getCallback('getRowId');\n        if (!idFunc) {\n            console.warn('AG Grid: getRowId callback must be implemented for transactions to work. Transaction was ignored.');\n            return {\n                status: ServerSideTransactionResultStatus.Cancelled,\n            };\n        }\n\n        const applyCallback = this.gridOptionsService.getCallback('isApplyServerSideTransaction');\n        if (applyCallback) {\n            const params: WithoutGridCommon<IsApplyServerSideTransactionParams> = {\n                transaction: transaction,\n                parentNode: this.parentRowNode,\n                groupLevelInfo: this.info\n            };\n            const apply = applyCallback(params);\n            if (!apply) {\n                return { status: ServerSideTransactionResultStatus.Cancelled };\n            }\n        }\n\n        // needs checked before transactions are applied, as rows won't be contiguous immediately\n        // after\n        const allRowsLoaded = this.cache.isStoreFullyLoaded();\n\n        let updatedNodes: RowNode[] | undefined = undefined;\n        if (transaction.update?.length) {\n            updatedNodes = this.cache.updateRowNodes(transaction.update);\n        }\n\n        let insertedNodes: RowNode[] | undefined = undefined;\n        if (transaction.add?.length) {\n            let addIndex = transaction.addIndex;\n            if (addIndex != null && addIndex < 0) {\n                addIndex = undefined;\n            }\n            insertedNodes = this.cache.insertRowNodes(transaction.add, addIndex);\n        }\n\n        let removedNodes: RowNode[] | undefined = undefined;\n        if (transaction.remove?.length) {\n            const allIdsToRemove = transaction.remove.map(data => (\n                idFunc({ level: this.level, parentKeys: this.parentRowNode.getGroupKeys(), data })\n            ));\n            const allUniqueIdsToRemove = [...new Set(allIdsToRemove)];\n            removedNodes = this.cache.removeRowNodes(allUniqueIdsToRemove);\n        }\n\n        const isClientSideSortingEnabled = this.gridOptionsService.get('serverSideEnableClientSideSort');\n        \n        const isUpdateOrAdd = updatedNodes?.length || insertedNodes?.length;\n        const isClientSideSort = allRowsLoaded && isClientSideSortingEnabled;\n        if (isClientSideSort && isUpdateOrAdd) {\n            // if client side sorting, we need to sort the rows after the transaction\n            this.cache.clientSideSortRows();\n        }\n\n        this.updateSelectionAfterTransaction(updatedNodes, removedNodes);\n        return {\n            status: ServerSideTransactionResultStatus.Applied,\n            update: updatedNodes,\n            add: insertedNodes,\n            remove: removedNodes,\n        }\n    }\n\n    private updateSelectionAfterTransaction(updatedNodes?: RowNode[], removedNodes?: RowNode[]) {\n        const nodesToDeselect: RowNode[] = [];\n        updatedNodes?.forEach(node => {\n            if (node.isSelected() && !node.selectable) {\n                nodesToDeselect.push(node);\n            }\n        });\n\n        removedNodes?.forEach(node => {\n            if (node.isSelected()) {\n                nodesToDeselect.push(node);\n            }\n        });\n\n        if (nodesToDeselect.length) {\n            this.selectionService.setNodesSelected({\n                newValue: false,\n                clearSelection: false,\n                nodes: nodesToDeselect,\n                source: 'rowDataChanged',\n            });\n        }\n    }\n\n    /**\n     * Clear the display indexes, used for fading rows out when stores are not being destroyed\n     */\n    clearDisplayIndexes(): void {\n        this.displayIndexStart = undefined;\n        this.displayIndexEnd = undefined;\n        this.cache.getNodes().forEach(lazyNode => this.blockUtils.clearDisplayIndex(lazyNode.node));\n\n        if (this.parentRowNode.sibling) {\n            this.blockUtils.clearDisplayIndex(this.parentRowNode.sibling);\n        }\n        this.cache.clearDisplayIndexes();\n    }\n\n    /**\n     * @returns an index representing the last sequentially displayed row in the grid for this store\n     */\n    getDisplayIndexStart(): number | undefined {\n        return this.displayIndexStart;\n    }\n\n    /**\n     * @returns the index representing one after the last sequentially displayed row in the grid for this store\n     */\n    getDisplayIndexEnd(): number | undefined {\n        return this.displayIndexEnd;\n    }\n\n    /** \n     * @returns the virtual size of this store\n     */\n    getRowCount(): number {\n        if (this.parentRowNode.sibling) {\n            return this.cache.getRowCount() + 1;\n        }\n        return this.cache.getRowCount();\n    }\n\n    /** \n     * Sets the current row count of the store, and whether the last row index is known\n     */\n    setRowCount(rowCount: number, isLastRowIndexKnown?: boolean): void {\n        this.cache.setRowCount(rowCount, isLastRowIndexKnown);\n    }\n\n    /**\n     * Given a display index, returns whether that row is within this store or a child store of this store\n     * \n     * @param displayIndex the visible index of a row\n     * @returns whether or not the row exists within this store\n     */\n    isDisplayIndexInStore(displayIndex: number): boolean {\n        if (this.cache.getRowCount() === 0) return false;\n\n        return this.displayIndexStart! <= displayIndex && displayIndex < this.getDisplayIndexEnd()!;\n    }\n\n    /**\n     * Recursively sets up the display indexes and top position of every node belonging to this store.\n     * \n     * Called after a row height changes, or a store updated event.\n     * \n     * @param displayIndexSeq the number sequence for generating the display index of each row\n     * @param nextRowTop an object containing the next row top value intended to be modified by ref per row\n     */\n    setDisplayIndexes(displayIndexSeq: NumberSequence, nextRowTop: { value: number; }): void {\n        this.displayIndexStart = displayIndexSeq.peek();\n        this.topPx = nextRowTop.value;\n\n        // delegate to the store to set the row display indexes\n        this.cache.setDisplayIndexes(displayIndexSeq, nextRowTop);\n\n        if (this.parentRowNode.sibling) {\n            this.blockUtils.setDisplayIndex(this.parentRowNode.sibling, displayIndexSeq, nextRowTop);\n        }\n\n        this.displayIndexEnd = displayIndexSeq.peek();\n        this.heightPx = nextRowTop.value - this.topPx;\n    }\n\n    /**\n     * Recursively applies a provided function to every node\n     * \n     * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeepAfterFilterAndSort\n     */\n    forEachStoreDeep(callback: (store: IServerSideStore, index: number) => void, sequence = new NumberSequence()): void {\n        callback(this, sequence.next());\n        this.cache.getNodes().forEach(lazyNode => {\n            const childCache = lazyNode.node.childStore;\n            if (childCache) {\n                childCache.forEachStoreDeep(callback, sequence);\n            }\n        });\n    }\n\n    /**\n     * Recursively applies a provided function to every node\n     * \n     * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeepAfterFilterAndSort\n     */\n    forEachNodeDeep(callback: (rowNode: RowNode<any>, index: number) => void, sequence = new NumberSequence()): void {\n        this.cache.getNodes().forEach(lazyNode => {\n            callback(lazyNode.node, sequence.next());\n            const childCache = lazyNode.node.childStore;\n            if (childCache) {\n                childCache.forEachNodeDeep(callback, sequence);\n            }\n        });\n    }\n\n    /**\n     * Recursively applies a provided function to every node\n     * \n     * For the purpose of exclusively server side filtered stores, this is the same as getNodes().forEachDeep\n     */\n    forEachNodeDeepAfterFilterAndSort(callback: (rowNode: RowNode<any>, index: number) => void, sequence = new NumberSequence(), includeFooterNodes = false): void {\n        const orderedNodes = this.cache.getOrderedNodeMap();\n        for (let key in orderedNodes) {\n            const lazyNode = orderedNodes[key];\n            callback(lazyNode.node, sequence.next());\n            const childCache = lazyNode.node.childStore;\n            if (childCache) {\n                childCache.forEachNodeDeepAfterFilterAndSort(callback, sequence, includeFooterNodes);\n            }\n        }\n\n        if (includeFooterNodes && this.parentRowNode.sibling) {\n            callback(this.parentRowNode.sibling, sequence.next());\n        }\n    }\n\n    /**\n     * Removes the failed status from all nodes, and marks them as stub to encourage reloading\n     */\n    retryLoads(): void {\n        this.cache.getNodes().forEach(({ node }) => {\n            if (node.failedLoad) {\n                node.failedLoad = false;\n                node.__needsRefreshWhenVisible = true;\n                node.stub = true;\n            }\n        });\n        this.forEachChildStoreShallow(store => store.retryLoads());\n        this.fireStoreUpdatedEvent();\n    }\n\n    /**\n     * Given a display index, returns the row at that location.\n     * \n     * @param displayRowIndex the displayed index within the grid to search for\n     * @returns the row node if the display index falls within the store, if it didn't exist this will create a new stub to return\n     */\n    getRowUsingDisplayIndex(displayRowIndex: number): IRowNode<any> | undefined {\n        if (this.parentRowNode.sibling && displayRowIndex === this.parentRowNode.sibling.rowIndex) {\n            return this.parentRowNode.sibling;\n        }\n        return this.cache.getRowByDisplayIndex(displayRowIndex);\n    }\n\n    /**\n     * Given a display index, returns the row top and height for the row at that index.\n     * \n     * @param displayIndex the display index of the node\n     * @returns an object containing the rowTop and rowHeight of the node at the given displayIndex\n     */\n    getRowBounds(displayIndex: number): RowBounds | null {\n        if (!this.isDisplayIndexInStore(displayIndex)) {\n            return null;\n        }\n\n        const thisNode = this.cache.getNodeCachedByDisplayIndex(displayIndex);\n        if (thisNode) {\n            const boundsFromRow = this.blockUtils.extractRowBounds(thisNode, displayIndex);\n            if (boundsFromRow) {\n                return boundsFromRow;\n            }\n        }\n\n        const { previousNode, nextNode } = this.cache.getSurroundingNodesByDisplayIndex(displayIndex) ?? {};\n\n        // previous node may equal, or catch via detail node or child of group\n        if (previousNode) {\n            const boundsFromRow = this.blockUtils.extractRowBounds(previousNode.node, displayIndex);\n            if (boundsFromRow != null) {\n                return boundsFromRow;\n            }\n        }\n    \n        const defaultRowHeight = this.gridOptionsService.getRowHeightAsNumber();\n        // if node after this, can calculate backwards (and ignore detail/grouping)\n        if (nextNode) {\n            const numberOfRowDiff = (nextNode.node.rowIndex! - displayIndex) * defaultRowHeight;\n            return {\n                rowTop: nextNode.node.rowTop! - numberOfRowDiff,\n                rowHeight: defaultRowHeight,\n            };\n        }\n\n        // otherwise calculate from end of store\n        const lastTop = this.topPx + this.heightPx;\n        const numberOfRowDiff = (this.getDisplayIndexEnd()! - displayIndex) * defaultRowHeight;\n        return {\n            rowTop: lastTop - numberOfRowDiff,\n            rowHeight: defaultRowHeight,\n        };\n    }\n\n    /**\n     * Given a vertical pixel, determines whether this store contains a row at that pixel\n     * \n     * @param pixel a vertical pixel position from the grid\n     * @returns whether that pixel points to a virtual space belonging to this store\n     */\n    isPixelInRange(pixel: number): boolean {\n        return pixel >= this.topPx && pixel < (this.topPx + this.heightPx);\n    }\n\n    /**\n     * Given a vertical pixel, returns the row existing at that pixel location\n     * \n     * @param pixel a vertical pixel position from the grid\n     * @returns the display index at the given pixel location\n     */\n    getRowIndexAtPixel(pixel: number): number | null {\n        if (pixel < this.topPx) {\n            return this.getDisplayIndexStart()!;\n        }\n\n        if (pixel >= this.topPx + this.heightPx) {\n            return this.getDisplayIndexEnd()! - 1;\n        }\n    \n        let distToPreviousNodeTop: number = Number.MAX_SAFE_INTEGER;\n        let previousNode: RowNode | null = null;\n        let distToNextNodeTop: number = Number.MAX_SAFE_INTEGER;\n        let nextNode: RowNode | null = null;\n\n        this.cache.getNodes().forEach(({ node }) => {\n            const distBetween = Math.abs(pixel - node.rowTop!);\n    \n            // previous node\n            if (node.rowTop! < pixel) {\n                if (distBetween < distToPreviousNodeTop) {\n                    distToPreviousNodeTop = distBetween;\n                    previousNode = node;\n                }\n                return;\n            }\n            // next node\n            if (distBetween < distToNextNodeTop) {\n                distToNextNodeTop = distBetween;\n                nextNode = node;\n            }\n        });\n\n        // cast these back as typescript doesn't understand the forEach above\n        previousNode = previousNode as RowNode | null;\n        nextNode = nextNode as RowNode | null;\n\n        // previous node may equal, or catch via detail node or child of group\n        if (previousNode) {\n            const indexOfRow = this.blockUtils.getIndexAtPixel(previousNode, pixel);\n            if (indexOfRow != null) {\n                return indexOfRow;\n            }\n        }\n\n        const defaultRowHeight = this.gridOptionsService.getRowHeightAsNumber();\n        // if node after this, can calculate backwards (and ignore detail/grouping)\n        if (nextNode) {\n            const nextTop = nextNode.rowTop!;\n            const numberOfRowDiff = Math.ceil((nextTop - pixel) / defaultRowHeight);\n            return nextNode.rowIndex! - numberOfRowDiff;\n        }\n\n        // otherwise calculate from end of store\n        const nextTop = this.topPx + this.heightPx;\n        const numberOfRowDiff = Math.floor((nextTop - pixel) / defaultRowHeight);\n        return this.getDisplayIndexEnd()! - numberOfRowDiff;\n    }\n\n    /**\n     * Given a path of group keys, returns the child store for that group.\n     * \n     * @param keys the grouping path to the desired store\n     * @returns the child store for the given keys, or null if not found\n     */\n    getChildStore(keys: string[]): IServerSideStore | null {\n        return this.storeUtils.getChildStore(keys, this, (key: string) => {\n            const lazyNode = this.cache.getNodes().find(lazyNode => lazyNode.node.key == key);\n            if (!lazyNode) {\n                return null;\n            }\n            return lazyNode.node;\n        });\n    }\n\n    /**\n     * Executes a provided callback on each child store belonging to this store\n     * \n     * @param cb the callback to execute\n     */\n    private forEachChildStoreShallow(cb: (store: IServerSideStore) => void) {\n        this.cache.getNodes().forEach(({ node }) => {\n            if (node.childStore) {\n                cb(node.childStore);\n            }\n        })\n    }\n\n    /**\n     * Executes after a change to sorting, determines recursively whether this store or a child requires refreshed.\n     * \n     * If a purge refresh occurs, the row count is preserved.\n     * \n     * @param params a set of properties pertaining to the sort changes\n     */\n    refreshAfterSort(params: StoreRefreshAfterParams) {\n        const serverSortsAllLevels = this.storeUtils.isServerSideSortAllLevels();\n        if (serverSortsAllLevels || this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, params)) {\n            const allRowsLoaded = this.cache.isStoreFullyLoaded();\n            const isClientSideSortingEnabled = this.gridOptionsService.get('serverSideEnableClientSideSort');\n            \n            const isClientSideSort = allRowsLoaded && isClientSideSortingEnabled;\n            if (!isClientSideSort) {\n                const oldCount = this.cache.getRowCount();\n                this.destroyBean(this.cache);\n                this.cache = this.createManagedBean(new LazyCache(this, oldCount, this.storeParams));\n                return;\n            }\n\n            // client side sorting only handles one level, so allow it to pass through\n            // to recursive sort.\n            this.cache.clientSideSortRows();\n        }\n\n        // call refreshAfterSort on children, as we did not purge.\n        // if we did purge, no need to do this as all children were destroyed\n        this.forEachChildStoreShallow(store => store.refreshAfterSort(params));\n    }\n\n    /**\n     * Executes after a change to filtering, determines recursively whether this store or a child requires refreshed.\n     * \n     * If a refresh occurs, the row count is reset.\n     * \n     * @param params a set of properties pertaining to the filter changes\n     */\n    refreshAfterFilter(params: StoreRefreshAfterParams) {\n        const serverFiltersAllLevels = !this.storeUtils.isServerSideOnlyRefreshFilteredGroups();\n        if (serverFiltersAllLevels || this.storeUtils.isServerRefreshNeeded(this.parentRowNode, this.ssrmParams.rowGroupCols, params)) {\n            this.refreshStore(true);\n            return;\n        }\n\n        // call refreshAfterFilter on children, as we did not purge.\n        // if we did purge, no need to do this as all children were destroyed\n        this.forEachChildStoreShallow(store => store.refreshAfterFilter(params));\n    }\n\n    /**\n     * Marks all existing nodes as requiring reloaded, and triggers a load check\n     *\n     * @param purge whether to remove all nodes and data in favour of stub nodes\n     */\n    refreshStore(purge: boolean) {\n        if (purge) {\n            this.destroyBean(this.cache);\n            this.cache = this.createManagedBean(new LazyCache(this, 1, this.storeParams));\n            this.fireStoreUpdatedEvent();\n            return;\n        }\n\n        this.cache.markNodesForRefresh();\n    }\n\n    /**\n     * Used for pagination, given a local/store index, returns the display index of that row\n     * \n     * @param topLevelIndex the store index of a row\n     * @returns the display index for the given store index\n     */\n    getTopLevelRowDisplayedIndex(topLevelIndex: number): number {\n        const displayIndex = this.cache.getDisplayIndexFromStoreIndex(topLevelIndex);\n        return displayIndex ?? topLevelIndex;\n    }\n\n    /**\n     * Used for pagination to determine if the last page is known, and for aria to determine if the last grid row is known\n     * \n     * @returns whether the last index of this store is known, or if lazy loading still required\n     */\n    isLastRowIndexKnown(): boolean {\n        return this.cache.isLastRowIndexKnown();\n    }\n\n    /**\n     * Used by the selection service to select a range of nodes\n     * \n     * @param firstInRange the first node in the range to find\n     * @param lastInRange the last node in the range to find\n     * @returns a range of nodes between firstInRange and lastInRange inclusive\n     */\n    getRowNodesInRange(firstInRange: RowNode<any>, lastInRange: RowNode<any>): RowNode<any>[] {\n        const result: RowNode[] = [];\n\n        let inActiveRange = false;\n\n        // if only one node passed, we start the selection at the top\n        if (_.missing(firstInRange)) {\n            inActiveRange = true;\n        }\n\n        return this.cache.getNodes().filter(({ node }) => {\n            return node.rowIndex! >= firstInRange.rowIndex! &&  node.rowIndex! <= lastInRange.rowIndex!;\n        }).map(({ node }) => node);\n    }\n\n    /**\n     * Mutates a given array to add this stores state, and recursively add all the children store states.\n     * \n     * @param result a mutable results array\n     */\n    addStoreStates(result: ServerSideGroupLevelState[]) {\n        result.push({\n            suppressInfiniteScroll: false,\n            route: this.parentRowNode.getGroupKeys(),\n            rowCount: this.getRowCount(),\n            lastRowIndexKnown: this.isLastRowIndexKnown(),\n            info: this.info,\n            maxBlocksInCache: this.storeParams.maxBlocksInCache,\n            cacheBlockSize: this.storeParams.cacheBlockSize,\n        });\n        this.forEachChildStoreShallow(childStore => childStore.addStoreStates(result));\n    }\n\n    public getIdSequence() {\n        return this.idSequence;\n    }\n\n    public getParentNode() {\n        return this.parentRowNode;\n    }\n\n    public getRowDetails() {\n        return {\n            field: this.groupField!,\n            group: this.group,\n            leafGroup: this.leafGroup,\n            level: this.level,\n            parent: this.parentRowNode,\n            rowGroupColumn: this.rowGroupColumn,\n        };\n    }\n\n    public getSsrmParams() {\n        return this.ssrmParams;\n    }\n\n    public setStoreInfo(info: any) {\n        if (info) {\n            Object.assign(this.info, info);\n        }\n    }\n\n    // gets called 1) row count changed 2) cache purged\n    public fireStoreUpdatedEvent(): void {\n        // this results in row model firing ModelUpdated.\n        // server side row model also updates the row indexes first\n        const event: WithoutGridCommon<StoreUpdatedEvent> = {\n            type: Events.EVENT_STORE_UPDATED\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    // gets called when row data updated, and no more refreshing needed\n    public fireRefreshFinishedEvent(): void {\n        const event: WithoutGridCommon<StoreRefreshedEvent> = {\n            type: Events.EVENT_STORE_REFRESHED,\n            route: this.parentRowNode.getRoute(),\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    public getBlockStates() {\n        return this.cache.getBlockStates();\n    }\n\n    public getStoreBounds() {\n        return {\n            topPx: this.topPx,\n            heightPx: this.heightPx,\n        }\n    }\n\n    public getCache() {\n        return this.cache;\n    }\n}\n", "import { Autowired, BeanStub, FocusService, GridApi, LoadSuccessParams, NumberSequence, PostConstruct, PreDestroy, RowNode, IRowNode, ServerSideGroupLevelParams, WithoutGridCommon, GetRowIdParams } from \"@ag-grid-community/core\";\nimport { BlockUtils } from \"../../blocks/blockUtils\";\nimport { NodeManager } from \"../../nodeManager\";\nimport { LazyStore } from \"./lazyStore\";\nimport { MultiIndexMap } from \"./multiIndexMap\";\nimport { ServerSideRowModel } from \"../../serverSideRowModel\";\nimport { RowNodeSorter } from \"@ag-grid-community/core\";\nimport { SortController } from \"@ag-grid-community/core\";\nimport { LazyBlockLoadingService } from \"./lazyBlockLoadingService\";\n\ninterface LazyStoreNode {\n    id: string;\n    index: number;\n    node: RowNode;\n};\n\nexport class LazyCache extends BeanStub {\n    @Autowired('gridApi') private api: GridApi;\n    @Autowired('ssrmBlockUtils') private blockUtils: BlockUtils;\n    @Autowired('focusService') private focusService: FocusService;\n    @Autowired('ssrmNodeManager') private nodeManager: NodeManager;\n    @Autowired('rowModel') private serverSideRowModel: ServerSideRowModel;\n    @Autowired('rowNodeSorter') private rowNodeSorter: RowNodeSorter;\n    @Autowired('sortController') private sortController: SortController;\n    @Autowired('lazyBlockLoadingService') private lazyBlockLoadingService: LazyBlockLoadingService;\n\n    /**\n     * Indicates whether this is still the live dataset for this store (used for ignoring old requests after purge)\n     */\n    private live = true;\n\n    /**\n     * A node map indexed by the node's id, index, and node.\n     */\n    private nodeMap: MultiIndexMap<LazyStoreNode>;\n\n    /**\n     * A map of nodes indexed by the display index.\n     */\n    private nodeDisplayIndexMap: Map<number, RowNode>;\n\n    /**\n     * A set of nodes waiting to be refreshed\n     */\n    private nodesToRefresh: Set<RowNode>;\n\n    /**\n     * End of store properties\n     */\n    private numberOfRows: number;\n    private isLastRowKnown: boolean;\n\n    /**\n     * The prefix to use for node ids, this is used to ensure that node ids are unique across stores\n     */\n    private defaultNodeIdPrefix: string | undefined;\n\n    /**\n     * Sibling services - 1-1 relationships.\n     */\n    private store: LazyStore;\n    private storeParams: ServerSideGroupLevelParams;\n\n    /**\n     * Grid options properties - stored locally for access speed.\n     */\n    private getRowIdFunc?: ((params: WithoutGridCommon<GetRowIdParams<any, any>>) => string);\n    private isMasterDetail: boolean;\n\n    /**\n     * A cache of removed group nodes, this is retained for preserving group\n     * state when the node moves in and out of the cache. Generally caused by\n     * rows moving blocks.\n     */\n    private removedNodeCache = new Map<string, RowNode>();\n\n    constructor(store: LazyStore, numberOfRows: number, storeParams: ServerSideGroupLevelParams) {\n        super();\n        this.store = store;\n        this.numberOfRows = numberOfRows;\n        this.isLastRowKnown = false;\n        this.storeParams = storeParams;\n    }\n\n    @PostConstruct\n    private init() {\n        this.lazyBlockLoadingService.subscribe(this);\n        // initiate the node map to be indexed at 'index', 'id' and 'node' for quick look-up.\n        // it's important id isn't first, as stub nodes overwrite each-other, and the first index is\n        // used for iteration.\n        this.nodeMap = new MultiIndexMap('index', 'id', 'node');\n\n        this.nodeDisplayIndexMap = new Map();\n        this.nodesToRefresh = new Set();\n\n        this.defaultNodeIdPrefix = this.blockUtils.createNodeIdPrefix(this.store.getParentNode());\n        this.getRowIdFunc = this.gridOptionsService.getCallback('getRowId');\n        this.isMasterDetail = this.gridOptionsService.get('masterDetail');\n    }\n\n    @PreDestroy\n    private destroyRowNodes() {\n        this.lazyBlockLoadingService.unsubscribe(this);\n        this.numberOfRows = 0;\n        this.nodeMap.forEach(node => this.blockUtils.destroyRowNode(node.node));\n        this.nodeMap.clear();\n        this.nodeDisplayIndexMap.clear();\n        this.nodesToRefresh.clear();\n        this.live = false;\n    }\n\n    /**\n     * Get the row node for a specific display index from this store\n     * @param displayIndex the display index of the node to find\n     * @returns undefined if the node is not in the store bounds, otherwise will always return a node\n     */\n    public getRowByDisplayIndex(displayIndex: number): IRowNode | undefined {\n        // if index isn't in store, nothing to return\n        if (!this.store.isDisplayIndexInStore(displayIndex)) {\n            return undefined;\n        }\n\n        // first try to directly look this node up in the display index map\n        const node = this.nodeDisplayIndexMap.get(displayIndex);\n        if (node) {\n            // if we have the node, check if it needs refreshed when rendered\n            if (node.stub || node.__needsRefreshWhenVisible) {\n                this.lazyBlockLoadingService.queueLoadCheck();\n            }\n            return node;\n        }\n\n        // next check if this is the first row, if so return a stub node\n        // this is a performance optimisation, as it is the most common scenario\n        // and enables the node - 1 check to kick in more often.\n        if (displayIndex === this.store.getDisplayIndexStart()) {\n            return this.createStubNode(0, displayIndex);\n        }\n\n        // check if the row immediately prior is available in the store\n        const contiguouslyPreviousNode = this.nodeDisplayIndexMap.get(displayIndex - 1);\n        if (contiguouslyPreviousNode) {\n            // if previous row is master detail, and expanded, this node must be detail\n            if (this.isMasterDetail && contiguouslyPreviousNode.master && contiguouslyPreviousNode.expanded) {\n                return contiguouslyPreviousNode.detailNode;\n            }\n\n            // if previous row is expanded group, this node will belong to that group.\n            if (contiguouslyPreviousNode.expanded && contiguouslyPreviousNode.childStore?.isDisplayIndexInStore(displayIndex)) {\n                return contiguouslyPreviousNode.childStore?.getRowUsingDisplayIndex(displayIndex);\n            }\n\n            // otherwise, row must be a stub node\n            const lazyCacheNode = this.nodeMap.getBy('node', contiguouslyPreviousNode)!;\n            return this.createStubNode(lazyCacheNode.index + 1, displayIndex);\n        }\n\n        const adjacentNodes = this.getSurroundingNodesByDisplayIndex(displayIndex);\n\n        // if no bounds skipped includes this, calculate from end index\n        if (adjacentNodes == null) {\n            const storeIndexFromEndIndex = this.store.getRowCount() - (this.store.getDisplayIndexEnd()! - displayIndex);\n            return this.createStubNode(storeIndexFromEndIndex, displayIndex);\n        }\n\n        const {previousNode, nextNode} = adjacentNodes;\n\n        // if the node before this node is expanded, this node might be a child of that node\n        if (previousNode && previousNode.node.expanded && previousNode.node.childStore?.isDisplayIndexInStore(displayIndex)) {\n            return previousNode.node.childStore?.getRowUsingDisplayIndex(displayIndex);\n        }\n\n        // if we have the node after this node, we can calculate the store index of this node by the difference\n        // in display indexes between the two nodes.\n        if (nextNode) {\n            const displayIndexDiff = nextNode.node.rowIndex! - displayIndex;\n            const newStoreIndex = nextNode.index - displayIndexDiff;\n            return this.createStubNode(newStoreIndex, displayIndex);\n        }\n\n        // if no next node, calculate from end index of this store\n        const storeIndexFromEndIndex = this.store.getRowCount() - (this.store.getDisplayIndexEnd()! - displayIndex);\n        return this.createStubNode(storeIndexFromEndIndex, displayIndex);\n    }\n\n    /**\n     * Used for creating and positioning a stub node without firing a store updated event\n     */\n    private createStubNode(storeIndex: number, displayIndex: number): RowNode {\n        // bounds are acquired before creating the node, as otherwise it'll use it's own empty self to calculate\n        const rowBounds = this.store.getRowBounds(displayIndex!);\n        const newNode = this.createRowAtIndex(storeIndex, null, node => {\n            node.setRowIndex(displayIndex);\n            node.setRowTop(rowBounds!.rowTop);\n            this.nodeDisplayIndexMap.set(displayIndex, node);\n        });\n        this.lazyBlockLoadingService.queueLoadCheck();\n        return newNode;\n    }\n\n    /**\n     * @param index The row index relative to this store\n     * @returns A rowNode at the given store index\n     */\n    public getRowByStoreIndex(index: number) {\n        return this.nodeMap.getBy('index', index)?.node;\n    }\n\n    /**\n     * Given a number of rows, skips through the given sequence & row top reference (using default row height)\n     * @param numberOfRowsToSkip number of rows to skip over in the given sequence\n     * @param displayIndexSeq the sequence in which to skip\n     * @param nextRowTop the row top reference in which to skip\n     */\n    private skipDisplayIndexes(numberOfRowsToSkip: number, displayIndexSeq: NumberSequence, nextRowTop: { value: number; }) {\n        if (numberOfRowsToSkip === 0) {\n            return;\n        }\n        const defaultRowHeight = this.gridOptionsService.getRowHeightAsNumber();\n\n        displayIndexSeq.skip(numberOfRowsToSkip);\n        nextRowTop.value += numberOfRowsToSkip * defaultRowHeight;\n    }\n\n    /**\n     * @param displayIndexSeq the number sequence for generating the display index of each row\n     * @param nextRowTop an object containing the next row top value intended to be modified by ref per row\n     */\n    public setDisplayIndexes(displayIndexSeq: NumberSequence, nextRowTop: { value: number; }): void {\n        // Create a map of display index nodes for access speed\n        this.nodeDisplayIndexMap.clear();\n\n        // create an object indexed by store index, as this will sort all of the nodes when we iterate\n        // the object\n        const orderedMap: {[key: number]: RowNode} = {};\n        this.nodeMap.forEach(lazyNode => {\n            orderedMap[lazyNode.index] = lazyNode.node;\n        });\n\n        let lastIndex = -1;\n        // iterate over the nodes in order, setting the display index on each node.\n        for (const stringIndex in orderedMap) {\n            const node = orderedMap[stringIndex];\n            const numericIndex = Number(stringIndex);\n\n            // if any nodes aren't currently in the store, skip the display indexes too\n            const numberOfRowsToSkip = (numericIndex - 1) - lastIndex;\n            this.skipDisplayIndexes(numberOfRowsToSkip, displayIndexSeq, nextRowTop);\n\n\n            // set this nodes index and row top\n            this.blockUtils.setDisplayIndex(node, displayIndexSeq, nextRowTop);\n            this.nodeDisplayIndexMap.set(node.rowIndex!, node);\n\n\n\n            // store this index for skipping after this\n            lastIndex = numericIndex;\n        }\n\n        // need to skip rows until the end of this store\n        const numberOfRowsToSkip = (this.numberOfRows - 1) - lastIndex;\n        this.skipDisplayIndexes(numberOfRowsToSkip, displayIndexSeq, nextRowTop);\n\n        // this is not terribly efficient, and could probs be improved\n        this.purgeExcessRows();\n    }\n\n    public getRowCount(): number {\n        return this.numberOfRows;\n    }\n    \n    setRowCount(rowCount: number, isLastRowIndexKnown?: boolean): void {\n        if (rowCount < 0) {\n            throw new Error('AG Grid: setRowCount can only accept a positive row count.');\n        }\n\n        this.numberOfRows = rowCount;\n\n        if (isLastRowIndexKnown != null) {\n            this.isLastRowKnown = isLastRowIndexKnown;\n\n            if (isLastRowIndexKnown === false) {\n                this.numberOfRows += 1;\n            }\n        }\n\n        this.fireStoreUpdatedEvent();\n    }\n\n    public getNodes() {\n        return this.nodeMap;\n    }\n\n    public getNodeCachedByDisplayIndex(displayIndex: number): RowNode | null {\n        return this.nodeDisplayIndexMap.get(displayIndex) ?? null;\n    }\n\n    public getNodesToRefresh(): Set<RowNode> {\n        return this.nodesToRefresh;\n    }\n\n    /**\n     * @returns the previous and next loaded row nodes surrounding the given display index\n     */\n    public getSurroundingNodesByDisplayIndex(displayIndex: number) {\n        let nextNode: LazyStoreNode | undefined;\n        let previousNode: LazyStoreNode | undefined;\n        this.nodeMap.forEach(lazyNode => {\n            // previous node\n            if (displayIndex > lazyNode.node.rowIndex!) {\n                // get the largest previous node\n                if (previousNode == null || previousNode.node.rowIndex! < lazyNode.node.rowIndex!) {\n                    previousNode = lazyNode;\n                }\n                return;\n            }\n            // next node\n            // get the smallest next node\n            if (nextNode == null || nextNode.node.rowIndex! > lazyNode.node.rowIndex!) {\n                nextNode = lazyNode;\n                return;\n            }\n        });\n        if (!previousNode && !nextNode) return null;\n        return {previousNode, nextNode};\n    }\n\n    /**\n     * Get or calculate the display index for a given store index\n     * @param storeIndex the rows index within this store\n     * @returns the rows visible display index relative to the grid\n     */\n    public getDisplayIndexFromStoreIndex(storeIndex: number): number | null {\n\n        const nodeAtIndex = this.nodeMap.getBy('index', storeIndex);\n        if (nodeAtIndex) {\n            return nodeAtIndex.node.rowIndex!;\n        }\n\n        let nextNode: LazyStoreNode | undefined;\n        let previousNode: LazyStoreNode | undefined;\n        this.nodeMap.forEach(lazyNode => {\n            // previous node\n            if (storeIndex > lazyNode.index) {\n                // get the largest previous node\n                if (previousNode == null || previousNode.index < lazyNode.index) {\n                    previousNode = lazyNode;\n                }\n                return;\n            }\n            // next node\n            // get the smallest next node\n            if (nextNode == null || nextNode.index > lazyNode.index) {\n                nextNode = lazyNode;\n                return;\n            }\n        });\n\n        if (!nextNode) {\n            return this.store.getDisplayIndexEnd()! - (this.numberOfRows - storeIndex);\n        }\n\n        if (!previousNode) {\n            return this.store.getDisplayIndexStart()! + storeIndex;\n        }\n\n        const storeIndexDiff = storeIndex - previousNode.index;\n        const previousDisplayIndex = (previousNode.node.childStore?.getDisplayIndexEnd() ?? previousNode.node.rowIndex!);\n        return previousDisplayIndex + storeIndexDiff;\n    }\n\n    /**\n     * Creates a new row and inserts it at the given index\n     * @param atStoreIndex the node index relative to this store\n     * @param data the data object to populate the node with \n     * @returns the new row node\n     */\n    private createRowAtIndex(atStoreIndex: number, data?: any, createNodeCallback?: (node: RowNode) => void): RowNode {\n        // make sure an existing node isn't being overwritten\n        const lazyNode = this.nodeMap.getBy('index', atStoreIndex);\n\n        // if node already exists, update it or destroy it\n        if (lazyNode) {\n            const { node } = lazyNode;\n            node.__needsRefreshWhenVisible = false;\n\n            // if the node is the same, just update the content\n            if (this.doesNodeMatch(data, node)) {\n                this.blockUtils.updateDataIntoRowNode(node, data);\n                this.nodesToRefresh.delete(node);\n                return node;\n            }\n\n            // if there's no id and this is an open group, protect this node from changes\n            // hasChildren also checks for tree data and master detail\n            if (this.getRowIdFunc == null && node.hasChildren() && node.expanded) {\n                this.nodesToRefresh.delete(node);\n                return node;\n            }\n\n            // destroy the old node, might be worth caching state here\n            this.destroyRowAtIndex(atStoreIndex);\n        }\n\n        // if the node already exists elsewhere, update it and move it to the new location\n        if (data && this.getRowIdFunc != null) {\n            const id = this.getRowId(data);\n\n            // the node was deleted at some point, but as we're refreshing\n            // it's been cached and we can retrieve it for reuse.\n            const deletedNode = id && this.removedNodeCache?.get(id);\n            if (deletedNode) {\n                this.removedNodeCache?.delete(id!);\n                this.blockUtils.updateDataIntoRowNode(deletedNode, data);\n                this.nodeMap.set({\n                    id: deletedNode.id!,\n                    node: deletedNode,\n                    index: atStoreIndex\n                });\n                return deletedNode;\n            }\n\n            const lazyNode = this.nodeMap.getBy('id', id);\n            if (lazyNode) {\n                // delete old lazy node so we can insert it at different location\n                this.nodeMap.delete(lazyNode);\n\n                const { node, index } = lazyNode;\n                this.blockUtils.updateDataIntoRowNode(node, data);\n                this.nodeMap.set({\n                    id: node.id!,\n                    node,\n                    index: atStoreIndex\n                });\n                this.nodesToRefresh.delete(node);\n\n                if (this.getBlockStartIndex(index) === this.getBlockStartIndex(atStoreIndex)) {\n                    // if the block hasn't changed and we have a nodes map, we don't need to refresh the original block, as this block\n                    // has just been refreshed.\n                    return node;\n                }\n\n                // mark all of the old block as needsVerify to trigger it for a refresh, as nodes\n                // should not be out of place\n                this.markBlockForVerify(index);\n\n                return node;\n            }\n        }\n\n        // node doesn't exist, create a new one\n        const newNode = this.blockUtils.createRowNode(this.store.getRowDetails());\n        if (data != null) {\n            const defaultId = this.getPrefixedId(this.store.getIdSequence().next());\n            this.blockUtils.setDataIntoRowNode(newNode, data, defaultId, undefined);\n\n            // don't allow the SSRM to listen to the dispatched row event, as it will\n            // compute extra unnecessary row updates\n            this.serverSideRowModel.setPaused(true);\n            this.blockUtils.checkOpenByDefault(newNode);\n            this.serverSideRowModel.setPaused(false);\n            this.nodeManager.addRowNode(newNode);\n        }\n\n        // add the new node to the store, has to be done after the display index is calculated so it doesn't take itself into account\n        this.nodeMap.set({\n            id: newNode.id!,\n            node: newNode,\n            index: atStoreIndex,\n        });\n\n        if (createNodeCallback) {\n            createNodeCallback(newNode);\n        }\n\n        return newNode;\n    }\n\n    public getBlockStates() {\n        const blockCounts: { [key: string]: number } = {};\n        const blockStates: { [key: string]: Set<string> } = {};\n\n        this.nodeMap.forEach(({ node, index }) => {\n            const blockStart = this.getBlockStartIndex(index);\n\n            if (!node.stub && !node.failedLoad) {\n                blockCounts[blockStart] = (blockCounts[blockStart] ?? 0) + 1;\n            }\n\n            let rowState = 'loaded';\n            if (node.failedLoad) {\n                rowState = 'failed';\n            } else if (this.lazyBlockLoadingService.isRowLoading(this, blockStart)) {\n                rowState = 'loading';\n            } else if (this.nodesToRefresh.has(node) || node.stub) {\n                rowState = 'needsLoading';\n            }\n\n            if (!blockStates[blockStart]) {\n                blockStates[blockStart] = new Set<string>();\n            }\n            blockStates[blockStart].add(rowState);\n        });\n\n        const statePriorityMap: { [key: string]: number } = {\n            loading: 4,\n            failed: 3,\n            needsLoading: 2,\n            loaded: 1,\n        };\n\n        const blockPrefix = this.blockUtils.createNodeIdPrefix(this.store.getParentNode());\n\n        const results: { [key: string]: any } = {};\n        Object.entries(blockStates).forEach(([blockStart, uniqueStates]) => {\n            const sortedStates = [...uniqueStates].sort((a, b) => (statePriorityMap[a] ?? 0) - (statePriorityMap[b] ?? 0));\n            const priorityState = sortedStates[0];\n\n            const blockNumber = Number(blockStart) / this.getBlockSize();\n\n            const blockId = blockPrefix ? `${blockPrefix}-${blockNumber}` : String(blockNumber);\n            results[blockId] = {\n                blockNumber,\n                startRow: Number(blockStart),\n                endRow: Number(blockStart) + this.getBlockSize(),\n                pageStatus: priorityState,\n                loadedRowCount: blockCounts[blockStart] ?? 0,\n            };\n        });\n        return results;\n    }\n\n    public destroyRowAtIndex(atStoreIndex: number) {\n        const lazyNode = this.nodeMap.getBy('index', atStoreIndex);\n        if (!lazyNode) { return; }\n\n        this.nodeMap.delete(lazyNode);\n        \n        this.nodeDisplayIndexMap.delete(lazyNode.node.rowIndex!);\n        \n        if (this.nodesToRefresh.size > 0) {\n            // while refreshing, we retain the group nodes so they can be moved\n            // without losing state\n            this.removedNodeCache.set(lazyNode.node.id!, lazyNode.node);\n        } else {\n            this.blockUtils.destroyRowNode(lazyNode.node);\n        }\n\n        this.nodesToRefresh.delete(lazyNode.node);\n    }\n\n    public getSsrmParams() {\n        return this.store.getSsrmParams();\n    }\n\n    /**\n     * @param id the base id to be prefixed\n     * @returns a node id with prefix if required\n     */\n    private getPrefixedId(id: number): string {\n        if (this.defaultNodeIdPrefix) {\n            return this.defaultNodeIdPrefix + '-' + id;\n        } else {\n            return id.toString();\n        }\n    }\n\n    private markBlockForVerify(rowIndex: number) {\n        const [start, end] = this.getBlockBounds(rowIndex);\n        const lazyNodesInRange = this.nodeMap.filter((lazyNode) => lazyNode.index >= start && lazyNode.index < end);\n        lazyNodesInRange.forEach(({ node }) => {\n            node.__needsRefreshWhenVisible = true;\n        });\n    }\n\n    private doesNodeMatch(data: any, node: RowNode): boolean {\n        if (node.stub) {\n            return false;\n        }\n\n        if (this.getRowIdFunc != null) {\n            const id: string = this.getRowId(data)!;\n            return node.id === id;\n        }\n        return node.data === data;\n    }\n\n    /**\n     * Deletes any stub nodes not within the given range\n     */\n    public purgeStubsOutsideOfViewport() {\n        const firstRow = this.api.getFirstDisplayedRowIndex();\n        const lastRow = this.api.getLastDisplayedRowIndex();\n        const firstRowBlockStart = this.getBlockStartIndex(firstRow);\n        const [_, lastRowBlockEnd] = this.getBlockBounds(lastRow);\n\n        this.nodeMap.forEach(lazyNode => {\n            // failed loads are still useful, so we don't purge them\n            if (this.lazyBlockLoadingService.isRowLoading(this, lazyNode.index) || lazyNode.node.failedLoad) {\n                return;\n            }\n            if (lazyNode.node.stub && (lazyNode.index < firstRowBlockStart || lazyNode.index > lastRowBlockEnd)) {\n                this.destroyRowAtIndex(lazyNode.index);\n            }\n        });\n    }\n\n    private getBlocksDistanceFromRow(nodes: LazyStoreNode[], otherDisplayIndex: number) {\n        const blockDistanceToMiddle: { [key: number]: number } = {};\n        nodes.forEach(({ node, index }) => {\n            const [blockStart, blockEnd] = this.getBlockBounds(index);\n            if (blockStart in blockDistanceToMiddle) {\n                return;\n            }\n            const distStart = Math.abs(node.rowIndex! - otherDisplayIndex);\n            let distEnd;\n            // may not have an end node if the block came back small \n            const lastLazyNode = this.nodeMap.getBy('index', [blockEnd - 1]);\n            if (lastLazyNode) distEnd = Math.abs(lastLazyNode.node.rowIndex! - otherDisplayIndex);\n            const farthest = distEnd == null || distStart < distEnd ? distStart : distEnd;\n\n            blockDistanceToMiddle[blockStart] = farthest;\n        });\n        return Object.entries(blockDistanceToMiddle);\n    }\n\n    private purgeExcessRows() {\n        // Delete all stub nodes which aren't in the viewport or already loading\n        this.purgeStubsOutsideOfViewport();\n\n        if (this.store.getDisplayIndexEnd() == null || this.storeParams.maxBlocksInCache == null) {\n            // if group is collapsed, or max blocks missing, ignore the event\n            return;\n        }\n\n        const firstRowInViewport = this.api.getFirstDisplayedRowIndex();\n        const lastRowInViewport = this.api.getLastDisplayedRowIndex();\n\n        // the start storeIndex of every block in this store\n        const allLoadedBlocks: Set<number> = new Set();\n        // the start storeIndex of every displayed block in this store\n        const blocksInViewport: Set<number> = new Set();\n        this.nodeMap.forEach(({ index, node }) => {\n            const blockStart = this.getBlockStartIndex(index);\n            allLoadedBlocks.add(blockStart);\n\n            const isInViewport = node.rowIndex! >= firstRowInViewport && node.rowIndex! <= lastRowInViewport;\n            if (isInViewport) {\n                blocksInViewport.add(blockStart);\n            }\n        });\n\n        // if the viewport is larger than the max blocks, then the viewport size is minimum cache size\n        const numberOfBlocksToRetain = Math.max(blocksInViewport.size, this.storeParams.maxBlocksInCache ?? 0);\n\n        // ensure there is blocks that can be removed\n        const loadedBlockCount = allLoadedBlocks.size;\n        const blocksToRemove = loadedBlockCount - numberOfBlocksToRetain;\n        if (blocksToRemove <= 0) {\n            return;\n        }\n\n        // the first and last block in the viewport\n        let firstRowBlockStart = Number.MAX_SAFE_INTEGER;\n        let lastRowBlockStart = Number.MIN_SAFE_INTEGER;\n        blocksInViewport.forEach(blockStart => {\n            if (firstRowBlockStart > blockStart) {\n                firstRowBlockStart = blockStart;\n            }\n\n            if (lastRowBlockStart < blockStart) {\n                lastRowBlockStart = blockStart;\n            }\n        });\n\n        // all nodes which aren't cached or in the viewport, and so can be removed\n        const disposableNodes = this.nodeMap.filter(({ node, index }) => {\n            const rowBlockStart = this.getBlockStartIndex(index);\n            const rowBlockInViewport = rowBlockStart >= firstRowBlockStart && rowBlockStart <= lastRowBlockStart;\n\n            return !rowBlockInViewport && !this.isNodeCached(node);\n        });\n\n        if (disposableNodes.length === 0) {\n            return;\n        }\n\n        const midViewportRow = firstRowInViewport + ((lastRowInViewport - firstRowInViewport) / 2);\n        const blockDistanceArray = this.getBlocksDistanceFromRow(disposableNodes, midViewportRow);\n        const blockSize = this.getBlockSize();\n\n        // sort the blocks by distance from middle of viewport\n        blockDistanceArray.sort((a, b) => Math.sign(b[1] - a[1]));\n\n        // remove excess blocks, starting from furthest from viewport\n        for (let i = 0; i < Math.min(blocksToRemove, blockDistanceArray.length); i++) {\n            const blockStart = Number(blockDistanceArray[i][0]);\n            for (let x = blockStart; x < blockStart + blockSize; x++) {\n                const lazyNode = this.nodeMap.getBy('index', x);\n                if (!lazyNode || this.isNodeCached(lazyNode.node)) {\n                    continue;\n                }\n                this.destroyRowAtIndex(x);\n            }\n        }\n    }\n\n    private isNodeFocused(node: RowNode): boolean {\n        const focusedCell = this.focusService.getFocusCellToUseAfterRefresh();\n        if (!focusedCell) { return false; }\n        if (focusedCell.rowPinned != null) { return false; }\n\n        const hasFocus = focusedCell.rowIndex === node.rowIndex;\n        return hasFocus;\n    }\n\n    private isNodeCached(node: RowNode): boolean {\n        return (node.isExpandable() && node.expanded) || this.isNodeFocused(node);\n    }\n\n    private extractDuplicateIds(rows: any[]) {\n        if (this.getRowIdFunc == null) {\n            return [];\n        }\n\n        const newIds = new Set();\n        const duplicates = new Set();\n        rows.forEach(data => {\n            const id = this.getRowId(data);\n            if (newIds.has(id)) {\n                duplicates.add(id);\n                return;\n            }\n            newIds.add(id);\n        });\n\n        return [...duplicates];\n    }\n\n    public onLoadSuccess(firstRowIndex: number, numberOfRowsExpected: number, response: LoadSuccessParams) {\n        if (!this.live) return;\n\n        const info = response.groupLevelInfo;\n        this.store.setStoreInfo(info);\n    \n        if (this.getRowIdFunc != null) {\n            const duplicates = this.extractDuplicateIds(response.rowData);\n            if (duplicates.length > 0) {\n                const duplicateIdText = duplicates.join(', ');\n                console.warn(`AG Grid: Unable to display rows as duplicate row ids (${duplicateIdText}) were returned by the getRowId callback. Please modify the getRowId callback to provide unique ids.`);\n                this.onLoadFailed(firstRowIndex, numberOfRowsExpected);\n                return;\n            }\n        }\n\n        if (response.pivotResultFields) {\n            this.serverSideRowModel.generateSecondaryColumns(response.pivotResultFields);\n        }\n        \n        const wasRefreshing = this.nodesToRefresh.size > 0;\n        response.rowData.forEach((data, responseRowIndex) => {\n            const rowIndex = firstRowIndex + responseRowIndex;\n            const nodeFromCache = this.nodeMap.getBy('index', rowIndex);\n        \n            // if stub, overwrite\n            if (nodeFromCache?.node?.stub) {\n                this.createRowAtIndex(rowIndex, data);\n                return;\n            }\n\n            // node already exists, and same as node at designated position, update data\n            if (nodeFromCache && this.doesNodeMatch(data, nodeFromCache.node)) {\n                this.blockUtils.updateDataIntoRowNode(nodeFromCache.node, data);\n                this.nodesToRefresh.delete(nodeFromCache.node);\n                nodeFromCache.node.__needsRefreshWhenVisible = false;\n                return;\n            }\n            // create row will handle deleting the overwritten row\n            this.createRowAtIndex(rowIndex, data);\n        });\n\n        if (response.rowCount != undefined && response.rowCount !== -1) {\n            // if the rowCount has been provided, set the row count\n            this.numberOfRows = response.rowCount;\n            this.isLastRowKnown = true;\n        } else if (numberOfRowsExpected > response.rowData.length) {\n            // infer the last row as the response came back short\n            this.numberOfRows = firstRowIndex + response.rowData.length;\n            this.isLastRowKnown = true;\n        } else if (!this.isLastRowKnown) {\n            // add 1 for loading row, as we don't know the last row\n            const lastInferredRow = firstRowIndex + response.rowData.length + 1;\n            if (lastInferredRow > this.numberOfRows) {\n                this.numberOfRows = lastInferredRow;\n            }\n        }\n\n        if (this.isLastRowKnown) {\n            // delete any rows after the last index\n            const lazyNodesAfterStoreEnd = this.nodeMap.filter(lazyNode => lazyNode.index >= this.numberOfRows);\n            lazyNodesAfterStoreEnd.forEach(lazyNode => this.destroyRowAtIndex(lazyNode.index));\n        }\n\n        this.fireStoreUpdatedEvent();\n\n        // Happens after store updated, as store updating can clear our excess rows.\n        const finishedRefreshing = this.nodesToRefresh.size === 0;\n        if (wasRefreshing && finishedRefreshing) {\n            this.fireRefreshFinishedEvent();\n        }\n    }\n\n    public fireRefreshFinishedEvent() {\n        const finishedRefreshing = this.nodesToRefresh.size === 0;\n        // if anything refreshing currently, skip.\n        if (!finishedRefreshing) {\n            return;\n        }\n\n        // any nodes left in the map need to be cleaned up, this prevents us preserving nodes\n        // indefinitely\n        this.removedNodeCache.forEach(node => {\n            this.blockUtils.destroyRowNode(node);\n        });\n        this.removedNodeCache = new Map();\n\n        this.store.fireRefreshFinishedEvent();\n    }\n\n    /**\n     * @returns true if all rows are loaded\n     */\n    public isStoreFullyLoaded() {\n        const knowsSize = this.isLastRowKnown;\n        const hasCorrectRowCount = this.nodeMap.getSize() === this.numberOfRows;\n        if (!knowsSize || !hasCorrectRowCount) {\n            return;\n        }\n\n        if (this.nodesToRefresh.size > 0) {\n            return;\n        }\n\n        // nodeMap find cancels early when it finds a matching record.\n        // better to use this than forEach\n        let index = -1;\n        const firstOutOfPlaceNode = this.nodeMap.find(lazyNode => {\n            index += 1;\n            // node not contiguous, nodes must be missing\n            if (lazyNode.index !== index) {\n                return true;\n            }\n            // node data is out of date\n            if (lazyNode.node.__needsRefreshWhenVisible) {\n                return true;\n            }\n            // node not yet loaded\n            if (lazyNode.node.stub) {\n                return true;\n            }\n            return false;\n        });\n        return firstOutOfPlaceNode == null;\n    }\n\n    public isLastRowIndexKnown() {\n        return this.isLastRowKnown;\n    }\n\n    public onLoadFailed(firstRowIndex: number, numberOfRowsExpected: number) {\n        if (!this.live) return;\n        const wasRefreshing = this.nodesToRefresh.size > 0;\n\n        for (let i = firstRowIndex; i < firstRowIndex + numberOfRowsExpected && i < this.getRowCount(); i++) {\n            let { node }: { node?: RowNode } = this.nodeMap.getBy('index', i) ?? {};\n            if (node) {\n                this.nodesToRefresh.delete(node);\n            }\n            if (!node || !node.stub) {\n                if (node && !node.stub) {\n                    // if node is not a stub, we destroy it and recreate as nodes can't go from data to stub\n                    this.destroyRowAtIndex(i);\n                }\n                node = this.createRowAtIndex(i);\n            }\n            // this node has been refreshed, even if it wasn't successful\n            node.__needsRefreshWhenVisible = false;\n            node.failedLoad = true;\n        }\n\n        const finishedRefreshing = this.nodesToRefresh.size === 0;\n        if (wasRefreshing && finishedRefreshing) {\n            this.fireRefreshFinishedEvent();\n        }\n\n        this.fireStoreUpdatedEvent();\n    }\n\n    public markNodesForRefresh() {\n        this.nodeMap.forEach(lazyNode => {\n            if (lazyNode.node.stub && !lazyNode.node.failedLoad) {\n                return;\n            }\n            this.nodesToRefresh.add(lazyNode.node);\n        });\n        this.lazyBlockLoadingService.queueLoadCheck();\n\n        if (this.isLastRowKnown && this.numberOfRows === 0) {\n            this.numberOfRows = 1;\n            this.isLastRowKnown = false;\n            this.fireStoreUpdatedEvent();\n        }\n    }\n\n    public isNodeInCache(id: string): boolean {\n        return !!this.nodeMap.getBy('id', id);\n    }\n\n    // gets called 1) row count changed 2) cache purged 3) items inserted\n    private fireStoreUpdatedEvent(): void {\n        if (!this.live) { return; }\n\n        this.store.fireStoreUpdatedEvent();\n    }\n\n    private getRowId(data: any) {\n        if (this.getRowIdFunc == null) {\n            return null;\n        }\n\n        // find rowNode using id\n        const { level } = this.store.getRowDetails();\n        const parentKeys = this.store.getParentNode().getGroupKeys();\n        const id: string = this.getRowIdFunc({\n            data,\n            parentKeys: parentKeys.length > 0 ? parentKeys : undefined,\n            level,\n        });\n        return String(id);\n    }\n\n    public getOrderedNodeMap() {\n        const obj: { [key: number]: LazyStoreNode } = {};\n        this.nodeMap.forEach(node => obj[node.index] = node);\n        return obj;\n    }\n\n    public clearDisplayIndexes() {\n        this.nodeDisplayIndexMap.clear();\n    }\n\n    /**\n     * Client side sorting\n     */\n    public clientSideSortRows() {\n        const sortOptions = this.sortController.getSortOptions();\n        const isAnySort = sortOptions.some(opt => opt.sort != null);\n        if (!isAnySort) {\n            return;\n        }\n        \n        // the node map does not need entirely recreated, only the indexes need updated.\n        const allNodes = new Array(this.nodeMap.getSize());\n        this.nodeMap.forEach(lazyNode => allNodes[lazyNode.index] = lazyNode.node);\n        this.nodeMap.clear();\n\n        const sortedNodes = this.rowNodeSorter.doFullSort(allNodes, sortOptions);\n        sortedNodes.forEach((node, index) => {\n            this.nodeMap.set({\n                id: node.id!,\n                node,\n                index,\n            });\n        });\n    }\n\n    /**\n     * Transaction Support here\n     */\n    public updateRowNodes(updates: any[]): RowNode[] {\n        if (this.getRowIdFunc == null) {\n            // throw error, as this is type checked in the store. User likely abusing internal apis if here.\n            throw new Error('AG Grid: Transactions can only be applied when row ids are supplied.');\n        }\n        \n        const updatedNodes: RowNode[] = [];\n        updates.forEach(data => {\n            const id: string = this.getRowId(data)!;\n            const lazyNode = this.nodeMap.getBy('id', id);\n            if (lazyNode) {\n                this.blockUtils.updateDataIntoRowNode(lazyNode.node, data);\n                updatedNodes.push(lazyNode.node);\n            }\n        });\n        return updatedNodes;\n    }\n\n    public insertRowNodes(inserts: any[], indexToAdd?: number): RowNode[] {\n        // adjust row count to allow for footer row\n        const realRowCount = this.store.getRowCount() - (this.store.getParentNode().sibling ? 1 : 0);\n\n        // if missing and we know the last row, we're inserting at the end\n        const addIndex = indexToAdd == null && this.isLastRowKnown ? realRowCount : indexToAdd;\n\n        // can't insert nodes past the end of the store\n        if (addIndex == null || realRowCount < addIndex) {\n            return [];\n        }\n\n        if (this.getRowIdFunc == null) {\n            // throw error, as this is type checked in the store. User likely abusing internal apis if here.\n            throw new Error('AG Grid: Transactions can only be applied when row ids are supplied.');\n        }\n\n        const uniqueInsertsMap: { [id: string]: any } = {};\n        \n        inserts.forEach(data => {\n            const dataId = this.getRowId(data)!;\n            if (dataId && this.isNodeInCache(dataId)) {\n                return;\n            }\n            \n            uniqueInsertsMap[dataId] = data;\n        });\n\n        const uniqueInserts = Object.values(uniqueInsertsMap);\n\n        let numberOfInserts = uniqueInserts.length;\n        if (numberOfInserts === 0) {\n            return [];\n        }\n\n        const nodesToMove = this.nodeMap.filter(node => node.index >= addIndex);\n        // delete all nodes which need moved first, so they don't get overwritten\n        nodesToMove.forEach(lazyNode => this.nodeMap.delete(lazyNode));\n        // then move the nodes to their new locations\n        nodesToMove.forEach(lazyNode => {\n            this.nodeMap.set({\n                node: lazyNode.node,\n                index: lazyNode.index + numberOfInserts,\n                id: lazyNode.id,\n            });\n        });\n                    \n        // increase the store size to accommodate\n        this.numberOfRows += numberOfInserts;\n\n        // finally insert the new rows\n        return uniqueInserts.map((data, uniqueInsertOffset) => this.createRowAtIndex(addIndex + uniqueInsertOffset, data));\n    }\n\n    public removeRowNodes(idsToRemove: string[]): RowNode[] {\n        if (this.getRowIdFunc == null) {\n            // throw error, as this is type checked in the store. User likely abusing internal apis if here.\n            throw new Error('AG Grid: Transactions can only be applied when row ids are supplied.');\n        }\n\n        const removedNodes: RowNode[] = [];\n        const nodesToVerify: RowNode[] = [];\n\n        // track how many nodes have been deleted, as when we pass other nodes we need to shift them up\n        let deletedNodeCount = 0;\n\n        const remainingIdsToRemove = [...idsToRemove];\n\n        const allNodes = this.getOrderedNodeMap();\n        let contiguousIndex = -1;\n        for (let stringIndex in allNodes) {\n            contiguousIndex += 1;\n            const node = allNodes[stringIndex];\n\n            // finding the index allows the use of splice which should be slightly faster than both a check and filter\n            const matchIndex = remainingIdsToRemove.findIndex(idToRemove => idToRemove === node.id);\n            if (matchIndex !== -1) {\n                // found node, remove it from nodes to remove\n                remainingIdsToRemove.splice(matchIndex, 1);\n\n                this.destroyRowAtIndex(Number(stringIndex));\n                removedNodes.push(node.node);\n                deletedNodeCount += 1;\n                continue;\n            }\n\n            // no nodes removed and this node doesn't match, so no need to shift\n            if (deletedNodeCount === 0) {\n                continue;\n            }\n\n            const numericStoreIndex = Number(stringIndex);\n            if (contiguousIndex !== numericStoreIndex) {\n                nodesToVerify.push(node.node);\n            }\n\n            // shift normal node up by number of deleted prior to this point\n            this.nodeMap.delete(allNodes[stringIndex]);\n            this.nodeMap.set({\n                id: node.id!,\n                node: node.node,\n                index: numericStoreIndex - deletedNodeCount,\n            });\n        }\n\n        this.numberOfRows -= this.isLastRowIndexKnown() ? idsToRemove.length : deletedNodeCount;\n\n        if (remainingIdsToRemove.length > 0 && nodesToVerify.length > 0) {\n            nodesToVerify.forEach(node => node.__needsRefreshWhenVisible = true);\n            this.lazyBlockLoadingService.queueLoadCheck();\n        }\n\n        return removedNodes;\n    }\n\n    /**\n     * Return the block size configured for this cache\n     */\n    public getBlockSize() {\n        return this.storeParams.cacheBlockSize || LazyBlockLoadingService.DEFAULT_BLOCK_SIZE;\n    }\n\n    /**\n     * Get the start index of the loading block for a given index\n     */\n    public getBlockStartIndex(storeIndex: number): number {\n        const blockSize = this.getBlockSize();\n        return storeIndex - (storeIndex % blockSize);\n    }\n\n    /**\n     * Get the start and end index of a block, given a row store index\n     */\n    public getBlockBounds(storeIndex: number): [number, number] {\n        const startOfBlock = this.getBlockStartIndex(storeIndex);\n        const blockSize = this.getBlockSize();\n        return [startOfBlock, startOfBlock + blockSize];\n    }\n}\n", "export class MultiIndexMap<K> {\n    private indexes: (keyof K)[];\n    private maps: Map<keyof K, Map<any, K>>;\n\n    constructor(...indexes: (keyof K)[]) {\n        if (indexes.length < 1) {\n            throw new Error('AG Grid: At least one index must be provided.');\n        }\n        this.indexes = indexes;\n        this.maps = new Map(\n            this.indexes.map(index => [index, new Map()])\n        );\n    }\n\n    public getSize(): number {\n        return this.maps.get(this.indexes[0])!.size;\n    }\n\n    public getBy(index: keyof K, key: any): K | undefined {\n        const map = this.maps.get(index);\n        if (!map) {\n            throw new Error(`AG Grid: ${String(index)} not found`);\n        }\n        return map.get(key);\n    }\n\n    public set(item: K) {\n        this.indexes.forEach(index => {\n            const map = this.maps.get(index);\n            if (!map) {\n                throw new Error(`AG Grid: ${String(index)} not found`);\n            }\n            map.set(item[index], item);\n        });\n    }\n\n    public delete(item: K) {\n        this.indexes.forEach(index => {\n            const map = this.maps.get(index);\n            if (!map) {\n                throw new Error(`AG Grid: ${String(index)} not found`);\n            }\n            map.delete(item[index]);\n        });\n    }\n\n    public clear() {\n        this.maps.forEach(map => map.clear());\n    }\n\n    private getIterator(index: keyof K) {\n        const map = this.maps.get(index);\n        if (!map) {\n            throw new Error(`AG Grid: ${String(index)} not found`);\n        }\n        return map.values();\n    }\n    \n    public forEach(callback: (item: K) => void) {\n        const iterator = this.getIterator(this.indexes[0]);\n        let pointer: IteratorResult<K, any>;\n        while (pointer = iterator.next()) {\n            if (pointer.done) break;\n            callback(pointer.value);\n        }\n    }\n    \n    public find(callback: (item: K) => boolean) {\n        const iterator = this.getIterator(this.indexes[0]);\n        let pointer: IteratorResult<K, any>;\n        while (pointer = iterator.next()) {\n            if (pointer.done) break;\n            if (callback(pointer.value)) {\n                return pointer.value;\n            }\n        }\n    }\n\n    public filter(predicate: (item: K) => boolean) {\n        const iterator = this.getIterator(this.indexes[0]);\n        let pointer: IteratorResult<K, any>;\n        const result: K[] = [];\n        while (pointer = iterator.next()) {\n            if (pointer.done) break;\n            if (predicate(pointer.value)) {\n                result.push(pointer.value);\n            }\n        }\n        return result;\n    }\n}", "import { Autowired, Bean, BeanStub, PostConstruct, RowNodeBlockLoader, RowRenderer, RowNode, IServerSideGetRowsRequest, LoadSuccessParams, IServerSideGetRowsParams } from \"@ag-grid-community/core\";\nimport { LazyCache } from \"./lazyCache\";\nimport { ServerSideRowModel } from \"../../serverSideRowModel\";\nimport { LazyStore } from \"./lazyStore\";\n\n@Bean('lazyBlockLoadingService')\nexport class LazyBlockLoadingService extends BeanStub {\n    public static DEFAULT_BLOCK_SIZE = 100;\n\n    @Autowired('rowNodeBlockLoader') private rowNodeBlockLoader: RowNodeBlockLoader;\n    @Autowired('rowRenderer') private rowRenderer: RowRenderer;\n    @Autowired('rowModel') private rowModel: ServerSideRowModel;\n    \n    // a map of caches to loading nodes\n    private cacheLoadingNodesMap: Map<LazyCache, Set<number>> = new Map();\n\n    // if a check is queued to happen this cycle\n    private isCheckQueued = false;\n\n    // this is cached for blockLoadDebounce\n    private nextBlockToLoad?: { cache: LazyCache, index: number } = undefined;\n    private loaderTimeout?: number;\n\n    @PostConstruct\n    private init() {\n        // after a block is loaded, check if we have a block to load now that\n        // `maxConcurrentDatasourceRequests` has changed\n        this.addManagedListener(this.rowNodeBlockLoader, RowNodeBlockLoader.BLOCK_LOADED_EVENT, () => this.queueLoadAction());\n    }\n\n    public subscribe(cache: LazyCache) {\n        this.cacheLoadingNodesMap.set(cache, new Set());\n    }\n\n    public unsubscribe(cache: LazyCache) {\n        this.cacheLoadingNodesMap.delete(cache);\n    }\n\n    /**\n     * Queues a microtask to check if any blocks need to be loaded.\n     */\n    public queueLoadCheck() {\n        if (this.isCheckQueued) {\n            return;\n        }\n        this.isCheckQueued = true;\n        window.queueMicrotask(() => {\n            this.queueLoadAction();\n            this.isCheckQueued = false;\n        });\n    }\n\n    private queueLoadAction() {\n        const nextBlockToLoad = this.getBlockToLoad();\n        if (!nextBlockToLoad) {\n            return;\n        }\n    \n        // for blockLoadDebounceMillis, if the next block to load is the same as the last block to load, ignore\n        // otherwise cancel existing timeout and requeue\n        const isSameBlock = this.nextBlockToLoad && this.nextBlockToLoad.cache === nextBlockToLoad.cache && this.nextBlockToLoad.index === nextBlockToLoad.index;\n        if (isSameBlock) {\n            return;\n        }\n        \n        if (!this.nextBlockToLoad || !isSameBlock) {\n            this.nextBlockToLoad = nextBlockToLoad;\n            window.clearTimeout(this.loaderTimeout);\n\n            const startRow = Number(this.nextBlockToLoad.index);\n            const cache = this.nextBlockToLoad.cache;\n            const endRow = nextBlockToLoad.index + nextBlockToLoad.cache.getBlockSize();\n            this.loaderTimeout = window.setTimeout(() => {\n                if (!cache.isAlive()) {\n                    return;\n                }\n                this.loaderTimeout = undefined;\n                this.attemptLoad(cache, startRow, endRow);\n                this.nextBlockToLoad = undefined;\n            }, this.gridOptionsService.get('blockLoadDebounceMillis'));\n        }\n    }\n\n    private attemptLoad(cache: LazyCache, start: number, end: number) {\n        const availableLoadingCount = this.rowNodeBlockLoader.getAvailableLoadingCount();\n        // too many loads already, ignore the request as a successful request will requeue itself anyway\n        if (availableLoadingCount != null && availableLoadingCount === 0) {\n            return;\n        };\n\n        this.rowNodeBlockLoader.registerLoads(1);\n        this.executeLoad(cache, start, end);\n\n        // requeue a load action before waiting for a response, this is to enable\n        // more than one block to load simultaneously due to maxConcurrentDatasourceRequests\n        this.queueLoadAction();\n    }\n\n    private executeLoad(cache: LazyCache, startRow: number, endRow: number) {\n        const ssrmParams = cache.getSsrmParams();\n        const request: IServerSideGetRowsRequest = {\n            startRow,\n            endRow,\n            rowGroupCols: ssrmParams.rowGroupCols,\n            valueCols: ssrmParams.valueCols,\n            pivotCols: ssrmParams.pivotCols,\n            pivotMode: ssrmParams.pivotMode,\n            groupKeys: (cache as any).store.getParentNode().getGroupKeys(),\n            filterModel: ssrmParams.filterModel,\n            sortModel: ssrmParams.sortModel,\n        };\n\n        const loadingNodes = this.cacheLoadingNodesMap.get(cache)!;\n        const removeNodesFromLoadingMap = () => {\n            for (let i = 0; i < endRow - startRow; i++) {\n                loadingNodes.delete(startRow + i);\n            }\n        }\n        \n        const addNodesToLoadingMap = () => {\n            for (let i = 0; i < endRow - startRow; i++) {\n                loadingNodes.add(startRow + i);\n            }\n        }\n\n        const success = (params: LoadSuccessParams) => {\n            cache.onLoadSuccess(startRow, endRow - startRow, params);\n            removeNodesFromLoadingMap();\n            this.rowNodeBlockLoader.loadComplete();\n        };\n\n        const fail = () => {\n            cache.onLoadFailed(startRow, endRow - startRow);\n            removeNodesFromLoadingMap();\n            this.rowNodeBlockLoader.loadComplete();\n        }\n\n        const params: IServerSideGetRowsParams = this.gridOptionsService.addGridCommonParams({\n            request,\n            success,\n            fail,\n            parentNode: (cache as any).store.getParentNode()\n        });\n\n        addNodesToLoadingMap();\n        cache.getSsrmParams().datasource?.getRows(params);\n    }\n\n    private getBlockToLoad() {\n        const firstRowInViewport = this.rowRenderer.getFirstVirtualRenderedRow();\n        const lastRowInViewport = this.rowRenderer.getLastVirtualRenderedRow();\n\n        // quick look-up for priority rows needing loading in viewport.\n        for (let i = firstRowInViewport; i <= lastRowInViewport; i++) {\n            const row = this.rowModel.getRow(i);\n            if (!row) {\n                continue;\n            }\n\n            const store = row.parent && row.parent.childStore;\n            if (!store || !(store instanceof LazyStore)) {\n                continue;\n            }\n\n            const cache: LazyCache = store.getCache();\n            const lazyNode = cache.getNodes().getBy('node', row);\n            if (!lazyNode) {\n                continue;\n            }\n\n            const loadingNodes = this.cacheLoadingNodesMap.get(cache);\n            if (loadingNodes?.has(lazyNode.index)) {\n                continue;\n            }\n\n            if (row.__needsRefreshWhenVisible || (row.stub && !row.failedLoad)) {\n                return {\n                    cache: cache,\n                    index: cache.getBlockStartIndex(lazyNode.index),\n                };\n            }\n        }\n\n        let cacheToRefresh: LazyCache | null = null;\n        let nodeToRefresh: RowNode | null = null;\n        let nodeToRefreshDist: number = Number.MAX_SAFE_INTEGER;\n\n        for (const cache of this.cacheLoadingNodesMap.keys()) {\n            const nodesToRefresh = cache.getNodesToRefresh();\n            nodesToRefresh.forEach(node => {\n                if (node.rowIndex == null) {\n                    nodeToRefresh = node;\n                    cacheToRefresh = cache;\n                    return;\n                }\n\n                const lazyNode = cache.getNodes().getBy('node', node);\n                if (!lazyNode) {\n                    return;\n                }\n\n                const loadingNodes = this.cacheLoadingNodesMap.get(cache);\n                if (loadingNodes?.has(lazyNode.index)) {\n                    return;\n                }\n            \n                const distToViewportTop = Math.abs(firstRowInViewport - node.rowIndex);\n                const distToViewportBottom = Math.abs(node.rowIndex - lastRowInViewport);\n                if (distToViewportTop < nodeToRefreshDist) {\n                    nodeToRefresh = node;\n                    nodeToRefreshDist = distToViewportTop;\n                    cacheToRefresh = cache;\n                }\n\n                if (distToViewportBottom < nodeToRefreshDist) {\n                    nodeToRefresh = node;\n                    nodeToRefreshDist = distToViewportBottom;\n                    cacheToRefresh = cache;\n                }\n            });\n        }\n\n        if (!cacheToRefresh) {\n            return undefined;\n        }\n\n        const lazyCache = cacheToRefresh as LazyCache;\n\n        const lazyIndex = lazyCache.getNodes().getBy('node', nodeToRefresh)?.index;\n        return lazyIndex == null ? undefined : {\n            cache: lazyCache,\n            index: lazyCache.getBlockStartIndex(lazyIndex),\n        };\n    }\n\n    public isRowLoading(cache: LazyCache, index: number) {\n        return this.cacheLoadingNodesMap.get(cache)?.has(index) ?? false;\n    }\n}", "import {\n    _,\n    IServerSideStore,\n    Autowired,\n    Bean,\n    BeanStub,\n    IServerSideGetRowsParams,\n    IServerSideGetRowsRequest,\n    StoreRefreshAfterParams,\n    RowNode,\n    ColumnVO,\n    RowNodeBlock,\n    ColumnModel,\n    GridOptions\n} from \"@ag-grid-community/core\";\nimport { SSRMParams, ServerSideRowModel } from \"../serverSideRowModel\";\nimport { StoreFactory } from \"./storeFactory\";\n\n@Bean('ssrmStoreUtils')\nexport class StoreUtils extends BeanStub {\n\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('rowModel') private serverSideRowModel: ServerSideRowModel;\n    @Autowired('ssrmStoreFactory') private storeFactory: StoreFactory;\n\n    public loadFromDatasource(p: {\n        storeParams: SSRMParams,\n        parentNode: RowNode,\n        parentBlock: RowNodeBlock,\n        success: () => void,\n        fail: () => void,\n        startRow?: number,\n        endRow?: number}\n    ): void {\n        const { storeParams, parentBlock, parentNode } = p;\n        const groupKeys = parentNode.getGroupKeys();\n\n        if (!storeParams.datasource) { return; }\n\n        const request: IServerSideGetRowsRequest = {\n            startRow: p.startRow,\n            endRow: p.endRow,\n            rowGroupCols: storeParams.rowGroupCols,\n            valueCols: storeParams.valueCols,\n            pivotCols: storeParams.pivotCols,\n            pivotMode: storeParams.pivotMode,\n            groupKeys: groupKeys,\n            filterModel: storeParams.filterModel,\n            sortModel: storeParams.sortModel\n        };\n\n        const getRowsParams: IServerSideGetRowsParams = this.gridOptionsService.addGridCommonParams({\n            success: p.success,\n            fail: p.fail,\n            request: request,\n            parentNode: p.parentNode\n        });\n\n        window.setTimeout(() => {\n            if (!storeParams.datasource || !parentBlock.isAlive()) {\n                // failCallback() is important, to reduce the 'RowNodeBlockLoader.activeBlockLoadsCount' count\n                p.fail();\n                return;\n            }\n            storeParams.datasource.getRows(getRowsParams);\n        }, 0);\n    }\n\n    public getChildStore(keys: string[], currentCache: IServerSideStore, findNodeFunc: (key: string) => RowNode | null): IServerSideStore | null {\n        if (_.missingOrEmpty(keys)) { return currentCache; }\n\n        const nextKey = keys[0];\n        const nextNode = findNodeFunc(nextKey);\n\n        if (nextNode) {\n            // if we have the final node, but not the final store, we create it to allow\n            // early population of data\n            if (keys.length === 1 && !nextNode.childStore) {\n                const storeParams = this.serverSideRowModel.getParams();\n                nextNode.childStore = this.createBean(this.storeFactory.createStore(storeParams, nextNode));\n            }\n\n            const keyListForNextLevel = keys.slice(1, keys.length);\n            const nextStore = nextNode.childStore;\n            return nextStore ? nextStore.getChildStore(keyListForNextLevel) : null;\n        }\n\n        return null;\n    }\n\n    public isServerRefreshNeeded(parentRowNode: RowNode, rowGroupCols: ColumnVO[], params: StoreRefreshAfterParams): boolean {\n        if (params.valueColChanged || params.secondaryColChanged) {\n            return true;\n        }\n\n        const level = parentRowNode.level + 1;\n        const grouping = level < rowGroupCols.length;\n        const leafNodes = !grouping;\n\n        if (leafNodes) { return true; }\n\n        const colIdThisGroup = rowGroupCols[level].id;\n        const actionOnThisGroup = params.changedColumns.indexOf(colIdThisGroup) > -1;\n\n        if (actionOnThisGroup) { return true; }\n\n        const allCols = this.columnModel.getAllGridColumns();\n        const affectedGroupCols = allCols\n            // find all impacted cols which also a group display column\n            .filter(col => col.getColDef().showRowGroup && params.changedColumns.includes(col.getId()))\n            .map(col => col.getColDef().showRowGroup)\n            // if displaying all groups, or displaying the effected col for this group, refresh\n            .some(group => group === true || group === colIdThisGroup);\n\n        return affectedGroupCols;\n    }\n\n    public getServerSideInitialRowCount(): number | null {\n        return this.gridOptionsService.get('serverSideInitialRowCount');\n    }\n\n    private assertRowModelIsServerSide(key: keyof GridOptions) {\n        if (!this.gridOptionsService.isRowModelType('serverSide')) {\n            _.warnOnce(`The '${key}' property can only be used with the Server Side Row Model.`);\n            return false;\n        }\n        return true;\n    }\n    private assertNotTreeData(key: keyof GridOptions) {\n        if (this.gridOptionsService.get('treeData')) {\n            _.warnOnce(`The '${key}' property cannot be used while using tree data.`);\n            return false;\n        }\n        return true;\n    }\n\n    public isServerSideSortAllLevels() {\n        return this.gridOptionsService.get('serverSideSortAllLevels') && this.assertRowModelIsServerSide('serverSideSortAllLevels');\n    }\n    public isServerSideOnlyRefreshFilteredGroups() {\n        return this.gridOptionsService.get('serverSideOnlyRefreshFilteredGroups') && this.assertRowModelIsServerSide('serverSideOnlyRefreshFilteredGroups');\n    }\n    public isServerSideSortOnServer() {\n        return this.gridOptionsService.get('serverSideSortOnServer') && this.assertRowModelIsServerSide('serverSideSortOnServer') && this.assertNotTreeData('serverSideSortOnServer');\n    }\n    public isServerSideFilterOnServer() {\n        return this.gridOptionsService.get('serverSideFilterOnServer') && this.assertRowModelIsServerSide('serverSideFilterOnServer') && this.assertNotTreeData('serverSideFilterOnServer');\n    }\n\n}", "import {\n    _,\n    RowBounds,\n    Autowired,\n    Bean,\n    BeanStub,\n    Column,\n    ColumnModel,\n    PostConstruct,\n    RowNode,\n    ValueService,\n    NumberSequence,\n    Beans,\n    IRowNode\n} from \"@ag-grid-community/core\";\nimport { NodeManager } from \"../nodeManager\";\nimport { ServerSideExpansionService } from \"../services/serverSideExpansionService\";\n\nexport const GROUP_MISSING_KEY_ID: 'ag-Grid-MissingKey' = 'ag-Grid-MissingKey';\n\n@Bean('ssrmBlockUtils')\nexport class BlockUtils extends BeanStub {\n\n    @Autowired('valueService') private valueService: ValueService;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('ssrmNodeManager') private nodeManager: NodeManager;\n    @Autowired('beans') private beans: Beans;\n    @Autowired('expansionService') private readonly expansionService: ServerSideExpansionService;\n\n    public createRowNode(params: {\n        group: boolean, leafGroup: boolean, level: number,\n        parent: RowNode, field: string, rowGroupColumn: Column, rowHeight?: number\n    }): RowNode {\n\n        const rowNode = new RowNode(this.beans);\n\n        const rowHeight = params.rowHeight != null ? params.rowHeight : this.gridOptionsService.getRowHeightAsNumber();\n        rowNode.setRowHeight(rowHeight);\n\n        rowNode.group = params.group;\n        rowNode.leafGroup = params.leafGroup;\n        rowNode.level = params.level;\n        rowNode.uiLevel = params.level;\n        rowNode.parent = params.parent;\n\n        // stub gets set to true here, and then false when this rowNode gets it's data\n        rowNode.stub = true;\n        rowNode.__needsRefreshWhenVisible = false;\n\n        if (rowNode.group) {\n            rowNode.expanded = false;\n            rowNode.field = params.field;\n            rowNode.rowGroupColumn = params.rowGroupColumn;\n        }\n\n        return rowNode;\n    }\n\n    public destroyRowNodes(rowNodes: RowNode[]): void {\n        if (rowNodes) {\n            rowNodes.forEach((row) => this.destroyRowNode(row));\n        }\n    }\n\n    public destroyRowNode(rowNode: RowNode, preserveStore: boolean = false): void {\n        if (rowNode.childStore && !preserveStore) {\n            this.destroyBean(rowNode.childStore);\n            rowNode.childStore = null;\n        }\n\n        // if this has a footer, destroy that too\n        if (rowNode.sibling && !rowNode.footer) {\n            this.destroyRowNode(rowNode.sibling, false);\n        }\n    \n        // this is needed, so row render knows to fade out the row, otherwise it\n        // sees row top is present, and thinks the row should be shown. maybe\n        // rowNode should have a flag on whether it is visible???\n        rowNode.clearRowTopAndRowIndex();\n        if (rowNode.id != null) {\n            this.nodeManager.removeNode(rowNode);\n        }\n    }\n\n    private setTreeGroupInfo(rowNode: RowNode): void {\n        rowNode.updateHasChildren();\n\n        const getKeyFunc = this.gridOptionsService.get('getServerSideGroupKey');\n        if (rowNode.hasChildren() && getKeyFunc != null) {\n            rowNode.key = getKeyFunc(rowNode.data);\n        }\n\n        if (!rowNode.hasChildren() && rowNode.childStore != null) {\n            this.destroyBean(rowNode.childStore);\n            rowNode.childStore = null;\n            rowNode.expanded = false;\n        }\n    }\n\n    private setRowGroupInfo(rowNode: RowNode): void {\n        rowNode.key = this.valueService.getValue(rowNode.rowGroupColumn!, rowNode);\n        if (rowNode.key === null || rowNode.key === undefined) {\n            _.doOnce(() => {\n                console.warn(`AG Grid: null and undefined values are not allowed for server side row model keys`);\n                if (rowNode.rowGroupColumn) {\n                    console.warn(`column = ${rowNode.rowGroupColumn.getId()}`);\n                }\n                console.warn(`data is `, rowNode.data);\n            }, 'ServerSideBlock-CannotHaveNullOrUndefinedForKey');\n        }\n\n        const getGroupIncludeFooter = this.beans.gridOptionsService.getGroupIncludeFooter();\n        const doesRowShowFooter = getGroupIncludeFooter({ node: rowNode });\n        if (doesRowShowFooter) {\n            rowNode.createFooter();\n            if (rowNode.sibling) {\n                rowNode.sibling.uiLevel = rowNode.uiLevel + 1;\n            }\n        }\n    }\n\n    private setMasterDetailInfo(rowNode: RowNode): void {\n        const isMasterFunc = this.gridOptionsService.get('isRowMaster');\n        if (isMasterFunc != null) {\n            rowNode.master = isMasterFunc(rowNode.data);\n        } else {\n            rowNode.master = true;\n        }\n    }\n\n    public updateDataIntoRowNode(rowNode: RowNode, data: any): void {\n        rowNode.updateData(data);\n\n        if (this.gridOptionsService.get('treeData')) {\n            this.setTreeGroupInfo(rowNode);\n            this.setChildCountIntoRowNode(rowNode);\n        } else if (rowNode.group) {\n            this.setChildCountIntoRowNode(rowNode);\n\n            if (!rowNode.footer) {\n                const getGroupIncludeFooter = this.beans.gridOptionsService.getGroupIncludeFooter();\n                const doesRowShowFooter = getGroupIncludeFooter({ node: rowNode });\n                if (doesRowShowFooter) {\n                    if (rowNode.sibling) {\n                        rowNode.sibling.updateData(data);\n                    } else {\n                        rowNode.createFooter();\n                    }\n                } else if (rowNode.sibling) {\n                    rowNode.destroyFooter();\n                }\n            }\n\n            // it's not possible for a node to change whether it's a group or not\n            // when doing row grouping (as only rows at certain levels are groups),\n            // so nothing to do here\n        } else if (this.gridOptionsService.get('masterDetail')) {\n            // this should be implemented, however it's not the use case i'm currently\n            // programming, so leaving for another day. to test this, create an example\n            // where whether a master row is expandable or not is dynamic\n        }\n    }\n\n    public setDataIntoRowNode(rowNode: RowNode, data: any, defaultId: string, cachedRowHeight: number | undefined): void {\n        rowNode.stub = false;\n        const treeData = this.gridOptionsService.get('treeData');\n\n        if (_.exists(data)) {\n            rowNode.setDataAndId(data, defaultId);\n\n            if (treeData) {\n                this.setTreeGroupInfo(rowNode);\n            } else if (rowNode.group) {\n                this.setRowGroupInfo(rowNode);\n            } else if (this.gridOptionsService.get('masterDetail')) {\n                this.setMasterDetailInfo(rowNode);\n            }\n\n        } else {\n            rowNode.setDataAndId(undefined, undefined);\n            rowNode.key = null;\n        }\n\n        if (treeData || rowNode.group) {\n            this.setGroupDataIntoRowNode(rowNode);\n            this.setChildCountIntoRowNode(rowNode);\n        }\n\n        // this needs to be done AFTER setGroupDataIntoRowNode(), as the height can depend on the group data\n        // getting set, if it's a group node and colDef.autoHeight=true\n        if (_.exists(data)) {\n            rowNode.setRowHeight(this.gridOptionsService.getRowHeightForNode(rowNode, false, cachedRowHeight).height);\n            rowNode.sibling?.setRowHeight(this.gridOptionsService.getRowHeightForNode(rowNode.sibling, false, cachedRowHeight).height);\n        }\n    }\n\n    private setChildCountIntoRowNode(rowNode: RowNode): void {\n        const getChildCount = this.gridOptionsService.get('getChildCount');\n        if (getChildCount) {\n            rowNode.setAllChildrenCount(getChildCount(rowNode.data));\n        }\n    }\n\n    private setGroupDataIntoRowNode(rowNode: RowNode): void {\n        const groupDisplayCols: Column[] = this.columnModel.getGroupDisplayColumns();\n\n        const usingTreeData = this.gridOptionsService.get('treeData');\n\n        groupDisplayCols.forEach(col => {\n            if (rowNode.groupData == null) {\n                rowNode.groupData = {};\n            }\n            if (usingTreeData) {\n                rowNode.groupData[col.getColId()] = rowNode.key;\n            } else if (col.isRowGroupDisplayed(rowNode.rowGroupColumn!.getId())) {\n                const groupValue = this.valueService.getValue(rowNode.rowGroupColumn!, rowNode);\n                rowNode.groupData[col.getColId()] = groupValue;\n            }\n        });\n    }\n\n    public clearDisplayIndex(rowNode: RowNode): void {\n        rowNode.clearRowTopAndRowIndex();\n\n        const hasChildStore = rowNode.hasChildren() && _.exists(rowNode.childStore);\n        if (hasChildStore) {\n            const childStore = rowNode.childStore;\n            childStore!.clearDisplayIndexes();\n        }\n\n        const hasDetailNode = rowNode.master && rowNode.detailNode;\n        if (hasDetailNode) {\n            rowNode.detailNode.clearRowTopAndRowIndex();\n        }\n    }\n\n    public setDisplayIndex(rowNode: RowNode, displayIndexSeq: NumberSequence, nextRowTop: { value: number }): void {\n        // set this row\n        rowNode.setRowIndex(displayIndexSeq.next());\n        rowNode.setRowTop(nextRowTop.value);\n        nextRowTop.value += rowNode.rowHeight!;\n\n        if (rowNode.footer) {\n            return;\n        }\n\n        // set child for master / detail\n        const hasDetailRow = rowNode.master;\n        if (hasDetailRow) {\n            if (rowNode.expanded && rowNode.detailNode) {\n                rowNode.detailNode.setRowIndex(displayIndexSeq.next());\n                rowNode.detailNode.setRowTop(nextRowTop.value);\n                nextRowTop.value += rowNode.detailNode.rowHeight!;\n            } else if (rowNode.detailNode) {\n                rowNode.detailNode.clearRowTopAndRowIndex();\n            }\n        }\n\n        // set children for SSRM child rows\n        const hasChildStore = rowNode.hasChildren() && _.exists(rowNode.childStore);\n        if (hasChildStore) {\n            const childStore = rowNode.childStore;\n            if (rowNode.expanded) {\n                childStore!.setDisplayIndexes(displayIndexSeq, nextRowTop);\n            } else {\n                // we need to clear the row tops, as the row renderer depends on\n                // this to know if the row should be faded out\n                childStore!.clearDisplayIndexes();\n            }\n        }\n    }\n\n    public binarySearchForDisplayIndex(displayRowIndex: number, rowNodes: RowNode[]): IRowNode | undefined {\n\n        let bottomPointer = 0;\n        let topPointer = rowNodes.length - 1;\n\n        if (_.missing(topPointer) || _.missing(bottomPointer)) {\n            console.warn(`AG Grid: error: topPointer = ${topPointer}, bottomPointer = ${bottomPointer}`);\n            return undefined;\n        }\n\n        while (true) {\n            const midPointer = Math.floor((bottomPointer + topPointer) / 2);\n            const currentRowNode = rowNodes[midPointer];\n\n            // first check current row for index\n            if (currentRowNode.rowIndex === displayRowIndex) {\n                return currentRowNode;\n            }\n\n            // then check if current row contains a detail row with the index\n            const expandedMasterRow = currentRowNode.master && currentRowNode.expanded;\n            const detailNode = currentRowNode.detailNode;\n\n            if (expandedMasterRow && detailNode && detailNode.rowIndex === displayRowIndex) {\n                return currentRowNode.detailNode;\n            }\n\n            // then check if child cache contains index\n            const childStore = currentRowNode.childStore;\n            if (currentRowNode.expanded && childStore && childStore.isDisplayIndexInStore(displayRowIndex)) {\n                return childStore.getRowUsingDisplayIndex(displayRowIndex);\n            }\n\n            // otherwise adjust pointers to continue searching for index\n            if (currentRowNode.rowIndex! < displayRowIndex) {\n                bottomPointer = midPointer + 1;\n            } else if (currentRowNode.rowIndex! > displayRowIndex) {\n                topPointer = midPointer - 1;\n            } else {\n                console.warn(`AG Grid: error: unable to locate rowIndex = ${displayRowIndex} in cache`);\n                return undefined;\n            }\n        }\n    }\n\n    public extractRowBounds(rowNode: RowNode, index: number): RowBounds | undefined {\n        const extractRowBounds = (currentRowNode: RowNode): RowBounds => ({\n            rowHeight: currentRowNode.rowHeight!,\n            rowTop: currentRowNode.rowTop!\n        });\n\n        if (rowNode.rowIndex === index) {\n            return extractRowBounds(rowNode);\n        }\n\n        if (rowNode.hasChildren() && rowNode.expanded && _.exists(rowNode.childStore)) {\n            const childStore = rowNode.childStore;\n            if (childStore.isDisplayIndexInStore(index)) {\n                return childStore.getRowBounds(index)!;\n            }\n        } else if (rowNode.master && rowNode.expanded && _.exists(rowNode.detailNode)) {\n            if (rowNode.detailNode.rowIndex === index) {\n                return extractRowBounds(rowNode.detailNode);\n            }\n        }\n    }\n\n    public getIndexAtPixel(rowNode: RowNode, pixel: number): number | null {\n        // first check if pixel is in range of current row\n        if (rowNode.isPixelInRange(pixel)) {\n            return rowNode.rowIndex;\n        }\n\n        // then check if current row contains a detail row with pixel in range\n        const expandedMasterRow = rowNode.master && rowNode.expanded;\n        const detailNode = rowNode.detailNode;\n\n        if (expandedMasterRow && detailNode && detailNode.isPixelInRange(pixel)) {\n            return rowNode.detailNode.rowIndex;\n        }\n\n        // then check if it's a group row with a child cache with pixel in range\n        if (rowNode.hasChildren() && rowNode.expanded && _.exists(rowNode.childStore)) {\n            const childStore = rowNode.childStore;\n            if (childStore.isPixelInRange(pixel)) {\n                return childStore.getRowIndexAtPixel(pixel);\n            }\n        }\n\n        return null;\n        // pixel is not within this row node or it's children / detail, so return undefined\n    }\n\n    public createNodeIdPrefix(parentRowNode: RowNode): string | undefined {\n        const parts: string[] = [];\n        let rowNode: RowNode | null = parentRowNode;\n        // pull keys from all parent nodes, but do not include the root node\n        while (rowNode && rowNode.level >= 0) {\n            if (rowNode.key === '') {\n                parts.push(GROUP_MISSING_KEY_ID);\n            } else {\n                parts.push(rowNode.key!);\n            }\n            rowNode = rowNode.parent;\n        }\n\n        if (parts.length > 0) {\n            return parts.reverse().join('-');\n        }\n        // no prefix, so node id's are left as they are\n        return undefined;\n    }\n\n    public checkOpenByDefault(rowNode: RowNode): void {\n        return this.expansionService.checkOpenByDefault(rowNode);\n    }\n}", "import { Bean, RowNode, PreDestroy } from \"@ag-grid-community/core\";\n\n@Bean('ssrmNodeManager')\nexport class NodeManager {\n\n    private rowNodes: {[id: string]: RowNode | undefined } = {};\n\n    public addRowNode(rowNode: RowNode): void {\n        const id = rowNode.id!;\n        if (this.rowNodes[id]) {\n            console.warn(`AG Grid: Duplicate node id ${rowNode.id}. Row ID's are provided via the getRowId() callback. Please modify the getRowId() callback code to provide unique row id values.`);\n            console.warn('first instance', this.rowNodes[id]!.data);\n            console.warn('second instance', rowNode.data);\n        }\n\n        this.rowNodes[id] = rowNode;\n    }\n\n    public removeNode(rowNode: RowNode): void {\n        const id = rowNode.id!;\n        if (this.rowNodes[id]) {\n            this.rowNodes[id] = undefined;\n        }\n    }\n\n    @PreDestroy\n    public clear(): void {\n        this.rowNodes = {};\n    }\n\n}", "import {\n    Autowired,\n    Bean,\n    BeanStub,\n    Events,\n    IServerSideTransactionManager,\n    PostConstruct,\n    RowNodeBlockLoader,\n    ServerSideTransaction,\n    ServerSideTransactionResult,\n    ServerSideTransactionResultStatus,\n    ValueCache,\n    AsyncTransactionsFlushed,\n    RowRenderer,\n    WithoutGridCommon,\n    RowNode\n} from \"@ag-grid-community/core\";\nimport { ServerSideRowModel } from \"./serverSideRowModel\";\nimport { ServerSideSelectionService } from \"./services/serverSideSelectionService\";\n\ninterface AsyncTransactionWrapper {\n    transaction: ServerSideTransaction;\n    callback?: (result: ServerSideTransactionResult) => void;\n}\n\n@Bean('ssrmTransactionManager')\nexport class TransactionManager extends BeanStub implements IServerSideTransactionManager {\n\n    @Autowired('rowNodeBlockLoader') private rowNodeBlockLoader: RowNodeBlockLoader;\n    @Autowired('valueCache') private valueCache: ValueCache;\n    @Autowired('rowModel') private serverSideRowModel: ServerSideRowModel;\n    @Autowired('rowRenderer') private rowRenderer: RowRenderer;\n    @Autowired('selectionService') private selectionService: ServerSideSelectionService;\n\n    private asyncTransactionsTimeout: number | undefined;\n    private asyncTransactions: AsyncTransactionWrapper[] = [];\n\n    @PostConstruct\n    private postConstruct(): void {\n        // only want to be active if SSRM active, otherwise would be interfering with other row models\n        if (!this.gridOptionsService.isRowModelType('serverSide')) { return; }\n    }\n\n    public applyTransactionAsync(transaction: ServerSideTransaction, callback?: (res: ServerSideTransactionResult) => void): void {\n        if (this.asyncTransactionsTimeout == null) {\n            this.scheduleExecuteAsync();\n        }\n        this.asyncTransactions.push({ transaction: transaction, callback: callback });\n    }\n\n    private scheduleExecuteAsync(): void {\n        const waitMillis = this.gridOptionsService.getAsyncTransactionWaitMillis();\n        this.asyncTransactionsTimeout = window.setTimeout(() => {\n            this.executeAsyncTransactions();\n        }, waitMillis);\n    }\n\n    private executeAsyncTransactions(): void {\n        if (!this.asyncTransactions) { return; }\n\n        const resultFuncs: (() => void)[] = [];\n        const resultsForEvent: ServerSideTransactionResult[] = [];\n\n        const transactionsToRetry: AsyncTransactionWrapper[] = [];\n        let atLeastOneTransactionApplied = false;\n\n        this.asyncTransactions.forEach(txWrapper => {\n            let result: ServerSideTransactionResult | undefined;\n            const hasStarted = this.serverSideRowModel.executeOnStore(txWrapper.transaction.route!, cache => {\n                result = cache.applyTransaction(txWrapper.transaction);\n            });\n\n            if (!hasStarted) {\n                result = {status: ServerSideTransactionResultStatus.StoreNotStarted};\n            } else if (result == undefined) {\n                result = {status: ServerSideTransactionResultStatus.StoreNotFound};\n            }\n\n            resultsForEvent.push(result);\n\n            const retryTransaction = result.status == ServerSideTransactionResultStatus.StoreLoading;\n\n            if (retryTransaction) {\n                transactionsToRetry.push(txWrapper);\n                return;\n            }\n\n            if (txWrapper.callback) {\n                resultFuncs.push(() => txWrapper.callback!(result!));\n            }\n            if (result.status === ServerSideTransactionResultStatus.Applied) {\n                atLeastOneTransactionApplied = true;\n            }\n        });\n\n        // do callbacks in next VM turn so it's async\n        if (resultFuncs.length > 0) {\n            window.setTimeout(() => {\n                resultFuncs.forEach(func => func());\n            }, 0);\n        }\n\n        this.asyncTransactionsTimeout = undefined;\n\n        // this will be empty list if nothing to retry\n        this.asyncTransactions = transactionsToRetry;\n\n        if (atLeastOneTransactionApplied) {\n            this.valueCache.onDataChanged();\n            this.eventService.dispatchEvent({type: Events.EVENT_STORE_UPDATED});\n        }\n\n        if (resultsForEvent.length > 0) {\n            const event: WithoutGridCommon<AsyncTransactionsFlushed> = {                \n                type: Events.EVENT_ASYNC_TRANSACTIONS_FLUSHED,\n                results: resultsForEvent\n            };\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    public flushAsyncTransactions(): void {\n        // the timeout could be missing, if we are flushing due to row data loaded\n        if (this.asyncTransactionsTimeout != null) {\n            clearTimeout(this.asyncTransactionsTimeout);\n        }\n        this.executeAsyncTransactions();\n    }\n\n    public applyTransaction(transaction: ServerSideTransaction): ServerSideTransactionResult | undefined {\n        let res: ServerSideTransactionResult | undefined;\n\n        const hasStarted = this.serverSideRowModel.executeOnStore(transaction.route!, store => {\n            res = store.applyTransaction(transaction);\n        });\n\n        if (!hasStarted) {\n            return { status: ServerSideTransactionResultStatus.StoreNotStarted };\n        } else if (res) {\n            this.valueCache.onDataChanged();\n            if (res.remove) {\n                const removedRowIds = res.remove.map(row => row.id!);\n                this.selectionService.deleteSelectionStateFromParent(transaction.route || [], removedRowIds);\n            }\n\n            this.eventService.dispatchEvent({type: Events.EVENT_STORE_UPDATED});\n            return res;\n        } else {\n            return { status: ServerSideTransactionResultStatus.StoreNotFound };\n        }\n    }\n}", "import {\n    _,\n    Autowired,\n    BeanStub,\n    StoreUpdatedEvent,\n    Events,\n    PostConstruct,\n    RowGroupOpenedEvent,\n    RowNode,\n    Bean,\n    Beans,\n    WithoutGridCommon\n} from \"@ag-grid-community/core\";\nimport { ServerSideRowModel } from \"../serverSideRowModel\";\nimport { StoreFactory } from \"../stores/storeFactory\";\n\n@Bean('ssrmExpandListener')\nexport class ExpandListener extends BeanStub {\n\n    @Autowired('rowModel') private serverSideRowModel: ServerSideRowModel;\n    @Autowired('ssrmStoreFactory') private storeFactory: StoreFactory;\n    @Autowired('beans') private beans: Beans;\n\n    @PostConstruct\n    private postConstruct(): void {\n        // only want to be active if SSRM active, otherwise would be interfering with other row models\n        if (!this.gridOptionsService.isRowModelType('serverSide')) { return; }\n\n        this.addManagedListener(this.eventService, Events.EVENT_ROW_GROUP_OPENED, this.onRowGroupOpened.bind(this));\n    }\n\n    private onRowGroupOpened(event: RowGroupOpenedEvent): void {\n        const rowNode = event.node as RowNode;\n\n        if (rowNode.expanded) {\n            if (rowNode.master) {\n                this.createDetailNode(rowNode);\n            } else if (_.missing(rowNode.childStore)) {\n                const storeParams = this.serverSideRowModel.getParams();\n                rowNode.childStore = this.createBean(this.storeFactory.createStore(storeParams, rowNode));\n            }\n        } else if (this.gridOptionsService.get('purgeClosedRowNodes') && _.exists(rowNode.childStore)) {\n            rowNode.childStore = this.destroyBean(rowNode.childStore)!;\n        }\n\n        const storeUpdatedEvent: WithoutGridCommon<StoreUpdatedEvent> = { type: Events.EVENT_STORE_UPDATED };\n        this.eventService.dispatchEvent(storeUpdatedEvent);\n    }\n\n    private createDetailNode(masterNode: RowNode): RowNode {\n        if (_.exists(masterNode.detailNode)) { return masterNode.detailNode; }\n\n        const detailNode = new RowNode(this.beans);\n\n        detailNode.detail = true;\n        detailNode.selectable = false;\n        detailNode.parent = masterNode;\n\n        if (_.exists(masterNode.id)) {\n            detailNode.id = 'detail_' + masterNode.id;\n        }\n\n        detailNode.data = masterNode.data;\n        detailNode.level = masterNode.level + 1;\n\n        const defaultDetailRowHeight = 200;\n        const rowHeight = this.gridOptionsService.getRowHeightForNode(detailNode).height;\n\n        detailNode.rowHeight = rowHeight ? rowHeight : defaultDetailRowHeight;\n        masterNode.detailNode = detailNode;\n\n        return detailNode;\n    }\n\n}", "import {\n    _,\n    Autowired,\n    Bean,\n    BeanStub,\n    ColumnModel,\n    GROUP_AUTO_COLUMN_ID,\n    Events,\n    PostConstruct,\n    SortController,\n    Column,\n    SortModelItem,\n    StoreRefreshAfterParams\n} from \"@ag-grid-community/core\";\nimport { ServerSideRowModel } from \"../serverSideRowModel\";\nimport { ListenerUtils } from \"./listenerUtils\";\n\n@Bean('ssrmSortService')\nexport class SortListener extends BeanStub {\n\n    @Autowired('sortController') private sortController: SortController;\n    @Autowired('rowModel') private serverSideRowModel: ServerSideRowModel;\n    @Autowired('ssrmListenerUtils') private listenerUtils: ListenerUtils;\n\n    @PostConstruct\n    private postConstruct(): void {\n        // only want to be active if SSRM active, otherwise would be interfering with other row models\n        if (!this.gridOptionsService.isRowModelType('serverSide')) { return; }\n\n        this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n    }\n\n    private onSortChanged(): void {\n        const storeParams = this.serverSideRowModel.getParams();\n        if (!storeParams) { return; } // params is undefined if no datasource set\n\n        const newSortModel = this.sortController.getSortModel();\n        const oldSortModel = storeParams.sortModel;\n\n        const changedColumns = this.findChangedColumnsInSort(newSortModel, oldSortModel);\n        const valueColChanged = this.listenerUtils.isSortingWithValueColumn(changedColumns);\n        const secondaryColChanged = this.listenerUtils.isSortingWithSecondaryColumn(changedColumns);\n\n        const params: StoreRefreshAfterParams = {\n            valueColChanged,\n            secondaryColChanged,\n            changedColumns\n        };\n\n        this.serverSideRowModel.refreshAfterSort(newSortModel, params);\n    }\n\n    // returns back all the cols that were effected by the sorting. eg if we were sorting by col A,\n    // and now we are sorting by col B, the list of impacted cols should be A and B. so if a cache\n    // is impacted by sorting on A or B then it needs to be refreshed. this includes where the cache\n    // was previously sorted by A and then the A sort now needs to be cleared.\n    private findChangedColumnsInSort(\n        newSortModel: SortModelItem[],\n        oldSortModel: SortModelItem[]): string[] {\n\n        let allColsInBothSorts: string[] = [];\n\n        [newSortModel, oldSortModel].forEach(sortModel => {\n            if (sortModel) {\n                const ids = sortModel.map(sm => sm.colId);\n                allColsInBothSorts = allColsInBothSorts.concat(ids);\n            }\n        });\n\n        const differentSorts = (oldSortItem: SortModelItem | undefined, newSortItem: SortModelItem | undefined) => {\n            const oldSort = oldSortItem ? oldSortItem.sort : null;\n            const newSort = newSortItem ? newSortItem.sort : null;\n            return oldSort !== newSort;\n        };\n\n        const differentIndexes = (oldSortItem: SortModelItem | undefined, newSortItem: SortModelItem | undefined) => {\n            const oldIndex = oldSortItem ? oldSortModel.indexOf(oldSortItem) : -1;\n            const newIndex = newSortItem ? newSortModel.indexOf(newSortItem) : -1;\n            return oldIndex !== newIndex;\n        };\n\n        return allColsInBothSorts.filter(colId => {\n            const oldSortItem = oldSortModel.find(sm => sm.colId === colId);\n            const newSortItem = newSortModel.find(sm => sm.colId === colId);\n            return differentSorts(oldSortItem, newSortItem) || differentIndexes(oldSortItem, newSortItem);\n        });\n    }\n\n}", "import {\n    AdvancedFilterModel,\n    Autowired,\n    Bean,\n    BeanStub,\n    Events,\n    FilterManager,\n    FilterModel,\n    PostConstruct,\n    StoreRefreshAfterParams\n} from \"@ag-grid-community/core\";\nimport { ServerSideRowModel } from \"../serverSideRowModel\";\nimport { ListenerUtils } from \"./listenerUtils\";\n\n@Bean('ssrmFilterListener')\nexport class FilterListener extends BeanStub {\n\n    @Autowired('rowModel') private serverSideRowModel: ServerSideRowModel;\n    @Autowired('filterManager') private filterManager: FilterManager;\n    @Autowired('ssrmListenerUtils') private listenerUtils: ListenerUtils;\n\n    @PostConstruct\n    private postConstruct(): void {\n        // only want to be active if SSRM active, otherwise would be interfering with other row models\n        if (!this.gridOptionsService.isRowModelType('serverSide')) { return; }\n\n        this.addManagedListener(this.eventService, Events.EVENT_ADVANCED_FILTER_ENABLED_CHANGED, () => this.onFilterChanged(true));\n        this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, () => this.onFilterChanged());\n    }\n\n    private onFilterChanged(advancedFilterEnabledChanged?: boolean): void {\n        const storeParams = this.serverSideRowModel.getParams();\n        if (!storeParams) { return; } // params is undefined if no datasource set\n\n        const oldModel = storeParams.filterModel;\n        let newModel: FilterModel | AdvancedFilterModel | null;\n        let changedColumns: string[];\n\n        if (this.filterManager.isAdvancedFilterEnabled()) {\n            newModel = this.filterManager.getAdvancedFilterModel();\n            // if advancedFilterEnabledChanged, old model is of type `FilterModel`\n            const oldColumns = advancedFilterEnabledChanged ? Object.keys(oldModel ?? {}) : this.getAdvancedFilterColumns(oldModel as AdvancedFilterModel | null);\n            const newColumns = this.getAdvancedFilterColumns(newModel as AdvancedFilterModel | null);\n            oldColumns.forEach(column => newColumns.add(column));\n            changedColumns = Array.from(newColumns);\n        } else {\n            newModel = this.filterManager.getFilterModel();\n            if (advancedFilterEnabledChanged) {\n                // old model is of type `AdvancedFilterModel | null`\n                const oldColumns = this.getAdvancedFilterColumns(oldModel as AdvancedFilterModel | null);\n                Object.keys(newModel).forEach(column => oldColumns.add(column));\n                changedColumns = Array.from(oldColumns);\n            } else {\n                changedColumns = this.findChangedColumns(oldModel as FilterModel, newModel as FilterModel);\n            }\n        }\n\n        const valueColChanged = this.listenerUtils.isSortingWithValueColumn(changedColumns);\n        const secondaryColChanged = this.listenerUtils.isSortingWithSecondaryColumn(changedColumns);\n\n        const params: StoreRefreshAfterParams = {\n            valueColChanged,\n            secondaryColChanged,\n            changedColumns\n        };\n\n        this.serverSideRowModel.refreshAfterFilter(newModel, params);\n    }\n\n    private findChangedColumns(oldModel: FilterModel, newModel: FilterModel): string[] {\n\n        const allColKeysMap: {[key: string]: boolean} = {};\n\n        Object.keys(oldModel).forEach(key => allColKeysMap[key] = true);\n        Object.keys(newModel).forEach(key => allColKeysMap[key] = true);\n\n        const res: string[] = [];\n\n        Object.keys(allColKeysMap).forEach(key => {\n            const oldJson = JSON.stringify(oldModel[key]);\n            const newJson = JSON.stringify(newModel[key]);\n            const filterChanged = oldJson != newJson;\n            if (filterChanged) {\n                res.push(key);\n            }\n        });\n\n        return res;\n    }\n\n    private getAdvancedFilterColumns(model: AdvancedFilterModel | null): Set<string> {\n        const columns = new Set<string>();\n        if (!model) { return columns; }\n\n        const processAdvancedFilterModel = (filterModel: AdvancedFilterModel) => {\n            if (filterModel.filterType === 'join') {\n                filterModel.conditions.forEach(condition => processAdvancedFilterModel(condition));\n            } else {\n                columns.add(filterModel.colId);\n            }\n        };\n\n        processAdvancedFilterModel(model);\n\n        return columns;\n    }\n}", "import {\n    _,\n    Autowired,\n    Bean,\n    IServerSideStore,\n    RowNode,\n    ServerSideGroupLevelParams,\n    GetServerSideGroupLevelParamsParams,\n    ColumnModel,\n    WithoutGridCommon,\n    GridOptionsService\n} from \"@ag-grid-community/core\";\nimport { SSRMParams } from \"../serverSideRowModel\";\nimport { FullStore } from \"./fullStore\";\nimport { LazyStore } from \"./lazy/lazyStore\";\n\n@Bean('ssrmStoreFactory')\nexport class StoreFactory {\n\n    @Autowired('gridOptionsService') private gridOptionsService: GridOptionsService;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n\n    public createStore(ssrmParams: SSRMParams, parentNode: RowNode): IServerSideStore {\n        const storeParams = this.getStoreParams(ssrmParams, parentNode);\n\n        const CacheClass = storeParams.suppressInfiniteScroll ? FullStore : LazyStore;\n\n        return new CacheClass(ssrmParams, storeParams, parentNode);\n    }\n\n    private getStoreParams(ssrmParams: SSRMParams, parentNode: RowNode): ServerSideGroupLevelParams {\n\n        const userStoreParams = this.getLevelSpecificParams(parentNode);\n\n        // if user provided overrideParams, we take infiniteScroll from there if it exists\n        const infiniteScroll = this.isInfiniteScroll(userStoreParams);\n        const cacheBlockSize = this.getBlockSize(infiniteScroll, userStoreParams);\n        const maxBlocksInCache = this.getMaxBlocksInCache(infiniteScroll, ssrmParams, userStoreParams);\n\n        const storeParams: ServerSideGroupLevelParams = {\n            suppressInfiniteScroll: !infiniteScroll,\n            cacheBlockSize,\n            maxBlocksInCache\n        };\n\n        return storeParams;\n    }\n\n    private getMaxBlocksInCache(infiniteScroll: boolean, ssrmParams: SSRMParams, userStoreParams?: ServerSideGroupLevelParams)\n        : number | undefined {\n\n        if (!infiniteScroll) { return undefined; }\n\n        const maxBlocksInCache = (userStoreParams && userStoreParams.maxBlocksInCache != null)\n            ? userStoreParams.maxBlocksInCache\n            : this.gridOptionsService.get('maxBlocksInCache');\n\n        const maxBlocksActive = maxBlocksInCache != null && maxBlocksInCache >= 0;\n\n        if (!maxBlocksActive) {\n            return undefined;\n        }\n\n        if (ssrmParams.dynamicRowHeight) {\n            const message = 'Server Side Row Model does not support Dynamic Row Height and Cache Purging. ' +\n                'Either a) remove getRowHeight() callback or b) remove maxBlocksInCache property. Purging has been disabled.';\n            _.warnOnce(message);\n            return undefined;\n        }\n\n        if (this.columnModel.isAutoRowHeightActive()) {\n            const message = 'Server Side Row Model does not support Auto Row Height and Cache Purging. ' +\n                'Either a) remove colDef.autoHeight or b) remove maxBlocksInCache property. Purging has been disabled.';\n            _.warnOnce(message);\n            return undefined;\n        }\n\n        return maxBlocksInCache;\n    }\n\n    private getBlockSize(infiniteScroll: boolean, userStoreParams?: ServerSideGroupLevelParams): number | undefined {\n        if (!infiniteScroll) { return undefined; }\n\n        const blockSize = (userStoreParams && userStoreParams.cacheBlockSize != null)\n            ? userStoreParams.cacheBlockSize\n            : this.gridOptionsService.get('cacheBlockSize');\n\n        if (blockSize != null && blockSize > 0) {\n            return blockSize;\n        } else {\n            return 100;\n        }\n    }\n\n    private getLevelSpecificParams(parentNode: RowNode): ServerSideGroupLevelParams | undefined {\n\n        const callback = this.gridOptionsService.getCallback('getServerSideGroupLevelParams');\n        if (!callback) { return undefined; }\n\n        const params: WithoutGridCommon<GetServerSideGroupLevelParamsParams> = {\n            level: parentNode.level + 1,\n            parentRowNode: parentNode.level >= 0 ? parentNode : undefined,\n            rowGroupColumns: this.columnModel.getRowGroupColumns(),\n            pivotColumns: this.columnModel.getPivotColumns(),\n            pivotMode: this.columnModel.isPivotMode()\n        };\n\n        const res = callback(params);\n        \n        return res;\n    }\n\n    private isInfiniteScroll(storeParams?: ServerSideGroupLevelParams): boolean {\n        const res = (storeParams && storeParams.suppressInfiniteScroll != null)\n            ? storeParams.suppressInfiniteScroll\n            : this.isSuppressServerSideInfiniteScroll();\n        return !res;\n    }\n\n    private isSuppressServerSideInfiniteScroll(): boolean {\n        return this.gridOptionsService.get('suppressServerSideInfiniteScroll');\n    }\n}", "import { Autowired, Bean, ColumnModel } from \"@ag-grid-community/core\";\n\n@Bean('ssrmListenerUtils')\nexport class ListenerUtils {\n\n    @Autowired('columnModel') private columnModel: ColumnModel;\n\n    public isSortingWithValueColumn(changedColumnsInSort: string[]): boolean {\n        const valueColIds = this.columnModel.getValueColumns().map(col => col.getColId());\n\n        for (let i = 0; i < changedColumnsInSort.length; i++) {\n            if (valueColIds.indexOf(changedColumnsInSort[i]) > -1) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public isSortingWithSecondaryColumn(changedColumnsInSort: string[]): boolean {\n        if (!this.columnModel.getSecondaryColumns()) {\n            return false;\n        }\n\n        const secondaryColIds = this.columnModel.getSecondaryColumns()!.map(col => col.getColId());\n\n        for (let i = 0; i < changedColumnsInSort.length; i++) {\n            if (secondaryColIds.indexOf(changedColumnsInSort[i]) > -1) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n}", "import {\n    Autowired,\n    Bean,\n    BeanStub,\n    ChangedPath,\n    Events,\n    IRowModel,\n    ISelectionService,\n    PostConstruct,\n    RowNode,\n    SelectionChangedEvent,\n    SelectionEventSourceType,\n    WithoutGridCommon,\n    ISetNodesSelectedParams,\n    ServerSideRowSelectionState,\n    ServerSideRowGroupSelectionState\n} from \"@ag-grid-community/core\";\nimport { DefaultStrategy } from \"./selection/strategies/defaultStrategy\";\nimport { GroupSelectsChildrenStrategy } from \"./selection/strategies/groupSelectsChildrenStrategy\";\nimport { ISelectionStrategy } from \"./selection/strategies/iSelectionStrategy\";\n\n@Bean('selectionService')\nexport class ServerSideSelectionService extends BeanStub implements ISelectionService {\n    @Autowired('rowModel') private rowModel: IRowModel;\n    private selectionStrategy: ISelectionStrategy;\n\n    @PostConstruct\n    private init(): void {\n        const groupSelectsChildren = this.gridOptionsService.get('groupSelectsChildren');\n        this.addManagedPropertyListener('groupSelectsChildren', (propChange) => {\n            this.destroyBean(this.selectionStrategy);\n\n            const StrategyClazz = !propChange.currentValue ? DefaultStrategy : GroupSelectsChildrenStrategy;\n            this.selectionStrategy = this.createManagedBean(new StrategyClazz());\n\n            this.shotgunResetNodeSelectionState();\n            const event: WithoutGridCommon<SelectionChangedEvent> = {\n                type: Events.EVENT_SELECTION_CHANGED,\n                source: 'api',\n            };\n            this.eventService.dispatchEvent(event);\n        });\n\n        this.addManagedPropertyListener('rowSelection', () => this.deselectAllRowNodes({ source: 'api' }));\n\n        const StrategyClazz = !groupSelectsChildren ? DefaultStrategy : GroupSelectsChildrenStrategy;\n        this.selectionStrategy = this.createManagedBean(new StrategyClazz());\n    }\n \n    public getSelectionState(): string[] | ServerSideRowSelectionState | ServerSideRowGroupSelectionState | null {\n        return this.selectionStrategy.getSelectedState();\n    }\n\n    public setSelectionState(state: string[] | ServerSideRowSelectionState | ServerSideRowGroupSelectionState, source: SelectionEventSourceType): void {\n        if (Array.isArray(state)) { return; }\n        this.selectionStrategy.setSelectedState(state);\n        this.shotgunResetNodeSelectionState();\n\n        const event: WithoutGridCommon<SelectionChangedEvent> = {\n            type: Events.EVENT_SELECTION_CHANGED,\n            source,\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    public setNodesSelected(params: ISetNodesSelectedParams): number {\n        const {nodes, ...otherParams} = params;\n\n        const rowSelection = this.gridOptionsService.get('rowSelection');\n        if (nodes.length > 1 && rowSelection !== 'multiple') {\n            console.warn(`AG Grid: cannot multi select while rowSelection='single'`);\n            return 0;\n        }\n\n        if (nodes.length > 1 && params.rangeSelect) {\n            console.warn(`AG Grid: cannot use range selection when multi selecting rows`);\n            return 0;\n        }\n\n        const adjustedParams = {\n            nodes: nodes.filter(node => node.selectable),\n            ...otherParams,\n        };\n\n        // if no selectable nodes, then return 0\n        if (!adjustedParams.nodes.length) {\n            return 0;\n        }\n \n        const changedNodes = this.selectionStrategy.setNodesSelected(adjustedParams);\n        this.shotgunResetNodeSelectionState(adjustedParams.source);\n        const event: WithoutGridCommon<SelectionChangedEvent> = {\n            type: Events.EVENT_SELECTION_CHANGED,\n            source: adjustedParams.source,\n        };\n        this.eventService.dispatchEvent(event);\n        return changedNodes;\n    }\n\n    /**\n     * Deletes the selection state for a set of nodes, for use after deleting nodes via\n     * transaction. As this is designed for transactions, all nodes should belong to the same group.\n     */\n    public deleteSelectionStateFromParent(storeRoute: string[], removedNodeIds: string[]) {\n        const stateChanged = this.selectionStrategy.deleteSelectionStateFromParent(storeRoute, removedNodeIds);\n        if (!stateChanged) {\n            return;\n        }\n\n        this.shotgunResetNodeSelectionState();\n\n        const event: WithoutGridCommon<SelectionChangedEvent> = {\n            type: Events.EVENT_SELECTION_CHANGED,\n            source: 'api',\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    private shotgunResetNodeSelectionState(source?: SelectionEventSourceType) {\n        this.rowModel.forEachNode(node => {\n            if (node.stub) {\n                return;\n            }\n\n            const isNodeSelected = this.selectionStrategy.isNodeSelected(node);\n            if (isNodeSelected !== node.isSelected()) {\n                node.selectThisNode(isNodeSelected, undefined, source);\n            }\n        });\n    }\n\n    public getSelectedNodes(): RowNode<any>[] {\n        return this.selectionStrategy.getSelectedNodes();\n    }\n\n    public getSelectedRows(): any[] {\n        return this.selectionStrategy.getSelectedRows();\n    }\n\n    public getSelectionCount(): number {\n        return this.selectionStrategy.getSelectionCount();\n    }\n\n    public syncInRowNode(rowNode: RowNode<any>, oldNode: RowNode<any> | null): void {\n        // update any refs being held in the strategies\n        this.selectionStrategy.processNewRow(rowNode);\n\n        const isNodeSelected = this.selectionStrategy.isNodeSelected(rowNode);\n\n        // if the node was selected but node is not selectable, we deselect the node.\n        // (could be due to user applying selected state directly, or a change in selectable)\n        if (isNodeSelected != false && !rowNode.selectable) {\n            this.selectionStrategy.setNodesSelected({\n                nodes: [rowNode],\n                newValue: false,\n                source: 'api',\n            });\n\n            // we need to shotgun reset here as if this was hierarchical, some group nodes\n            // may be changing from indeterminate to unchecked.\n            this.shotgunResetNodeSelectionState();\n            const event: WithoutGridCommon<SelectionChangedEvent> = {\n                type: Events.EVENT_SELECTION_CHANGED,\n                source: 'api',\n            };\n            this.eventService.dispatchEvent(event);\n            return;\n        }\n        rowNode.setSelectedInitialValue(isNodeSelected);\n    }\n\n    public reset(): void {\n        this.selectionStrategy.deselectAllRowNodes({ source: 'api' });\n    }\n\n    public isEmpty(): boolean {\n        return this.selectionStrategy.isEmpty();\n    }\n\n    public hasNodesToSelect(justFiltered = false, justCurrentPage = false) {\n        return true;\n    }\n\n    public selectAllRowNodes(params: { source: SelectionEventSourceType; justFiltered?: boolean | undefined; justCurrentPage?: boolean | undefined; }): void {\n        if (params.justCurrentPage || params.justFiltered) {\n            console.warn(\"AG Grid: selecting just filtered only works when gridOptions.rowModelType='clientSide'\");\n        }\n\n        this.selectionStrategy.selectAllRowNodes(params);\n\n        this.rowModel.forEachNode(node => {\n            if (node.stub) {\n                return;\n            }\n\n            node.selectThisNode(true, undefined, params.source);\n        });\n\n        const event: WithoutGridCommon<SelectionChangedEvent> = {\n            type: Events.EVENT_SELECTION_CHANGED,\n            source: params.source,\n        };\n        this.eventService.dispatchEvent(event);\n    }\n    \n    public deselectAllRowNodes(params: { source: SelectionEventSourceType; justFiltered?: boolean | undefined; justCurrentPage?: boolean | undefined; }): void {\n        if (params.justCurrentPage || params.justFiltered) {\n            console.warn(\"AG Grid: selecting just filtered only works when gridOptions.rowModelType='clientSide'\");\n        }\n\n        this.selectionStrategy.deselectAllRowNodes(params);\n\n        this.rowModel.forEachNode(node => {\n            if (node.stub) {\n                return;\n            }\n\n            node.selectThisNode(false, undefined, params.source);\n        });\n\n        const event: WithoutGridCommon<SelectionChangedEvent> = {\n            type: Events.EVENT_SELECTION_CHANGED,\n            source: params.source,\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    public getSelectAllState(justFiltered?: boolean, justCurrentPage?: boolean): boolean | null {\n        return this.selectionStrategy.getSelectAllState(justFiltered, justCurrentPage);\n    }\n\n    // used by CSRM\n    public updateGroupsFromChildrenSelections(source: SelectionEventSourceType, changedPath?: ChangedPath | undefined): boolean {\n        return false;\n    }\n\n    // used by CSRM\n    public getBestCostNodeSelection(): RowNode<any>[] | undefined {\n        console.warn('AG Grid: calling gridApi.getBestCostNodeSelection() is only possible when using rowModelType=`clientSide`.');\n        return undefined;\n    }\n\n    // used by CSRM\n    public filterFromSelection(): void {\n        return;\n    }\n}", "import { Autowired, BeanStub, Events, IRowModel, PostConstruct, RowNode, SelectionChangedEvent, SelectionEventSourceType, WithoutGridCommon, ISetNodesSelectedParams, IServerSideSelectionState } from \"@ag-grid-community/core\";\nimport { ISelectionStrategy } from \"./iSelectionStrategy\";\n\ninterface SelectedState {\n    selectAll: boolean;\n    toggledNodes: Set<string>;\n}\n\nexport class DefaultStrategy extends BeanStub implements ISelectionStrategy {\n    @Autowired('rowModel') private rowModel: IRowModel;\n\n    private selectedState: SelectedState = { selectAll: false, toggledNodes: new Set() };\n    private lastSelected: string | null = null;\n\n    private selectAllUsed: boolean = false;\n    // this is to prevent regressions, default selectionService retains reference of clicked nodes.\n    private selectedNodes: { [key: string]: RowNode } = {};\n\n    private rowSelection?: 'single' | 'multiple';\n\n    @PostConstruct\n    private init(): void {\n        this.rowSelection = this.gridOptionsService.get('rowSelection');\n        this.addManagedPropertyListener('rowSelection', (propChange) => {\n            this.rowSelection = propChange.currentValue;\n        });\n\n    }\n\n    public getSelectedState(): IServerSideSelectionState {\n        return {\n            selectAll: this.selectedState.selectAll,\n            toggledNodes: [...this.selectedState.toggledNodes],\n        };\n    }\n\n    public setSelectedState(state: any) {\n        // fire selection changed event\n        const newState: SelectedState = {\n            selectAll: false,\n            toggledNodes: new Set(),\n        };\n\n        if (typeof state !== 'object') {\n            console.error('AG Grid: The provided selection state should be an object.');\n            return;\n        }\n\n        if ('selectAll' in state && typeof state.selectAll === 'boolean') {\n            newState.selectAll = state.selectAll;\n        }  else {\n            console.error('AG Grid: Select all status should be of boolean type.');\n            return;\n        }\n\n        if ('toggledNodes' in state && Array.isArray(state.toggledNodes)) {\n            state.toggledNodes.forEach((key: any) => {\n                if (typeof key === 'string') {\n                    newState.toggledNodes.add(key);\n                } else {\n                    console.warn(`AG Grid: Provided ids must be of string type. Invalid id provided: ${key}`);\n                }\n            });\n        } else {\n            console.error('AG Grid: `toggledNodes` must be an array of string ids.');\n            return;\n        }\n\n        this.selectedState = newState;\n    }\n\n    public deleteSelectionStateFromParent(parentPath: string[], removedNodeIds: string[]): boolean {\n        if (this.selectedState.toggledNodes.size === 0) {\n            return false;\n        }\n\n        let anyNodesToggled = false;\n\n        removedNodeIds.forEach(id => {\n            if (this.selectedState.toggledNodes.delete(id)) {\n                anyNodesToggled = true;\n            }\n        });\n\n        return anyNodesToggled;\n    }\n\n    public setNodesSelected(params: ISetNodesSelectedParams): number {\n        if (params.nodes.length === 0) return 0;\n\n        const onlyThisNode = params.clearSelection && params.newValue && !params.rangeSelect;\n        if (this.rowSelection !== 'multiple' || onlyThisNode) {\n            if (params.nodes.length > 1) {\n                throw new Error('AG Grid: cannot select multiple rows when rowSelection is set to \\'single\\'');\n            }\n            const node = params.nodes[0];\n            if (params.newValue) {\n                this.selectedNodes = { [node.id!]: node };\n                this.selectedState = {\n                    selectAll: false,\n                    toggledNodes: new Set([node.id!]),\n                };\n            } else {\n                this.selectedNodes = {};\n                this.selectedState = {\n                    selectAll: false,\n                    toggledNodes: new Set(),\n                }\n            }\n            this.lastSelected = node.id!;\n            return 1;\n        }\n\n        const updateNodeState = (node: RowNode) => {\n            if (params.newValue) {\n                this.selectedNodes[node.id!] = node;\n            } else {\n                delete this.selectedNodes[node.id!];\n            }\n\n            const isNodeSelectable = node.selectable;\n            const doesNodeConform = params.newValue === this.selectedState.selectAll;\n            if (doesNodeConform || !isNodeSelectable) {\n                this.selectedState.toggledNodes.delete(node.id!);\n                return;\n            }\n            this.selectedState.toggledNodes.add(node.id!);\n        }\n\n        if (params.rangeSelect && this.lastSelected) {\n            if (params.nodes.length > 1) {\n                throw new Error('AG Grid: cannot select multiple rows when using rangeSelect');\n            }\n            const node = params.nodes[0];\n            const lastSelectedNode = this.rowModel.getRowNode(this.lastSelected);\n            this.rowModel.getNodesInRangeForSelection(node, lastSelectedNode ?? null).forEach(updateNodeState);\n            this.lastSelected = node.id!;\n            return 1;\n        }\n\n        params.nodes.forEach(updateNodeState);\n        this.lastSelected = params.nodes[params.nodes.length - 1].id!;\n        return 1;\n    }\n\n    public processNewRow(node: RowNode<any>): void {\n        if (this.selectedNodes[node.id!]) {\n            this.selectedNodes[node.id!] = node;\n        }\n    }\n\n    public isNodeSelected(node: RowNode): boolean | undefined {\n        const isToggled = this.selectedState.toggledNodes.has(node.id!);\n        return this.selectedState.selectAll ? !isToggled : isToggled;\n    }\n\n    public getSelectedNodes(): RowNode<any>[] {\n        if (this.selectAllUsed) {\n            console.warn(\n                `AG Grid: getSelectedNodes and getSelectedRows functions cannot be used with select all functionality with the server-side row model.\n                Use \\`api.getServerSideSelectionState()\\` instead.`\n            );\n        }\n        return Object.values(this.selectedNodes);\n    }\n\n    public getSelectedRows(): any[] {\n        return this.getSelectedNodes().map(node => node.data);\n    }\n\n    public getSelectionCount(): number {\n        if (this.selectedState.selectAll) {\n            return -1;\n        }\n        return this.selectedState.toggledNodes.size;\n    }\n\n    public clearOtherNodes(rowNodeToKeepSelected: RowNode<any>, source: SelectionEventSourceType): number {\n        const clearedRows = this.selectedState.selectAll ? 1 : this.selectedState.toggledNodes.size - 1;\n        this.selectedState = {\n            selectAll: false,\n            toggledNodes: new Set([rowNodeToKeepSelected.id!]),\n        }\n\n        this.rowModel.forEachNode(node => {\n            if (node !== rowNodeToKeepSelected) {\n                node.selectThisNode(false, undefined, source);\n            }\n        });\n\n        const event: WithoutGridCommon<SelectionChangedEvent> = {\n            type: Events.EVENT_SELECTION_CHANGED,\n            source,\n        };\n        this.eventService.dispatchEvent(event);\n\n        return clearedRows;\n    }\n\n    public isEmpty(): boolean {\n        return !this.selectedState.selectAll && !this.selectedState.toggledNodes?.size;\n    }\n    \n    public selectAllRowNodes(params: { source: SelectionEventSourceType; justFiltered?: boolean | undefined; justCurrentPage?: boolean | undefined; }): void {\n        this.selectedState = { selectAll: true, toggledNodes: new Set() };\n        this.selectedNodes = {};\n        this.selectAllUsed = true;\n    }\n\n    public deselectAllRowNodes(params: { source: SelectionEventSourceType; justFiltered?: boolean | undefined; justCurrentPage?: boolean | undefined; }): void {\n        this.selectedState = { selectAll: false, toggledNodes: new Set() };\n        this.selectedNodes = {};\n    }\n\n    public getSelectAllState(justFiltered?: boolean, justCurrentPage?: boolean): boolean | null {\n        if (this.selectedState.selectAll) {\n            if (this.selectedState.toggledNodes.size > 0) {\n                return null;\n            }\n            return true;\n        }\n\n        if (this.selectedState.toggledNodes.size > 0) {\n            return null;\n        }\n        return false;\n    }\n}", "import { Autowired, BeanStub, IRowModel, IRowNode, IServerSideGroupSelectionState, RowNode, SelectionEventSourceType, ISetNodesSelectedParams, ColumnModel, FilterManager, PostConstruct, Events, IServerSideStore, ISelectionService } from \"@ag-grid-community/core\";\nimport { ServerSideRowModel } from \"../../../serverSideRowModel\";\nimport { ISelectionStrategy } from \"./iSelectionStrategy\";\n\ninterface SelectionState {\n    selectAllChildren: boolean;\n    toggledNodes: Map<string, SelectionState>;\n}\n\nexport class GroupSelectsChildrenStrategy extends BeanStub implements ISelectionStrategy {\n    @Autowired('rowModel') private rowModel: IRowModel;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('filterManager') private filterManager: FilterManager;\n    @Autowired('rowModel') private serverSideRowModel: ServerSideRowModel;\n    @Autowired('selectionService') private selectionService: ISelectionService;\n\n    private selectedState: SelectionState = { selectAllChildren: false, toggledNodes: new Map() };\n    private lastSelected: RowNode | null = null;\n\n    @PostConstruct\n    private init(): void {\n        // if model has updated, a store may now be fully loaded to clean up indeterminate states\n        this.addManagedListener(this.eventService, Events.EVENT_MODEL_UPDATED, () => this.removeRedundantState());\n\n        // when the grouping changes, the state no longer makes sense, so reset the state.\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.selectionService.reset('rowGroupChanged'));\n    }\n\n    public getSelectedState() {\n        const treeData = this.gridOptionsService.get('treeData');\n        const recursivelySerializeState = (state: SelectionState, level: number, nodeId?: string) => {\n            const normalisedState: IServerSideGroupSelectionState = {\n                nodeId,\n            };\n    \n            if (treeData || level <= this.columnModel.getRowGroupColumns().length) {\n                normalisedState.selectAllChildren = state.selectAllChildren;\n            }\n    \n            // omit toggledNodes if empty\n            if (state.toggledNodes.size) {\n                const toggledNodes: IServerSideGroupSelectionState[] = [];\n                state.toggledNodes.forEach((value, key) => {\n                    const newState = recursivelySerializeState(value, level + 1, key);\n                    toggledNodes.push(newState);\n                });\n                normalisedState.toggledNodes = toggledNodes;\n            }\n    \n            return normalisedState;\n        }\n        return recursivelySerializeState(this.selectedState, 0);\n    }\n\n    public setSelectedState(state: IServerSideGroupSelectionState) {\n        const recursivelyDeserializeState = (normalisedState: IServerSideGroupSelectionState, parentSelected: boolean): SelectionState => {\n            if (typeof normalisedState !== 'object') {\n                throw new Error('AG Grid: Each provided state object must be an object.')\n            }\n            if ('selectAllChildren' in normalisedState && typeof normalisedState.selectAllChildren !== 'boolean') {\n                throw new Error('AG Grid: `selectAllChildren` must be a boolean value or undefined.');\n            }\n            if ('toggledNodes' in normalisedState) {\n                if (!Array.isArray(normalisedState.toggledNodes)) {\n                    throw new Error('AG Grid: `toggledNodes` must be an array.');\n                }\n                const allHaveIds = normalisedState.toggledNodes.every(innerState => (\n                    typeof innerState === 'object' && 'nodeId' in innerState && typeof innerState.nodeId === 'string'\n                ));\n                if (!allHaveIds) {\n                    throw new Error('AG Grid: Every `toggledNode` requires an associated string id.')\n                }\n            }\n            const isThisNodeSelected = normalisedState.selectAllChildren ?? !parentSelected;\n            const convertedChildren = normalisedState.toggledNodes?.map<[string, SelectionState]>(innerState => (\n                [innerState.nodeId!, recursivelyDeserializeState(innerState, isThisNodeSelected)]\n            ));\n            const doesRedundantStateExist = convertedChildren?.some(([_, innerState]) => isThisNodeSelected === innerState.selectAllChildren && innerState.toggledNodes.size === 0);\n            if (doesRedundantStateExist) {\n                throw new Error(`\n                    AG Grid: AG Grid: Row selection state could not be parsed due to invalid data. Ensure all child state has toggledNodes or does not conform with the parent rule.\n                    Please rebuild the selection state and reapply it.\n                `);\n            }\n            return {\n                selectAllChildren: isThisNodeSelected,\n                toggledNodes: new Map(convertedChildren),\n            };\n        };\n\n        try {\n            this.selectedState = recursivelyDeserializeState(state, !!state.selectAllChildren);\n        } catch (e) {\n            console.error(e.message);\n        }\n    }\n\n    public deleteSelectionStateFromParent(parentRoute: string[], removedNodeIds: string[]): boolean {\n        let parentState: SelectionState | undefined = this.selectedState;\n        const remainingRoute = [...parentRoute];\n        while (parentState && remainingRoute.length) {\n            parentState = parentState.toggledNodes.get(remainingRoute.pop()!);\n        }\n\n        // parent has no explicit state, nothing to remove\n        if (!parentState) {\n            return false;\n        }\n\n        let anyStateChanged = false;\n        removedNodeIds.forEach(id => {\n            if (parentState?.toggledNodes.delete(id)) {\n                anyStateChanged = true;\n            }\n        });\n\n        if (anyStateChanged) {\n            this.removeRedundantState();\n        }\n        return anyStateChanged;\n    }\n\n    public setNodesSelected(params: ISetNodesSelectedParams): number {\n        const { nodes, ...other } = params;\n\n        if (nodes.length === 0) return 0;\n\n        if (params.rangeSelect) {\n            if (nodes.length > 1) {\n                throw new Error('AG Grid: cannot select multiple rows when using rangeSelect');\n            }\n            const node = nodes[0];\n            const rangeOfNodes = this.rowModel.getNodesInRangeForSelection(node, this.lastSelected);\n            // sort the routes by route length, high to low, this means we can do the lowest level children first\n            const routes = rangeOfNodes.map(this.getRouteToNode).sort((a, b) => b.length - a.length);\n\n            // skip routes if we've already done a descendent\n            const completedRoutes: Set<IRowNode> = new Set();\n            routes.forEach(route => {\n                // skip routes if we've already selected a descendent\n                if (completedRoutes.has(route[route.length - 1])) {\n                    return;\n                }\n\n                route.forEach(part => completedRoutes.add(part));\n                this.recursivelySelectNode(route, this.selectedState, {node, ...other});\n            });\n\n            this.removeRedundantState();\n            this.lastSelected = node;\n            return 1;\n        }\n\n        params.nodes.forEach(node => {\n            const idPathToNode = this.getRouteToNode(node);\n            this.recursivelySelectNode(idPathToNode, this.selectedState, { ...other, node });\n        });\n        this.removeRedundantState();\n        this.lastSelected = params.nodes[params.nodes.length - 1];\n        return 1;\n    }\n\n    public isNodeSelected(node: RowNode): boolean | undefined {\n        const path = this.getRouteToNode(node);\n        return this.isNodePathSelected(path, this.selectedState);\n    }\n\n    private isNodePathSelected([nextNode, ...nodes]: RowNode[], state: SelectionState): boolean | undefined {\n        if (nodes.length === 0) {\n            const isToggled = state.toggledNodes.has(nextNode.id!);\n            if (nextNode.hasChildren()) {\n                const groupState = state.toggledNodes.get(nextNode.id!);\n                if (groupState && groupState.toggledNodes.size) {\n                    return undefined;\n                }\n            }\n            return state.selectAllChildren ? !isToggled : isToggled;\n        }\n\n        // if there's a deeper level, check recursively\n        if (state.toggledNodes.has(nextNode.id!)) {\n            const nextState = state.toggledNodes.get(nextNode.id!);\n            if (nextState) {\n                return this.isNodePathSelected(nodes, nextState);\n            }\n        }\n \n        // no deeper custom state, respect the closest default\n        return !!state.selectAllChildren;\n    }\n\n    private getRouteToNode(node: RowNode) {\n        const pathToNode = [];\n        let tempNode = node;\n        while (tempNode.parent) {\n            pathToNode.push(tempNode);\n            tempNode = tempNode.parent;\n        }\n        return pathToNode.reverse();\n    }\n\n    private removeRedundantState() {\n        if (this.filterManager.isAnyFilterPresent()) {\n            return;\n        }\n\n        const forEachNodeStateDepthFirst = (state = this.selectedState, thisKey?: string, parentState?: SelectionState) => {\n            // clean up lowest level state first in order to calculate this levels state\n            // from updated child state\n            state.toggledNodes.forEach((value, key) => {\n                forEachNodeStateDepthFirst(value, key, state);\n            });\n\n            if (thisKey) {\n                const thisRow = this.rowModel.getRowNode(thisKey);\n                const thisRowStore = thisRow?.childStore;\n                const isStoreSizeKnown = thisRowStore?.isLastRowIndexKnown();\n                if (isStoreSizeKnown) {\n                    // have to check greater than, as we may have stale state still, if so all visible rows may not be\n                    // toggled\n                    const possibleAllNodesToggled = state.toggledNodes.size >= thisRowStore!.getRowCount();\n                    if (possibleAllNodesToggled) {\n                        // more complex checks nested for performance\n                        for(const childState of state.toggledNodes.entries()) {\n                            const [key, value] = childState;\n                            // if any child has toggled rows, then this row is indeterminate\n                            // and the state is relevant.\n                            if (value.toggledNodes.size > 0) {\n                                return;\n                            }\n\n                            const rowDoesNotExist = !this.rowModel.getRowNode(key);\n                            if (rowDoesNotExist) {\n                                // if row doesn't exist, it's not toggled.\n                                return;\n                            }\n                        }\n    \n                        // no indeterminate rows, and all rows are toggled, flip this row state\n                        // and clear child states.\n                        state.selectAllChildren = !state.selectAllChildren;\n                        state.toggledNodes.clear();\n                    }\n                }\n            }\n\n            // if this has no toggled rows, and is identical to parent state, it's redundant and can be removed.\n            const hasNoToggledRows = state.toggledNodes.size === 0;\n            const isIdenticalToParent = parentState?.selectAllChildren === state.selectAllChildren;\n            if (hasNoToggledRows && isIdenticalToParent) {\n                parentState?.toggledNodes.delete(thisKey!);\n            }\n        }\n        forEachNodeStateDepthFirst();\n    }\n\n    private recursivelySelectNode([nextNode, ...nodes]: IRowNode[], selectedState: SelectionState, params: { newValue: boolean, source: SelectionEventSourceType, event?: Event, node: RowNode }) {\n        if (!nextNode) {\n            return;\n        }\n\n        // if this is the last node, hard add/remove based on its selectAllChildren state\n        const isLastNode = !nodes.length;\n        if (isLastNode) {\n            // if the node is not selectable, we should never have it in selection state\n            const isNodeSelectable = nextNode.selectable;\n            const doesNodeConform = selectedState.selectAllChildren === params.newValue;\n            if (doesNodeConform || !isNodeSelectable) {\n                selectedState.toggledNodes.delete(nextNode.id!);\n                return;\n            }\n            const newState: SelectionState = {\n                selectAllChildren: params.newValue,\n                toggledNodes: new Map(),\n            };\n            selectedState.toggledNodes.set(nextNode.id!, newState);\n            return;\n        }\n\n        const doesStateAlreadyExist = selectedState.toggledNodes.has(nextNode.id!);\n        const childState: SelectionState = doesStateAlreadyExist ? (\n            selectedState.toggledNodes.get(nextNode.id!)!\n        ) : {\n            selectAllChildren: selectedState.selectAllChildren,\n            toggledNodes: new Map(),\n        };\n\n        if (!doesStateAlreadyExist) {\n            selectedState.toggledNodes.set(nextNode.id!, childState);\n        }\n\n        this.recursivelySelectNode(nodes, childState, params);\n\n        // cleans out groups which have no toggled nodes and an equivalent default to its parent\n        if (selectedState.selectAllChildren === childState.selectAllChildren && childState.toggledNodes.size === 0) {\n            selectedState.toggledNodes.delete(nextNode.id!);\n        }\n    }\n\n    public getSelectedNodes(): RowNode<any>[] {\n        console.warn(\n            `AG Grid: \\`getSelectedNodes\\` and \\`getSelectedRows\\` functions cannot be used with \\`groupSelectsChildren\\` and the server-side row model.\n            Use \\`api.getServerSideSelectionState()\\` instead.`\n        );\n\n        const selectedNodes: RowNode[] = [];\n        this.rowModel.forEachNode(node => {\n            if (node.isSelected()) {\n                selectedNodes.push(node);\n            }\n        });\n        return selectedNodes;\n    }\n\n    public processNewRow(node: RowNode<any>): void {\n        // This is used for updating outdated node refs, as this model entirely uses ids it's irrelevant\n    }\n\n    public getSelectedRows(): any[] {\n        return this.getSelectedNodes().map(node => node.data);\n    }\n\n    public getSelectionCount(): number {\n        return -1;\n    }\n\n    public isEmpty(): boolean {\n        return !this.selectedState.selectAllChildren && !this.selectedState.toggledNodes?.size;\n    }\n\n    public selectAllRowNodes(params: { source: SelectionEventSourceType; justFiltered?: boolean | undefined; justCurrentPage?: boolean | undefined; }): void {\n        this.selectedState = { selectAllChildren: true, toggledNodes: new Map() };\n    }\n\n    public deselectAllRowNodes(params: { source: SelectionEventSourceType; justFiltered?: boolean | undefined; justCurrentPage?: boolean | undefined; }): void {\n        this.selectedState = { selectAllChildren: false, toggledNodes: new Map() };\n    }\n\n    public getSelectAllState(justFiltered?: boolean, justCurrentPage?: boolean): boolean | null {\n        if (this.selectedState.selectAllChildren) {\n            if (this.selectedState.toggledNodes.size > 0) {\n                return null;\n            }\n            return true;\n        }\n\n        if (this.selectedState.toggledNodes.size > 0) {\n            return null;\n        }\n        return false;\n    }\n}", "// DO NOT UPDATE MANUALLY: Generated from script during build time\nexport const VERSION = '31.2.0';", "import {\n    Autowired,\n    Bean,\n    Events,\n    ExpansionService,\n    IExpansionService,\n    IsServerSideGroupOpenByDefaultParams,\n    RowNode,\n    WithoutGridCommon\n} from \"@ag-grid-community/core\";\nimport { ServerSideRowModel } from \"../serverSideRowModel\";\n\n@Bean('expansionService')\nexport class ServerSideExpansionService extends ExpansionService implements IExpansionService {\n    @Autowired('rowModel') private readonly serverSideRowModel: ServerSideRowModel;\n\n    private queuedRowIds: Set<string> = new Set();\n\n    protected postConstruct(): void {\n        super.postConstruct();\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => {\n            this.queuedRowIds.clear();\n        });\n    }\n\n    public checkOpenByDefault(rowNode: RowNode): void {\n        if (!rowNode.isExpandable()) { return; }\n\n        if (this.queuedRowIds.has(rowNode.id!)) {\n            this.queuedRowIds.delete(rowNode.id!);\n            rowNode.setExpanded(true);\n            return;\n        }\n\n        const userFunc = this.gridOptionsService.getCallback('isServerSideGroupOpenByDefault');\n        if (!userFunc) { return; }\n\n        const params: WithoutGridCommon<IsServerSideGroupOpenByDefaultParams> = {\n            data: rowNode.data,\n            rowNode\n        };\n\n        const userFuncRes = userFunc(params);\n\n        if (userFuncRes) {\n            rowNode.setExpanded(true);\n        }\n    }\n\n    public expandRows(rowIds: string[]): void {\n        rowIds.forEach(rowId => {\n            const rowNode = this.serverSideRowModel.getRowNode(rowId);\n            if (rowNode) {\n                rowNode.setExpanded(true);\n            } else {\n                this.queuedRowIds.add(rowId);\n            }\n        });\n    }\n\n    public expandAll(value: boolean): void {\n        this.serverSideRowModel.expandAll(value);\n    }\n\n    public onGroupExpandedOrCollapsed(): void {\n        // do nothing\n    }\n}"],
  "mappings": "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",
  "names": ["_", "Autowired", "Bean", "BeanStub", "Events", "NumberSequence", "PostConstruct", "PreDestroy", "RowNode", "_", "Autowired", "BeanStub", "Events", "NumberSequence", "PostConstruct", "PreDestroy", "ServerSideTransactionResultStatus", "Autowired", "BeanStub", "PostConstruct", "PreDestroy", "Autowired", "PostConstruct", "RowNodeBlockLoader", "RowNodeBlockLoader", "params", "Autowired", "PostConstruct", "BeanStub", "storeIndexFromEndIndex", "numberOfRowsToSkip", "lazyNode", "_a", "_", "Autowired", "PostConstruct", "PreDestroy", "BeanStub", "NumberSequence", "Events", "ServerSideTransactionResultStatus", "numberOfRowDiff", "nextTop", "lazyNode", "_", "Autowired", "PostConstruct", "PreDestroy", "BeanStub", "_", "Events", "RowNode", "NumberSequence", "Autowired", "PreDestroy", "PostConstruct", "Bean", "_", "Autowired", "Bean", "BeanStub", "BeanStub", "_", "Autowired", "Bean", "_", "Autowired", "Bean", "BeanStub", "RowNode", "BeanStub", "RowNode", "_", "Autowired", "Bean", "Bean", "PreDestroy", "PreDestroy", "Bean", "Autowired", "Bean", "BeanStub", "Events", "PostConstruct", "ServerSideTransactionResultStatus", "BeanStub", "ServerSideTransactionResultStatus", "Events", "Autowired", "PostConstruct", "Bean", "_", "Autowired", "BeanStub", "Events", "PostConstruct", "RowNode", "Bean", "BeanStub", "Events", "_", "RowNode", "Autowired", "PostConstruct", "Bean", "Autowired", "Bean", "BeanStub", "Events", "PostConstruct", "BeanStub", "Events", "Autowired", "PostConstruct", "Bean", "Autowired", "Bean", "BeanStub", "Events", "PostConstruct", "BeanStub", "Events", "Autowired", "PostConstruct", "Bean", "_", "Autowired", "Bean", "_", "Autowired", "Bean", "Autowired", "Bean", "Autowired", "Bean", "Autowired", "Bean", "BeanStub", "Events", "PostConstruct", "Autowired", "BeanStub", "Events", "PostConstruct", "BeanStub", "Events", "Autowired", "PostConstruct", "Autowired", "BeanStub", "PostConstruct", "Events", "BeanStub", "Events", "_", "Autowired", "PostConstruct", "BeanStub", "StrategyClazz", "Events", "Autowired", "PostConstruct", "Bean", "Autowired", "Bean", "Events", "Events", "Autowired", "Bean"]
}
