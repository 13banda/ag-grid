{
  "version": 3,
  "sources": ["../../src/main.ts", "../../src/clipboardModule.ts", "../../src/clipboard/clipboardService.ts", "../../src/version.ts"],
  "sourcesContent": ["export { ClipboardModule } from \"./clipboardModule\";\n", "import { Module, ModuleNames } from \"@ag-grid-community/core\";\nimport { EnterpriseCoreModule } from \"@ag-grid-enterprise/core\";\nimport { CsvExportModule } from \"@ag-grid-community/csv-export\";\nimport { ClipboardService } from \"./clipboard/clipboardService\";\nimport { VERSION } from \"./version\";\n\nexport const ClipboardModule: Module = {\n    version: VERSION,\n    moduleName: ModuleNames.ClipboardModule,\n    beans: [ClipboardService],\n    dependantModules: [\n        EnterpriseCoreModule,\n        CsvExportModule\n    ]\n};\n", "import {\n    _,\n    Autowired,\n    Bean,\n    BeanStub,\n    CellNavigationService,\n    CellPosition,\n    CellPositionUtils,\n    CellRange,\n    ChangedPath,\n    IClientSideRowModel,\n    IClipboardCopyParams,\n    IClipboardCopyRowsParams,\n    Column,\n    ColumnModel,\n    CsvExportParams,\n    CutEndEvent,\n    CutStartEvent,\n    Events,\n    FlashCellsEvent,\n    FocusService,\n    GridCtrl,\n    IClipboardService,\n    IRowModel,\n    Logger,\n    LoggerFactory,\n    PasteEndEvent,\n    PasteStartEvent,\n    PostConstruct,\n    ProcessCellForExportParams,\n    RowNode,\n    RowPosition,\n    RowPositionUtils,\n    RowRenderer,\n    RowValueChangedEvent,\n    ISelectionService,\n    ValueService,\n    ICsvCreator,\n    IRangeService,\n    Optional,\n    CtrlsService,\n    WithoutGridCommon,\n    ProcessRowGroupForExportParams,\n    ValueFormatterService,\n    ValueParserService\n} from \"@ag-grid-community/core\";\n\ninterface RowCallback {\n    (gridRow: RowPosition, rowNode: RowNode | undefined, columns: Column[], rangeIndex: number, isLastRow?: boolean): void;\n}\n\ninterface ColumnCallback {\n    (columns: Column[]): void;\n}\n\ntype CellsToFlashType = { [key: string]: boolean }\ntype DataForCellRangesType = { data: string, cellsToFlash: CellsToFlashType }\n\n// Matches value in changeDetectionService\nconst SOURCE_PASTE = 'paste';\nconst EXPORT_TYPE_DRAG_COPY = 'dragCopy';\nconst EXPORT_TYPE_CLIPBOARD = 'clipboard';\n\nenum CellClearType { CellRange, SelectedRows, FocusedCell };\n\nconst apiError = (method: string) => `AG Grid: Unable to use the Clipboard API (navigator.clipboard.${method}()). ` +\n'The reason why it could not be used has been logged in the previous line. ' +\n'For this reason the grid has defaulted to using a workaround which doesn\\'t perform as well. ' +\n'Either fix why Clipboard API is blocked, OR stop this message from appearing by setting grid ' +\n'property suppressClipboardApi=true (which will default the grid to using the workaround rather than the API.';\n\n@Bean('clipboardService')\nexport class ClipboardService extends BeanStub implements IClipboardService {\n\n    @Autowired('csvCreator') private csvCreator: ICsvCreator;\n    @Autowired('loggerFactory') private loggerFactory: LoggerFactory;\n    @Autowired('selectionService') private selectionService: ISelectionService;\n    @Optional('rangeService') private rangeService: IRangeService;\n    @Autowired('rowModel') private rowModel: IRowModel;\n    @Autowired('ctrlsService') public ctrlsService: CtrlsService;\n\n    @Autowired('valueService') private valueService: ValueService;\n    @Autowired('focusService') private focusService: FocusService;\n    @Autowired('rowRenderer') private rowRenderer: RowRenderer;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('cellNavigationService') private cellNavigationService: CellNavigationService;\n    @Autowired('cellPositionUtils') public cellPositionUtils: CellPositionUtils;\n    @Autowired('rowPositionUtils') public rowPositionUtils: RowPositionUtils;\n    @Autowired('valueFormatterService') private valueFormatterService: ValueFormatterService;\n    @Autowired('valueParserService') private valueParserService: ValueParserService;\n\n    private clientSideRowModel: IClientSideRowModel;\n    private logger: Logger;\n    private gridCtrl: GridCtrl;\n    private lastPasteOperationTime: number = 0;\n\n    private navigatorApiFailed = false;\n\n    @PostConstruct\n    private init(): void {\n        this.logger = this.loggerFactory.create('ClipboardService');\n\n        if (this.rowModel.getType() === 'clientSide') {\n            this.clientSideRowModel = this.rowModel as IClientSideRowModel;\n        }\n\n        this.ctrlsService.whenReady(p => {\n            this.gridCtrl = p.gridCtrl;\n        });\n\n    }\n\n    public pasteFromClipboard(): void {\n        this.logger.log('pasteFromClipboard');\n\n        // Method 1 - native clipboard API, available in modern chrome browsers\n        const allowNavigator = !this.gridOptionsService.get('suppressClipboardApi');\n        // Some browsers (Firefox) do not allow Web Applications to read from\n        // the clipboard so verify if not only the ClipboardAPI is available,\n        // but also if the `readText` method is public.\n        if (allowNavigator && !this.navigatorApiFailed && navigator.clipboard && navigator.clipboard.readText) {\n            navigator.clipboard.readText()\n                .then(this.processClipboardData.bind(this))\n                .catch((e) => {\n                    _.doOnce(() => {\n                        console.warn(e);\n                        console.warn(apiError('readText'));\n                    }, 'clipboardApiError');\n                    this.navigatorApiFailed = true;\n                    this.pasteFromClipboardLegacy();\n                });\n        } else {\n            this.pasteFromClipboardLegacy();\n        }\n    }\n\n    private pasteFromClipboardLegacy(): void {\n        // Method 2 - if modern API fails, the old school hack\n        let defaultPrevented = false;\n        const handlePasteEvent = (e: ClipboardEvent) => {\n            const currentPastOperationTime = (new Date()).getTime();\n            if (currentPastOperationTime - this.lastPasteOperationTime < 50) {\n                defaultPrevented = true;\n                e.preventDefault();\n            }\n            this.lastPasteOperationTime = currentPastOperationTime;\n        }\n\n        this.executeOnTempElement(\n            (textArea: HTMLTextAreaElement) => {\n                textArea.addEventListener('paste', handlePasteEvent);\n                textArea.focus({ preventScroll: true });\n\n            },\n            (element: HTMLTextAreaElement) => {\n                const data = element.value;\n                if (!defaultPrevented) {\n                    this.processClipboardData(data);\n                } else {\n                    this.refocusLastFocusedCell();\n                }\n                element.removeEventListener('paste', handlePasteEvent);\n            }\n        );\n    }\n\n    private refocusLastFocusedCell(): void {\n        const focusedCell = this.focusService.getFocusedCell();\n\n        if (focusedCell) {\n            this.focusService.setFocusedCell({\n                rowIndex: focusedCell.rowIndex,\n                column: focusedCell.column, \n                rowPinned: focusedCell.rowPinned, \n                forceBrowserFocus: true\n            });\n        }\n    }\n\n    private getClipboardDelimiter() {\n        const delimiter = this.gridOptionsService.get('clipboardDelimiter');\n        return _.exists(delimiter) ? delimiter : '\\t';\n    }\n\n    private processClipboardData(data: string): void {\n        if (data == null) { return; }\n\n        let parsedData: string[][] | null = ClipboardService.stringToArray(data, this.getClipboardDelimiter());\n\n        const userFunc = this.gridOptionsService.getCallback('processDataFromClipboard');\n\n        if (userFunc) {\n            parsedData = userFunc({ data: parsedData });\n        }\n\n        if (parsedData == null) { return; }\n\n        if (this.gridOptionsService.get('suppressLastEmptyLineOnPaste')) {\n            this.removeLastLineIfBlank(parsedData!);\n        }\n\n        const pasteOperation = (\n            cellsToFlash: any,\n            updatedRowNodes: RowNode[],\n            focusedCell: CellPosition,\n            changedPath: ChangedPath | undefined) => {\n\n            const rangeActive = this.rangeService && this.rangeService.isMoreThanOneCell();\n            const pasteIntoRange = rangeActive && !this.hasOnlyOneValueToPaste(parsedData!);\n\n            if (pasteIntoRange) {\n                this.pasteIntoActiveRange(parsedData!, cellsToFlash, updatedRowNodes, changedPath);\n            } else {\n                this.pasteStartingFromFocusedCell(parsedData!, cellsToFlash, updatedRowNodes, focusedCell, changedPath);\n            }\n        };\n\n        this.doPasteOperation(pasteOperation);\n    }\n\n    // This will parse a delimited string into an array of arrays.\n    static stringToArray(strData: string, delimiter = ','): string[][] {\n        const data: any[][] = [];\n        const isNewline = (char: string) => char === '\\r' || char === '\\n';\n\n        let insideQuotedField = false;\n\n        if (strData === '') { return [['']]; }\n\n        // iterate over each character, keep track of current row and column (of the returned array)\n        for (let row = 0, column = 0, position = 0; position < strData.length; position++) {\n            const previousChar = strData[position - 1];\n            const currentChar = strData[position];\n            const nextChar = strData[position + 1];\n            const ensureDataExists = () => {\n                if (!data[row]) {\n                    // create row if it doesn't exist\n                    data[row] = [];\n                }\n\n                if (!data[row][column]) {\n                    // create column if it doesn't exist\n                    data[row][column] = '';\n                }\n            };\n\n            ensureDataExists();\n\n            if (currentChar === '\"') {\n                if (insideQuotedField) {\n                    if (nextChar === '\"') {\n                        // unescape double quote\n                        data[row][column] += '\"';\n                        position++;\n                    } else {\n                        // exit quoted field\n                        insideQuotedField = false;\n                    }\n\n                    // continue;\n                } else if (previousChar === undefined || previousChar === delimiter || isNewline(previousChar)) {\n                    // enter quoted field\n                    insideQuotedField = true;\n                    // continue;\n                }\n            }\n\n            if (!insideQuotedField && currentChar !== '\"') {\n                if (currentChar === delimiter) {\n                    // move to next column\n                    column++;\n                    ensureDataExists();\n\n                    continue;\n                } else if (isNewline(currentChar)) {\n                    // move to next row\n                    column = 0;\n                    row++;\n                    ensureDataExists();\n\n                    if (currentChar === '\\r' && nextChar === '\\n') {\n                        // skip over second newline character if it exists\n                        position++;\n                    }\n\n                    continue;\n                }\n            }\n\n            // add current character to current column\n            data[row][column] += currentChar;\n        }\n\n        return data;\n    }\n\n\n    // common code to paste operations, e.g. paste to cell, paste to range, and copy range down\n    private doPasteOperation(pasteOperationFunc: (\n        cellsToFlash: any,\n        updatedRowNodes: RowNode[],\n        focusedCell: CellPosition | null,\n        changedPath: ChangedPath | undefined) => void\n    ): void {\n        const source = 'clipboard';\n\n        this.eventService.dispatchEvent({\n            type: Events.EVENT_PASTE_START,\n            source\n        } as WithoutGridCommon<PasteStartEvent>);\n\n        let changedPath: ChangedPath | undefined;\n\n        if (this.clientSideRowModel) {\n            const onlyChangedColumns = this.gridOptionsService.get('aggregateOnlyChangedColumns');\n            changedPath = new ChangedPath(onlyChangedColumns, this.clientSideRowModel.getRootNode());\n        }\n\n        const cellsToFlash = {} as any;\n        const updatedRowNodes: RowNode[] = [];\n        const focusedCell = this.focusService.getFocusedCell();\n\n        pasteOperationFunc(cellsToFlash, updatedRowNodes, focusedCell, changedPath);\n\n        const nodesToRefresh: RowNode[] = [...updatedRowNodes];\n        if (changedPath) {\n            this.clientSideRowModel.doAggregate(changedPath);\n\n            // add all nodes impacted by aggregation, as they need refreshed also.\n            changedPath.forEachChangedNodeDepthFirst(rowNode => {\n                nodesToRefresh.push(rowNode);\n            });\n        }\n\n        // clipboardService has to do changeDetection itself, to prevent repeat logic in favour of batching.\n        // changeDetectionService is disabled for this action.\n        this.rowRenderer.refreshCells({ rowNodes: nodesToRefresh });\n\n        this.dispatchFlashCells(cellsToFlash);\n        this.fireRowChanged(updatedRowNodes);\n\n        // if using the clipboard hack with a temp element, then the focus has been lost,\n        // so need to put it back. otherwise paste operation loosed focus on cell and keyboard\n        // navigation stops.\n        this.refocusLastFocusedCell();\n        const event: WithoutGridCommon<PasteEndEvent> = {\n            type: Events.EVENT_PASTE_END,\n            source\n        }\n        this.eventService.dispatchEvent(event);\n    }\n\n    private pasteIntoActiveRange(\n        clipboardData: string[][],\n        cellsToFlash: any,\n        updatedRowNodes: RowNode[],\n        changedPath: ChangedPath | undefined\n    ) {\n        // true if clipboard data can be evenly pasted into range, otherwise false\n        const abortRepeatingPasteIntoRows = this.getRangeSize() % clipboardData.length != 0;\n\n        let indexOffset = 0;\n        let dataRowIndex = 0;\n\n        const rowCallback: RowCallback = (currentRow: RowPosition, rowNode: RowNode, columns: Column[], index: number) => {\n            const atEndOfClipboardData = index - indexOffset >= clipboardData.length;\n\n            if (atEndOfClipboardData) {\n                if (abortRepeatingPasteIntoRows) { return; }\n\n                // increment offset and reset data index to repeat paste of data\n                indexOffset += dataRowIndex;\n                dataRowIndex = 0;\n            }\n\n            const currentRowData = clipboardData[index - indexOffset];\n\n            // otherwise we are not the first row, so copy\n            updatedRowNodes.push(rowNode);\n\n            const processCellFromClipboardFunc = this.gridOptionsService.getCallback('processCellFromClipboard');\n\n            columns.forEach((column, idx) => {\n                if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) { return; }\n\n                // repeat data for columns we don't have data for - happens when to range is bigger than copied data range\n                if (idx >= currentRowData.length) {\n                    idx = idx % currentRowData.length;\n                }\n\n                const newValue = this.processCell(\n                    rowNode, column, currentRowData[idx], EXPORT_TYPE_DRAG_COPY, processCellFromClipboardFunc, true);\n\n                rowNode.setDataValue(column, newValue, SOURCE_PASTE);\n\n                if (changedPath) {\n                    changedPath.addParentNode(rowNode.parent, [column]);\n                }\n\n                const { rowIndex, rowPinned } = currentRow;\n                const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n                cellsToFlash[cellId] = true;\n            });\n\n            dataRowIndex++;\n        };\n\n        this.iterateActiveRanges(false, rowCallback);\n    }\n\n    private pasteStartingFromFocusedCell(\n        parsedData: string[][],\n        cellsToFlash: any,\n        updatedRowNodes: RowNode[],\n        focusedCell: CellPosition,\n        changedPath: ChangedPath | undefined\n    ) {\n        if (!focusedCell) { return; }\n\n        const currentRow: RowPosition = { rowIndex: focusedCell.rowIndex, rowPinned: focusedCell.rowPinned };\n        const columnsToPasteInto = this.columnModel.getDisplayedColumnsStartingAt(focusedCell.column);\n\n        if (this.isPasteSingleValueIntoRange(parsedData)) {\n            this.pasteSingleValueIntoRange(parsedData, updatedRowNodes, cellsToFlash, changedPath);\n        } else {\n            this.pasteMultipleValues(\n                parsedData,\n                currentRow,\n                updatedRowNodes,\n                columnsToPasteInto,\n                cellsToFlash,\n                EXPORT_TYPE_CLIPBOARD,\n                changedPath);\n        }\n    }\n\n    // if range is active, and only one cell, then we paste this cell into all cells in the active range.\n    private isPasteSingleValueIntoRange(parsedData: string[][]): boolean {\n        return this.hasOnlyOneValueToPaste(parsedData)\n            && this.rangeService != null\n            && !this.rangeService.isEmpty();\n    }\n\n    private pasteSingleValueIntoRange(parsedData: string[][], updatedRowNodes: RowNode[], cellsToFlash: any, changedPath: ChangedPath | undefined) {\n        const value = parsedData[0][0];\n\n        const rowCallback: RowCallback = (currentRow: RowPosition, rowNode: RowNode, columns: Column[]) => {\n            updatedRowNodes.push(rowNode);\n            columns.forEach(column =>\n                this.updateCellValue(rowNode, column, value, cellsToFlash, EXPORT_TYPE_CLIPBOARD, changedPath));\n        };\n\n        this.iterateActiveRanges(false, rowCallback);\n    }\n\n    private hasOnlyOneValueToPaste(parsedData: string[][]) {\n        return parsedData.length === 1 && parsedData[0].length === 1;\n    }\n\n    public copyRangeDown(): void {\n        if (!this.rangeService || this.rangeService.isEmpty()) {\n            return;\n        }\n\n        const firstRowValues: any[] = [];\n\n        const pasteOperation = (\n            cellsToFlash: any,\n            updatedRowNodes: RowNode[],\n            focusedCell: CellPosition,\n            changedPath: ChangedPath | undefined\n        ) => {\n            const processCellForClipboardFunc = this.gridOptionsService.getCallback('processCellForClipboard');\n            const processCellFromClipboardFunc = this.gridOptionsService.getCallback('processCellFromClipboard');\n\n            const rowCallback: RowCallback = (currentRow: RowPosition, rowNode: RowNode, columns: Column[]) => {\n                // take reference of first row, this is the one we will be using to copy from\n                if (!firstRowValues.length) {\n                    // two reasons for looping through columns\n                    columns.forEach(column => {\n                        // get the initial values to copy down\n                        const value = this.processCell(\n                            rowNode,\n                            column,\n                            this.valueService.getValue(column, rowNode),\n                            EXPORT_TYPE_DRAG_COPY,\n                            processCellForClipboardFunc, false, true);\n\n                        firstRowValues.push(value);\n                    });\n                } else {\n                    // otherwise we are not the first row, so copy\n                    updatedRowNodes.push(rowNode);\n                    columns.forEach((column, index) => {\n                        if (!column.isCellEditable(rowNode) || column.isSuppressPaste(rowNode)) { return; }\n\n                        const firstRowValue = this.processCell(\n                            rowNode, column, firstRowValues[index], EXPORT_TYPE_DRAG_COPY, processCellFromClipboardFunc, true);\n\n                        rowNode.setDataValue(column, firstRowValue, SOURCE_PASTE);\n\n                        if (changedPath) {\n                            changedPath.addParentNode(rowNode.parent, [column]);\n                        }\n\n                        const { rowIndex, rowPinned } = currentRow;\n                        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n                        cellsToFlash[cellId] = true;\n                    });\n                }\n            };\n\n            this.iterateActiveRanges(true, rowCallback);\n        };\n\n        this.doPasteOperation(pasteOperation);\n    }\n\n    private removeLastLineIfBlank(parsedData: string[][]): void {\n        // remove last row if empty, excel puts empty last row in\n        const lastLine = _.last(parsedData);\n        const lastLineIsBlank = lastLine && lastLine.length === 1 && lastLine[0] === '';\n\n        if (lastLineIsBlank) {\n            // do not remove the last empty line when that is the only line pasted\n            if (parsedData.length === 1) { return; }\n            _.removeFromArray(parsedData, lastLine);\n        }\n    }\n\n    private fireRowChanged(rowNodes: RowNode[]): void {\n        if (this.gridOptionsService.get('editType') !== 'fullRow') { return; }\n\n        rowNodes.forEach(rowNode => {\n            const event: WithoutGridCommon<RowValueChangedEvent> = {\n                type: Events.EVENT_ROW_VALUE_CHANGED,\n                node: rowNode,\n                data: rowNode.data,\n                rowIndex: rowNode.rowIndex!,\n                rowPinned: rowNode.rowPinned\n            };\n\n            this.eventService.dispatchEvent(event);\n        });\n    }\n\n    private pasteMultipleValues(\n        clipboardGridData: string[][],\n        currentRow: RowPosition | null,\n        updatedRowNodes: RowNode[],\n        columnsToPasteInto: Column[],\n        cellsToFlash: any,\n        type: string,\n        changedPath: ChangedPath | undefined): void {\n\n        let rowPointer = currentRow;\n\n        // if doing CSRM and NOT tree data, then it means groups are aggregates, which are read only,\n        // so we should skip them when doing paste operations.\n        const skipGroupRows = this.clientSideRowModel != null && !this.gridOptionsService.get('enableGroupEdit') && !this.gridOptionsService.get('treeData');\n\n        const getNextGoodRowNode = () => {\n            while (true) {\n                if (!rowPointer) { return null; }\n                const res = this.rowPositionUtils.getRowNode(rowPointer);\n                // move to next row down for next set of values\n                rowPointer = this.cellNavigationService.getRowBelow({ rowPinned: rowPointer.rowPinned, rowIndex: rowPointer.rowIndex });\n\n                // if no more rows, return null\n                if (res == null) { return null; }\n\n                // skip details rows and footer rows, never paste into them as they don't hold data\n                const skipRow = res.detail || res.footer || (skipGroupRows && res.group);\n\n                // skipping row means we go into the next iteration of the while loop\n                if (!skipRow) { return res; }\n            }\n        };\n\n        clipboardGridData.forEach(clipboardRowData => {\n            const rowNode = getNextGoodRowNode();\n\n            // if we have come to end of rows in grid, then skip\n            if (!rowNode) { return; }\n\n            clipboardRowData.forEach((value, index) =>\n                this.updateCellValue(rowNode, columnsToPasteInto[index], value, cellsToFlash, type, changedPath));\n\n            updatedRowNodes.push(rowNode);\n        });\n    }\n\n    private updateCellValue(\n        rowNode: RowNode | null,\n        column: Column,\n        value: string,\n        cellsToFlash: any,\n        type: string,\n        changedPath: ChangedPath | undefined) {\n        if (\n            !rowNode ||\n            !column ||\n            !column.isCellEditable(rowNode) ||\n            column.isSuppressPaste(rowNode)\n        ) { return; }\n\n\n        // if the cell is a group and the col is an aggregation, skip the cell.\n        if (rowNode.group && column.isValueActive()) { return; }\n\n        const processedValue = this.processCell(rowNode, column, value, type, this.gridOptionsService.getCallback('processCellFromClipboard'), true);\n        rowNode.setDataValue(column, processedValue, SOURCE_PASTE);\n        \n        const { rowIndex, rowPinned } = rowNode;\n        const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex: rowIndex!, column, rowPinned });\n        cellsToFlash[cellId] = true;\n\n        if (changedPath) {\n            changedPath.addParentNode(rowNode.parent, [column]);\n        }\n    }\n\n    public copyToClipboard(params: IClipboardCopyParams = {}): void {\n        this.copyOrCutToClipboard(params);\n    }\n\n    public cutToClipboard(params: IClipboardCopyParams = {}, source: 'api' | 'ui' | 'contextMenu' = 'api'): void {\n        if (this.gridOptionsService.get('suppressCutToClipboard')) { return; }\n\n        const startEvent: WithoutGridCommon<CutStartEvent> = {\n            type: Events.EVENT_CUT_START,\n            source\n        };\n        this.eventService.dispatchEvent(startEvent);\n\n        this.copyOrCutToClipboard(params, true);\n\n        const endEvent: WithoutGridCommon<CutEndEvent> = {\n            type: Events.EVENT_CUT_END,\n            source\n        };\n        this.eventService.dispatchEvent(endEvent);\n\n    }\n\n    private copyOrCutToClipboard(params: IClipboardCopyParams, cut?: boolean): void {\n        let { includeHeaders, includeGroupHeaders } = params;\n        this.logger.log(`copyToClipboard: includeHeaders = ${includeHeaders}`);\n\n        // don't override 'includeHeaders' if it has been explicitly set to 'false'\n        if (includeHeaders == null) {\n            includeHeaders = this.gridOptionsService.get('copyHeadersToClipboard');\n        }\n\n        if (includeGroupHeaders == null) {\n            includeGroupHeaders = this.gridOptionsService.get('copyGroupHeadersToClipboard');\n        }\n\n        const copyParams = { includeHeaders, includeGroupHeaders };\n        const shouldCopyRows = !this.gridOptionsService.get('suppressCopyRowsToClipboard');\n\n\n        let cellClearType: CellClearType | null = null;\n        // Copy priority is Range > Row > Focus\n        if (this.rangeService && !this.rangeService.isEmpty() && !this.shouldSkipSingleCellRange()) {\n            this.copySelectedRangeToClipboard(copyParams);\n            cellClearType = CellClearType.CellRange;\n        } else if (shouldCopyRows && !this.selectionService.isEmpty()) {\n            this.copySelectedRowsToClipboard(copyParams);\n            cellClearType = CellClearType.SelectedRows;\n        } else if (this.focusService.isAnyCellFocused()) {\n            this.copyFocusedCellToClipboard(copyParams);\n            cellClearType = CellClearType.FocusedCell;\n        }\n\n        if (cut && cellClearType !== null) {\n            this.clearCellsAfterCopy(cellClearType);\n        }\n    }\n\n    private clearCellsAfterCopy(type: CellClearType) {\n        this.eventService.dispatchEvent({ type: Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_START });\n        if (type === CellClearType.CellRange) {\n            this.rangeService.clearCellRangeCellValues({ cellEventSource: 'clipboardService' });\n        } else if (type === CellClearType.SelectedRows) {\n            this.clearSelectedRows();\n        } else {\n            const focusedCell = this.focusService.getFocusedCell();\n            if (focusedCell == null) { return; }\n\n            const rowNode = this.rowPositionUtils.getRowNode(focusedCell);\n            if (rowNode) {\n                this.clearCellValue(rowNode, focusedCell.column);\n            }\n        }\n        this.eventService.dispatchEvent({ type: Events.EVENT_KEY_SHORTCUT_CHANGED_CELL_END });\n    }\n\n    private clearSelectedRows(): void {\n        const selected = this.selectionService.getSelectedNodes();\n        const columns = this.columnModel.getAllDisplayedColumns();\n\n        for (const row of selected) {\n            for (const col of columns) {\n                this.clearCellValue(row, col);\n            }\n        }\n    }\n\n    private clearCellValue(rowNode: RowNode, column: Column): void {\n        if (!column.isCellEditable(rowNode)) { return; }\n        rowNode.setDataValue(column, null, 'clipboardService');\n    }\n\n    private shouldSkipSingleCellRange(): boolean {\n        return this.gridOptionsService.get('suppressCopySingleCellRanges') && !this.rangeService.isMoreThanOneCell();\n    }\n\n    private iterateActiveRanges(onlyFirst: boolean, rowCallback: RowCallback, columnCallback?: ColumnCallback): void {\n        if (!this.rangeService || this.rangeService.isEmpty()) { return; }\n\n        const cellRanges = this.rangeService.getCellRanges();\n\n        if (onlyFirst) {\n            this.iterateActiveRange(cellRanges[0], rowCallback, columnCallback, true);\n        } else {\n            cellRanges.forEach((range, idx) => this.iterateActiveRange(range, rowCallback, columnCallback, idx === cellRanges.length - 1));\n        }\n    }\n\n    private iterateActiveRange(range: CellRange, rowCallback: RowCallback, columnCallback?: ColumnCallback, isLastRange?: boolean): void {\n        if (!this.rangeService) { return; }\n\n        let currentRow: RowPosition | null = this.rangeService.getRangeStartRow(range);\n        const lastRow = this.rangeService.getRangeEndRow(range);\n\n        if (columnCallback && range.columns) {\n            columnCallback(range.columns);\n        }\n\n        let rangeIndex = 0;\n        let isLastRow = false;\n\n        // the currentRow could be missing if the user sets the active range manually, and sets a range\n        // that is outside of the grid (eg. sets range rows 0 to 100, but grid has only 20 rows).\n        while (!isLastRow && currentRow != null) {\n            const rowNode = this.rowPositionUtils.getRowNode(currentRow);\n            isLastRow = this.rowPositionUtils.sameRow(currentRow, lastRow);\n\n            rowCallback(currentRow, rowNode, range.columns, rangeIndex++, isLastRow && isLastRange);\n\n            currentRow = this.cellNavigationService.getRowBelow(currentRow);\n        }\n    }\n\n    public copySelectedRangeToClipboard(params: IClipboardCopyParams = {}): void {\n        if (!this.rangeService || this.rangeService.isEmpty()) { return; }\n\n        const allRangesMerge = this.rangeService.areAllRangesAbleToMerge();\n        const { data, cellsToFlash } = allRangesMerge ? this.buildDataFromMergedRanges(params) : this.buildDataFromRanges(params);\n\n        this.copyDataToClipboard(data);\n        this.dispatchFlashCells(cellsToFlash);\n    }\n\n    private buildDataFromMergedRanges(params: IClipboardCopyParams): DataForCellRangesType {\n        const columnsSet: Set<Column> = new Set();\n        const ranges = this.rangeService.getCellRanges();\n        const rowPositionsMap: Map<string, boolean> = new Map();\n        const allRowPositions: RowPosition[] = [];\n        const allCellsToFlash: CellsToFlashType = {};\n\n        ranges.forEach(range => {\n            range.columns.forEach(col => columnsSet.add(col));\n            const { rowPositions, cellsToFlash } = this.getRangeRowPositionsAndCellsToFlash(range);\n            rowPositions.forEach(rowPosition => {\n                const rowPositionAsString = `${rowPosition.rowIndex}-${rowPosition.rowPinned || 'null'}`;\n                if (!rowPositionsMap.get(rowPositionAsString)) {\n                    rowPositionsMap.set(rowPositionAsString, true);\n                    allRowPositions.push(rowPosition);\n                }\n            })\n            Object.assign(allCellsToFlash, cellsToFlash);\n        });\n\n        const allColumns = this.columnModel.getAllDisplayedColumns();\n        const exportedColumns = Array.from(columnsSet);\n\n        exportedColumns.sort((a, b) => {\n            const posA = allColumns.indexOf(a);\n            const posB = allColumns.indexOf(b);\n\n            return posA - posB;\n        });\n\n        const data = this.buildExportParams({\n            columns: exportedColumns,\n            rowPositions: allRowPositions,\n            includeHeaders: params.includeHeaders,\n            includeGroupHeaders: params.includeGroupHeaders,\n        });\n\n        return { data, cellsToFlash: allCellsToFlash };\n    }\n\n    private buildDataFromRanges(params: IClipboardCopyParams): DataForCellRangesType {\n        const ranges = this.rangeService.getCellRanges();\n        const data: string[] = [];\n        const allCellsToFlash: CellsToFlashType = {};\n\n        ranges.forEach(range => {\n            const { rowPositions, cellsToFlash } = this.getRangeRowPositionsAndCellsToFlash(range);\n            Object.assign(allCellsToFlash, cellsToFlash);\n            data.push(this.buildExportParams({\n                columns: range.columns,\n                rowPositions: rowPositions,\n                includeHeaders: params.includeHeaders,\n                includeGroupHeaders: params.includeGroupHeaders,\n            }));\n        });\n\n        return { data: data.join('\\n'), cellsToFlash: allCellsToFlash };\n    }\n\n    private getRangeRowPositionsAndCellsToFlash(range: CellRange): { rowPositions: RowPosition[], cellsToFlash: CellsToFlashType } {\n        const rowPositions: RowPosition[] = [];\n        const cellsToFlash: CellsToFlashType = {};\n        const startRow = this.rangeService.getRangeStartRow(range);\n        const lastRow = this.rangeService.getRangeEndRow(range);\n\n        let node: RowPosition | null = startRow;\n\n        while (node) {\n            rowPositions.push(node);\n            range.columns.forEach(column => {\n                const { rowIndex, rowPinned } = node!;\n                const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned });\n                cellsToFlash[cellId] = true;\n            });\n            if (this.rowPositionUtils.sameRow(node, lastRow)) { break; }\n            node = this.cellNavigationService.getRowBelow(node);\n        }\n\n        return { rowPositions, cellsToFlash }\n    }\n\n    private getCellsToFlashFromRowNodes(rowNodes: RowNode[]): CellsToFlashType {\n        const allDisplayedColumns = this.columnModel.getAllDisplayedColumns();\n        const cellsToFlash: CellsToFlashType = {};\n        for (let i = 0; i < rowNodes.length; i++) {\n            const { rowIndex, rowPinned } = rowNodes[i];\n            if (rowIndex == null) { continue; }\n            for (let j = 0; j < allDisplayedColumns.length; j++) {\n                const column = allDisplayedColumns[j];\n                const cellId = this.cellPositionUtils.createIdFromValues({ rowIndex, column, rowPinned })\n                cellsToFlash[cellId] = true;\n            }\n        }\n\n        return cellsToFlash;\n    }\n\n    private copyFocusedCellToClipboard(params: IClipboardCopyParams = {}): void {\n        const focusedCell = this.focusService.getFocusedCell();\n\n        if (focusedCell == null) { return; }\n\n        const cellId = this.cellPositionUtils.createId(focusedCell);\n        const currentRow: RowPosition = { rowPinned: focusedCell.rowPinned, rowIndex: focusedCell.rowIndex };\n        const column = focusedCell.column;\n\n        const data = this.buildExportParams({\n            columns: [column],\n            rowPositions: [currentRow],\n            includeHeaders: params.includeHeaders,\n            includeGroupHeaders: params.includeGroupHeaders\n        });\n\n        this.copyDataToClipboard(data);\n        this.dispatchFlashCells({ [cellId]: true });\n    }\n\n    public copySelectedRowsToClipboard(params: IClipboardCopyRowsParams = {}): void {\n        const { columnKeys, includeHeaders, includeGroupHeaders } = params;\n\n        const data = this.buildExportParams({\n            columns: columnKeys,\n            includeHeaders,\n            includeGroupHeaders\n        });\n\n        this.copyDataToClipboard(data);\n        const rowNodes = this.selectionService.getSelectedNodes() || [];\n        this.dispatchFlashCells(this.getCellsToFlashFromRowNodes(rowNodes));\n    }\n\n    private buildExportParams(params: {\n        columns?: (string | Column)[],\n        rowPositions?: RowPosition[]\n        includeHeaders?: boolean,\n        includeGroupHeaders?: boolean\n    }): string {\n        const { columns, rowPositions, includeHeaders = false, includeGroupHeaders = false } = params;\n\n        const exportParams: CsvExportParams = {\n            columnKeys: columns,\n            rowPositions,\n            skipColumnHeaders: !includeHeaders,\n            skipColumnGroupHeaders: !includeGroupHeaders,\n            suppressQuotes: true,\n            columnSeparator: this.getClipboardDelimiter(),\n            onlySelected: !rowPositions,\n            processCellCallback: this.gridOptionsService.getCallback('processCellForClipboard'),\n            processRowGroupCallback: (params) => this.processRowGroupCallback(params),\n            processHeaderCallback: this.gridOptionsService.getCallback('processHeaderForClipboard'),\n            processGroupHeaderCallback: this.gridOptionsService.getCallback('processGroupHeaderForClipboard')\n            \n        };\n\n        return this.csvCreator.getDataAsCsv(exportParams, true);\n    }\n\n    private processRowGroupCallback(params: ProcessRowGroupForExportParams) {\n        const { node, column } = params;\n\n        const isTreeData = this.gridOptionsService.get('treeData');\n        const isSuppressGroupMaintainValueType = this.gridOptionsService.get('suppressGroupMaintainValueType');\n\n        // if not tree data and not suppressGroupMaintainValueType then we get the value from the group data\n        const getValueFromNode = () => {\n            if (isTreeData || isSuppressGroupMaintainValueType || !column) {\n                return node.key;\n            }\n            const value = node.groupData?.[column.getId()];\n            if (!value || !node.rowGroupColumn || node.rowGroupColumn.getColDef().useValueFormatterForExport === false) { return value; }\n            return this.valueFormatterService.formatValue(node.rowGroupColumn, node, value) ?? value;\n        }\n        let value = getValueFromNode();\n\n        if (params.node.footer) {\n            let suffix = '';\n            if (value && value.length) {\n                suffix = ` ${value}`;\n            }\n            value = `Total${suffix}`;\n        }\n        const processCellForClipboard = this.gridOptionsService.getCallback('processCellForClipboard');\n\n        if (processCellForClipboard) {\n            let column = node.rowGroupColumn as Column;\n\n            if (!column && node.footer && node.level === -1) {\n                column = this.columnModel.getRowGroupColumns()[0];\n            }\n            return processCellForClipboard({\n                value,\n                node,\n                column,\n                type: 'clipboard',\n                formatValue: (valueToFormat: any) => this.valueFormatterService.formatValue(column, node, valueToFormat) ?? valueToFormat,\n                parseValue: (valueToParse: string) => this.valueParserService.parseValue(column, node, valueToParse, this.valueService.getValue(column, node))\n            });\n        }\n        return value;\n    }\n\n    private dispatchFlashCells(cellsToFlash: {}): void {\n        window.setTimeout(() => {\n            const event: WithoutGridCommon<FlashCellsEvent> = {\n                type: Events.EVENT_FLASH_CELLS,\n                cells: cellsToFlash\n            };\n\n            this.eventService.dispatchEvent(event);\n        }, 0);\n    }\n\n    private processCell<T>(\n        rowNode: RowNode | undefined,\n        column: Column,\n        value: T,\n        type: string,\n        func?: ((params: WithoutGridCommon<ProcessCellForExportParams>) => T),\n        canParse?: boolean,\n        canFormat?: boolean): T {\n        if (func) {\n            const params: WithoutGridCommon<ProcessCellForExportParams> = {\n                column,\n                node: rowNode,\n                value,\n                type,\n                formatValue: (valueToFormat: any) => this.valueFormatterService.formatValue(column, rowNode ?? null, valueToFormat) ?? valueToFormat,\n                parseValue: (valueToParse: string) => this.valueParserService.parseValue(column, rowNode ?? null, valueToParse, this.valueService.getValue(column, rowNode))\n\n            };\n\n            return func(params);\n        }\n        if (canParse && column.getColDef().useValueParserForImport !== false) {\n            return this.valueParserService.parseValue(column, rowNode ?? null, value, this.valueService.getValue(column, rowNode));\n        } else if (canFormat && column.getColDef().useValueFormatterForExport !== false) {\n            return this.valueFormatterService.formatValue(column, rowNode ?? null, value) ?? value as any;\n        }\n\n        return value;\n    }\n\n    private copyDataToClipboard(data: string): void {\n        const userProvidedFunc = this.gridOptionsService.getCallback('sendToClipboard');\n\n        // method 1 - user provided func\n        if (userProvidedFunc) {\n            userProvidedFunc({ data });\n            return;\n        }\n\n        // method 2 - native clipboard API, available in modern chrome browsers\n        const allowNavigator = !this.gridOptionsService.get('suppressClipboardApi');\n        if (allowNavigator && navigator.clipboard) {\n            navigator.clipboard.writeText(data).catch((e) => {\n                _.doOnce(() => {\n                    console.warn(e);\n                    console.warn(apiError('writeText'));\n                }, 'clipboardApiError');\n                this.copyDataToClipboardLegacy(data);\n            });\n            return;\n        }\n\n        this.copyDataToClipboardLegacy(data);\n    }\n\n    private copyDataToClipboardLegacy(data: string): void {\n        // method 3 - if all else fails, the old school hack\n        this.executeOnTempElement(element => {\n            const eDocument = this.gridOptionsService.getDocument();\n            const focusedElementBefore = eDocument.activeElement as HTMLElement;\n\n            element.value = data || ' '; // has to be non-empty value or execCommand will not do anything\n            element.select();\n            element.focus({ preventScroll: true });\n\n            const result = eDocument.execCommand('copy');\n\n            if (!result) {\n                console.warn('AG Grid: Browser did not allow document.execCommand(\\'copy\\'). Ensure ' +\n                    'api.copySelectedRowsToClipboard() is invoked via a user event, i.e. button click, otherwise ' +\n                    'the browser will prevent it for security reasons.');\n            }\n\n            if (focusedElementBefore != null && focusedElementBefore.focus != null) {\n                focusedElementBefore.focus({ preventScroll: true });\n            }\n        });\n    }\n\n    private executeOnTempElement(\n        callbackNow: (element: HTMLTextAreaElement) => void,\n        callbackAfter?: (element: HTMLTextAreaElement) => void\n    ): void {\n        const eDoc = this.gridOptionsService.getDocument();\n        const eTempInput = eDoc.createElement('textarea');\n        eTempInput.style.width = '1px';\n        eTempInput.style.height = '1px';\n\n        // removing items from the DOM causes the document element to scroll to the\n        // position where the element was positioned. Here we set scrollTop / scrollLeft\n        // to prevent the document element from scrolling when we remove it from the DOM.\n        eTempInput.style.top = eDoc.documentElement.scrollTop + 'px';\n        eTempInput.style.left = eDoc.documentElement.scrollLeft + 'px';\n\n        eTempInput.style.position = 'absolute';\n        eTempInput.style.opacity = '0';\n\n        const guiRoot = this.gridCtrl.getGui();\n\n        guiRoot.appendChild(eTempInput);\n\n        try {\n            callbackNow(eTempInput);\n        } catch (err) {\n            console.warn('AG Grid: Browser does not support document.execCommand(\\'copy\\') for clipboard operations');\n        }\n\n        //It needs 100 otherwise OS X seemed to not always be able to paste... Go figure...\n        if (callbackAfter) {\n            window.setTimeout(() => {\n                callbackAfter(eTempInput);\n                guiRoot.removeChild(eTempInput);\n            }, 100);\n        } else {\n            guiRoot.removeChild(eTempInput);\n        }\n    }\n\n    private getRangeSize(): number {\n        const ranges = this.rangeService.getCellRanges();\n        let startRangeIndex = 0;\n        let endRangeIndex = 0;\n\n        if (ranges.length > 0) {\n            startRangeIndex = this.rangeService.getRangeStartRow(ranges[0]).rowIndex;\n            endRangeIndex = this.rangeService.getRangeEndRow(ranges[0]).rowIndex;\n        }\n\n        return startRangeIndex - endRangeIndex + 1;\n    }\n}\n", "// DO NOT UPDATE MANUALLY: Generated from script during build time\nexport const VERSION = '31.2.0';"],
  "mappings": "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",
  "names": ["import_core", "params", "value", "column", "_a"]
}
