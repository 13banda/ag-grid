{
  "version": 3,
  "sources": ["../../src/rowGroupingModule.ts", "../../src/rowGrouping/aggregationStage.ts", "../../src/rowGrouping/groupStage.ts", "../../src/rowGrouping/batchRemover.ts", "../../src/rowGrouping/pivotColDefService.ts", "../../src/rowGrouping/pivotStage.ts", "../../src/rowGrouping/aggFuncService.ts", "../../src/rowGrouping/columnDropZones/gridHeaderDropZones.ts", "../../src/rowGrouping/columnDropZones/rowGroupDropZonePanel.ts", "../../src/rowGrouping/columnDropZones/baseDropZonePanel.ts", "../../src/rowGrouping/columnDropZones/dropZoneColumnComp.ts", "../../src/rowGrouping/columnDropZones/pivotDropZonePanel.ts", "../../src/rowGrouping/filterAggregatesStage.ts", "../../src/version.ts", "../../src/rowGrouping/groupFilter/groupFilter.ts", "../../src/rowGrouping/groupFilter/groupFloatingFilter.ts", "../../src/rowGrouping/columnDropZones/valueDropZonePanel.ts"],
  "sourcesContent": ["import { Module, ModuleNames } from \"@ag-grid-community/core\";\nimport { EnterpriseCoreModule } from \"@ag-grid-enterprise/core\";\nimport { AggregationStage } from \"./rowGrouping/aggregationStage\";\nimport { GroupStage } from \"./rowGrouping/groupStage\";\nimport { PivotColDefService } from \"./rowGrouping/pivotColDefService\";\nimport { PivotStage } from \"./rowGrouping/pivotStage\";\nimport { AggFuncService } from \"./rowGrouping/aggFuncService\";\nimport { GridHeaderDropZones } from \"./rowGrouping/columnDropZones/gridHeaderDropZones\";\nimport { FilterAggregatesStage } from \"./rowGrouping/filterAggregatesStage\";\nimport { VERSION } from \"./version\";\nimport { GroupFilter } from \"./rowGrouping/groupFilter/groupFilter\";\nimport { GroupFloatingFilterComp } from \"./rowGrouping/groupFilter/groupFloatingFilter\";\n\nexport const RowGroupingModule: Module = {\n    version: VERSION,\n    moduleName: ModuleNames.RowGroupingModule,\n    beans: [AggregationStage, FilterAggregatesStage, GroupStage, PivotColDefService, PivotStage, AggFuncService],\n    agStackComponents: [\n        { componentName: 'AgGridHeaderDropZones', componentClass: GridHeaderDropZones }\n    ],\n    userComponents: [\n        { componentName: 'agGroupColumnFilter', componentClass: GroupFilter },\n        { componentName: 'agGroupColumnFloatingFilter', componentClass: GroupFloatingFilterComp },\n    ],\n    dependantModules: [\n        EnterpriseCoreModule\n    ]\n};\n", "import {\n    Bean,\n    BeanStub,\n    IRowNodeStage,\n    Autowired,\n    ColumnModel,\n    ValueService,\n    RowNode,\n    Column,\n    StageExecuteParams,\n    IAggFunc,\n    ChangedPath,\n    IAggFuncParams,\n    _,\n    GetGroupRowAggParams,\n    WithoutGridCommon,\n    GridOptions,\n} from \"@ag-grid-community/core\";\nimport { AggFuncService } from \"./aggFuncService\";\n\ninterface AggregationDetails {\n    alwaysAggregateAtRootLevel: boolean;\n    groupIncludeTotalFooter: boolean;\n    changedPath: ChangedPath;\n    valueColumns: Column[];\n    pivotColumns: Column[];\n    filteredOnly: boolean;\n    userAggFunc: ((params: WithoutGridCommon<GetGroupRowAggParams<any, any>>) => any) | undefined;\n}\n\n@Bean('aggregationStage')\nexport class AggregationStage extends BeanStub implements IRowNodeStage {\n\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('valueService') private valueService: ValueService;\n    @Autowired('aggFuncService') private aggFuncService: AggFuncService;\n\n    // it's possible to recompute the aggregate without doing the other parts\n    // + api.refreshClientSideRowModel('aggregate')\n    public execute(params: StageExecuteParams): any {\n        // if changed path is active, it means we came from a) change detection or b) transaction update.\n        // for both of these, if no value columns are present, it means there is nothing to aggregate now\n        // and there is no cleanup to be done (as value columns don't change between transactions or change\n        // detections). if no value columns and no changed path, means we have to go through all nodes in\n        // case we need to clean up agg data from before.\n        const noValueColumns = _.missingOrEmpty(this.columnModel.getValueColumns());\n        const noUserAgg = !this.gridOptionsService.getCallback('getGroupRowAgg');\n        const changedPathActive = params.changedPath && params.changedPath.isActive();\n        if (noValueColumns && noUserAgg && changedPathActive) { return; }\n\n        const aggDetails = this.createAggDetails(params);\n\n        this.recursivelyCreateAggData(aggDetails);\n    }\n\n    private createAggDetails(params: StageExecuteParams): AggregationDetails {\n\n        const pivotActive = this.columnModel.isPivotActive();\n\n        const measureColumns = this.columnModel.getValueColumns();\n        const pivotColumns = pivotActive ? this.columnModel.getPivotColumns() : [];\n\n        const aggDetails: AggregationDetails = {\n            alwaysAggregateAtRootLevel: this.gridOptionsService.get('alwaysAggregateAtRootLevel'),\n            groupIncludeTotalFooter: this.gridOptionsService.get('groupIncludeTotalFooter'),\n            changedPath: params.changedPath!,\n            valueColumns: measureColumns,\n            pivotColumns: pivotColumns,\n            filteredOnly:  !this.isSuppressAggFilteredOnly(),\n            userAggFunc: this.gridOptionsService.getCallback('getGroupRowAgg') as any,\n        };\n\n        return aggDetails;\n    }\n\n    private isSuppressAggFilteredOnly() {\n        const isGroupAggFiltering = this.gridOptionsService.getGroupAggFiltering() !== undefined;\n        return isGroupAggFiltering || this.gridOptionsService.get('suppressAggFilteredOnly');\n    }\n\n    private recursivelyCreateAggData(aggDetails: AggregationDetails) {\n\n        const callback = (rowNode: RowNode) => {\n\n            const hasNoChildren = !rowNode.hasChildren();\n            if (hasNoChildren) {\n                // this check is needed for TreeData, in case the node is no longer a child,\n                // but it was a child previously.\n                if (rowNode.aggData) {\n                    rowNode.setAggData(null);\n                }\n                // never agg data for leaf nodes\n                return;\n            }\n\n            //Optionally enable the aggregation at the root Node\n            const isRootNode = rowNode.level === -1;\n            // if total footer is displayed, the value is in use\n            if (isRootNode && !aggDetails.groupIncludeTotalFooter) {\n                const notPivoting = !this.columnModel.isPivotMode();\n                if (!aggDetails.alwaysAggregateAtRootLevel && notPivoting) {\n                    rowNode.setAggData(null);\n                    return;\n                }\n            }\n\n            this.aggregateRowNode(rowNode, aggDetails);\n        };\n\n        aggDetails.changedPath.forEachChangedNodeDepthFirst(callback, true);\n    }\n\n    private aggregateRowNode(rowNode: RowNode, aggDetails: AggregationDetails): void {\n\n        const measureColumnsMissing = aggDetails.valueColumns.length === 0;\n        const pivotColumnsMissing = aggDetails.pivotColumns.length === 0;\n\n        let aggResult: any;\n        if (aggDetails.userAggFunc) {\n            aggResult = aggDetails.userAggFunc({ nodes: rowNode.childrenAfterFilter! });\n        } else if (measureColumnsMissing) {\n            aggResult = null;\n        } else if (pivotColumnsMissing) {\n            aggResult = this.aggregateRowNodeUsingValuesOnly(rowNode, aggDetails);\n        } else {\n            aggResult = this.aggregateRowNodeUsingValuesAndPivot(rowNode);\n        }\n\n        rowNode.setAggData(aggResult);\n\n        // if we are grouping, then it's possible there is a sibling footer\n        // to the group, so update the data here also if there is one\n        if (rowNode.sibling) {\n            rowNode.sibling.setAggData(aggResult);\n        }\n    }\n\n    private aggregateRowNodeUsingValuesAndPivot(rowNode: RowNode): any {\n        const result: any = {};\n\n        const secondaryColumns = this.columnModel.getSecondaryColumns() ?? [];\n        let canSkipTotalColumns = true;\n        for (let i = 0; i < secondaryColumns.length; i++) {\n            const secondaryCol = secondaryColumns[i];\n            const colDef = secondaryCol.getColDef();\n\n            if (colDef.pivotTotalColumnIds != null) {\n                canSkipTotalColumns = false;\n                continue;\n            }\n\n            const keys: string[] = colDef.pivotKeys ?? [];\n            let values: any[];\n\n            if (rowNode.leafGroup) {\n                // lowest level group, get the values from the mapped set\n                values = this.getValuesFromMappedSet(rowNode.childrenMapped, keys, colDef.pivotValueColumn!);\n            } else {\n                // value columns and pivot columns, non-leaf group\n                values = this.getValuesPivotNonLeaf(rowNode, colDef.colId!);\n            }\n\n            // bit of a memory drain storing null/undefined, but seems to speed up performance.\n            result[colDef.colId!] = this.aggregateValues(values, colDef.pivotValueColumn!.getAggFunc()!, colDef.pivotValueColumn!, rowNode, secondaryCol);\n        }\n\n        if (!canSkipTotalColumns) {\n            for (let i = 0; i < secondaryColumns.length; i++) {\n                const secondaryCol = secondaryColumns[i];\n                const colDef = secondaryCol.getColDef();\n    \n                if (colDef.pivotTotalColumnIds == null || !colDef.pivotTotalColumnIds.length) {\n                    continue;\n                }\n    \n                const aggResults: any[] = colDef.pivotTotalColumnIds.map((currentColId: string) => result[currentColId]);\n                // bit of a memory drain storing null/undefined, but seems to speed up performance.\n                result[colDef.colId!] = this.aggregateValues(aggResults, colDef.pivotValueColumn!.getAggFunc()!, colDef.pivotValueColumn!, rowNode, secondaryCol);\n            }\n        }\n\n        return result;\n    }\n\n    private aggregateRowNodeUsingValuesOnly(rowNode: RowNode, aggDetails: AggregationDetails): any {\n        const result: any = {};\n\n        const changedValueColumns = aggDetails.changedPath.isActive() ?\n            aggDetails.changedPath.getValueColumnsForNode(rowNode, aggDetails.valueColumns)\n            : aggDetails.valueColumns;\n\n        const notChangedValueColumns = aggDetails.changedPath.isActive() ?\n            aggDetails.changedPath.getNotValueColumnsForNode(rowNode, aggDetails.valueColumns)\n            : null;\n\n        const values2d = this.getValuesNormal(rowNode, changedValueColumns, aggDetails.filteredOnly);\n        const oldValues = rowNode.aggData;\n\n        changedValueColumns.forEach((valueColumn: Column, index: number) => {\n            result[valueColumn.getId()] = this.aggregateValues(values2d[index], valueColumn.getAggFunc()!, valueColumn, rowNode);\n        });\n\n        if (notChangedValueColumns && oldValues) {\n            notChangedValueColumns.forEach((valueColumn: Column) => {\n                result[valueColumn.getId()] = oldValues[valueColumn.getId()];\n            });\n        }\n\n        return result;\n    }\n\n    private getValuesPivotNonLeaf(rowNode: RowNode, colId: string): any[] {\n        return rowNode.childrenAfterFilter!.map((childNode: RowNode) => childNode.aggData[colId]);\n    }\n\n    private getValuesFromMappedSet(mappedSet: any, keys: string[], valueColumn: Column): any[] {\n        let mapPointer = mappedSet;\n        for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            mapPointer = mapPointer ? mapPointer[key] : null;\n        }\n\n        if (!mapPointer) {\n            return [];\n        }\n\n        return mapPointer.map((rowNode: RowNode) => this.valueService.getValue(valueColumn, rowNode));\n    }\n\n    private getValuesNormal(rowNode: RowNode, valueColumns: Column[], filteredOnly: boolean): any[][] {\n        // create 2d array, of all values for all valueColumns\n        const values: any[][] = [];\n        valueColumns.forEach(() => values.push([]));\n\n        const valueColumnCount = valueColumns.length;\n\n        const nodeList = filteredOnly ? rowNode.childrenAfterFilter : rowNode.childrenAfterGroup;\n        const rowCount = nodeList!.length;\n\n        for (let i = 0; i < rowCount; i++) {\n            const childNode = nodeList![i];\n            for (let j = 0; j < valueColumnCount; j++) {\n                const valueColumn = valueColumns[j];\n                // if the row is a group, then it will only have an agg result value,\n                // which means valueGetter is never used.\n                const value = this.valueService.getValue(valueColumn, childNode);\n                values[j].push(value);\n            }\n        }\n\n        return values;\n    }\n\n    public aggregateValues(values: any[], aggFuncOrString: string | IAggFunc, column?: Column, rowNode?: RowNode, pivotResultColumn?: Column): any {\n        const aggFunc = typeof aggFuncOrString === 'string' ?\n            this.aggFuncService.getAggFunc(aggFuncOrString) :\n            aggFuncOrString;\n\n        if (typeof aggFunc !== 'function') {\n            console.error(`AG Grid: unrecognised aggregation function ${aggFuncOrString}`);\n            return null;\n        }\n\n        const aggFuncAny = aggFunc;\n        const params: IAggFuncParams = this.gridOptionsService.addGridCommonParams({\n            values: values,\n            column: column,\n            colDef: column ? column.getColDef() : undefined,\n            pivotResultColumn: pivotResultColumn,\n            rowNode: rowNode,\n            data: rowNode ? rowNode.data : undefined\n        } as any); // the \"as any\" is needed to allow the deprecation warning messages\n\n        return aggFuncAny(params);\n    }\n}\n", "import {\n    _,\n    Autowired,\n    Bean,\n    BeanStub,\n    ChangedPath,\n    Column,\n    ColumnModel,\n    GetDataPath,\n    IRowNodeStage,\n    IsGroupOpenByDefaultParams,\n    RowNode,\n    RowNodeTransaction,\n    SelectableService,\n    StageExecuteParams,\n    ValueService,\n    Beans,\n    ISelectionService,\n    WithoutGridCommon,\n    InitialGroupOrderComparatorParams,\n    GridOptions,\n    KeyCreatorParams\n} from \"@ag-grid-community/core\";\nimport { BatchRemover } from \"./batchRemover\";\n\ninterface GroupInfo {\n    key: string; // e.g. 'Ireland'\n    field: string | null; // e.g. 'country'\n    rowGroupColumn: Column | null;\n    leafNode?: RowNode;\n}\n\ninterface GroupingDetails {\n    pivotMode: boolean;\n    includeParents: boolean;\n    expandByDefault: number;\n    changedPath: ChangedPath;\n    rootNode: RowNode;\n    groupedCols: Column[];\n    groupedColCount: number;\n    transactions: RowNodeTransaction[];\n    rowNodeOrder: { [id: string]: number; };\n    \n    groupAllowUnbalanced: boolean;\n    isGroupOpenByDefault: (params: WithoutGridCommon<IsGroupOpenByDefaultParams>) => boolean;\n    initialGroupOrderComparator: (params: WithoutGridCommon<InitialGroupOrderComparatorParams>) => number;\n    \n    usingTreeData: boolean;\n    suppressGroupMaintainValueType: boolean;\n    getDataPath: GetDataPath | undefined;\n    keyCreators: (((params: KeyCreatorParams) => string) | undefined)[];\n}\n\n@Bean('groupStage')\nexport class GroupStage extends BeanStub implements IRowNodeStage {\n\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('selectableService') private selectableService: SelectableService;\n    @Autowired('valueService') private valueService: ValueService;\n    @Autowired('beans') private beans: Beans;\n    @Autowired('selectionService') private selectionService: ISelectionService;\n\n    // when grouping, these items are of note:\n    // rowNode.parent: RowNode: set to the parent\n    // rowNode.childrenAfterGroup: RowNode[] = the direct children of this group\n    // rowNode.childrenMapped: string=>RowNode = children mapped by group key (when groups) or an empty map if leaf group (this is then used by pivot)\n    // for leaf groups, rowNode.childrenAfterGroup = rowNode.allLeafChildren;\n\n    private oldGroupingDetails: GroupingDetails;\n    private oldGroupDisplayColIds: string;\n\n    public execute(params: StageExecuteParams): void {\n\n        const details = this.createGroupingDetails(params);\n\n        if (details.transactions) {\n            this.handleTransaction(details);\n        } else {\n            const afterColsChanged = params.afterColumnsChanged === true;\n            this.shotgunResetEverything(details, afterColsChanged);\n        }\n\n        if (!details.usingTreeData) {\n            // we don't do group sorting for tree data\n            this.positionLeafsAndGroups(params.changedPath!);\n            this.orderGroups(details);\n        }\n\n        this.selectableService.updateSelectableAfterGrouping();\n    }\n\n    private positionLeafsAndGroups(changedPath: ChangedPath) {\n        changedPath.forEachChangedNodeDepthFirst(group => {\n            if (group.childrenAfterGroup) {\n                const leafNodes: RowNode[] = [];\n                const groupNodes: RowNode[] = [];\n                let unbalancedNode: RowNode | undefined;\n\n                group.childrenAfterGroup.forEach(row => {\n                    if (!row.childrenAfterGroup?.length) {\n                        leafNodes.push(row);\n                    } else {\n                        if (row.key === '' && !unbalancedNode) {\n                            unbalancedNode = row;\n                        } else {\n                            groupNodes.push(row);\n                        }\n                    }\n                });\n\n                if (unbalancedNode) {\n                    groupNodes.push(unbalancedNode);\n                }\n                \n                group.childrenAfterGroup = [...leafNodes, ...groupNodes];\n            }\n        }, false);\n    }\n\n    private createGroupingDetails(params: StageExecuteParams): GroupingDetails {\n        const { rowNode, changedPath, rowNodeTransactions, rowNodeOrder } = params;\n\n        const usingTreeData = this.gridOptionsService.get('treeData');\n\n        const groupedCols = usingTreeData ? null : this.columnModel.getRowGroupColumns();\n\n        const details: GroupingDetails = {\n            // someone complained that the parent attribute was causing some change detection\n            // to break in an angular add-on.  Taking the parent out breaks a cyclic dependency, hence this flag got introduced.\n            includeParents: !this.gridOptionsService.get('suppressParentsInRowNodes'),\n            expandByDefault: this.gridOptionsService.get('groupDefaultExpanded'),\n            groupedCols: groupedCols!,\n            rootNode: rowNode,\n            pivotMode: this.columnModel.isPivotMode(),\n            groupedColCount: usingTreeData || !groupedCols ? 0 : groupedCols.length,\n            rowNodeOrder: rowNodeOrder!,\n            transactions: rowNodeTransactions!,\n            // if no transaction, then it's shotgun, changed path would be 'not active' at this point anyway\n            changedPath: changedPath!,\n            groupAllowUnbalanced:  this.gridOptionsService.get('groupAllowUnbalanced'),\n            isGroupOpenByDefault: this.gridOptionsService.getCallback('isGroupOpenByDefault') as any,\n            initialGroupOrderComparator: this.gridOptionsService.getCallback('initialGroupOrderComparator') as any,\n            usingTreeData: usingTreeData,\n            suppressGroupMaintainValueType: this.gridOptionsService.get('suppressGroupMaintainValueType'),\n            getDataPath: usingTreeData ? this.gridOptionsService.get('getDataPath') : undefined,\n            keyCreators: groupedCols?.map(column => column.getColDef().keyCreator) ?? []\n        };\n\n        return details;\n    }\n\n    private handleTransaction(details: GroupingDetails): void {\n\n        details.transactions.forEach(tran => {\n            // we don't allow batch remover for tree data as tree data uses Filler Nodes,\n            // and creating/deleting filler nodes needs to be done alongside the node deleting\n            // and moving. if we want to Batch Remover working with tree data then would need\n            // to consider how Filler Nodes would be impacted (it's possible that it can be easily\n            // modified to work, however for now I don't have the brain energy to work it all out).\n            const batchRemover = !details.usingTreeData ? new BatchRemover() : undefined;\n\n            // the order here of [add, remove, update] needs to be the same as in ClientSideNodeManager,\n            // as the order is important when a record with the same id is added and removed in the same\n            // transaction.\n            if (_.existsAndNotEmpty(tran.remove)) {\n                this.removeNodes(tran.remove as RowNode[], details, batchRemover);\n            }\n            if (_.existsAndNotEmpty(tran.update)) {\n                this.moveNodesInWrongPath(tran.update as RowNode[], details, batchRemover);\n            }\n            if (_.existsAndNotEmpty(tran.add)) {\n                this.insertNodes(tran.add as RowNode[], details, false);\n            }\n            // must flush here, and not allow another transaction to be applied,\n            // as each transaction must finish leaving the data in a consistent state.\n            if (batchRemover) {\n                const parentsWithChildrenRemoved = batchRemover.getAllParents().slice();\n                batchRemover.flush();\n                this.removeEmptyGroups(parentsWithChildrenRemoved, details);\n            }\n        });\n\n        if (details.rowNodeOrder) {\n            this.sortChildren(details);\n        }\n    }\n\n    // this is used when doing delta updates, eg Redux, keeps nodes in right order\n    private sortChildren(details: GroupingDetails): void {\n        details.changedPath.forEachChangedNodeDepthFirst(node => {\n            if (!node.childrenAfterGroup) {\n                return;\n            }\n\n            const didSort = _.sortRowNodesByOrder(node.childrenAfterGroup!, details.rowNodeOrder);\n            if (didSort) {\n                details.changedPath.addParentNode(node);\n            }\n        }, false, true);\n    }\n\n    private orderGroups(details: GroupingDetails): void {\n        const comparator = details.initialGroupOrderComparator;\n        if (_.exists(comparator)) { recursiveSort(details.rootNode); }\n\n        function recursiveSort(rowNode: RowNode): void {\n            const doSort = _.exists(rowNode.childrenAfterGroup) &&\n                // we only want to sort groups, so we do not sort leafs (a leaf group has leafs as children)\n                !rowNode.leafGroup;\n\n            if (doSort) {\n                rowNode.childrenAfterGroup!.sort((nodeA, nodeB) => comparator!({ nodeA, nodeB }));\n                rowNode.childrenAfterGroup!.forEach((childNode: RowNode) => recursiveSort(childNode));\n            }\n        }\n    }\n\n    private getExistingPathForNode(node: RowNode, details: GroupingDetails): GroupInfo[] {\n        const res: GroupInfo[] = [];\n\n        // when doing tree data, the node is part of the path,\n        // but when doing grid grouping, the node is not part of the path so we start with the parent.\n        let pointer = details.usingTreeData ? node : node.parent;\n        while (pointer && pointer !== details.rootNode) {\n            res.push({\n                key: pointer.key!,\n                rowGroupColumn: pointer.rowGroupColumn,\n                field: pointer.field\n            });\n            pointer = pointer.parent;\n        }\n        res.reverse();\n        return res;\n    }\n\n    private moveNodesInWrongPath(childNodes: RowNode[], details: GroupingDetails, batchRemover: BatchRemover | undefined): void {\n        childNodes.forEach(childNode => {\n\n            // we add node, even if parent has not changed, as the data could have\n            // changed, hence aggregations will be wrong\n            if (details.changedPath.isActive()) {\n                details.changedPath.addParentNode(childNode.parent);\n            }\n\n            const infoToKeyMapper = (item: GroupInfo) => item.key;\n            const oldPath: string[] = this.getExistingPathForNode(childNode, details).map(infoToKeyMapper);\n            const newPath: string[] = this.getGroupInfo(childNode, details).map(infoToKeyMapper);\n\n            const nodeInCorrectPath = _.areEqual(oldPath, newPath);\n\n            if (!nodeInCorrectPath) {\n                this.moveNode(childNode, details, batchRemover);\n            }\n        });\n    }\n\n    private moveNode(childNode: RowNode, details: GroupingDetails, batchRemover: BatchRemover | undefined): void {\n\n        this.removeNodesInStages([childNode], details, batchRemover);\n        this.insertOneNode(childNode, details, true, batchRemover);\n\n        // hack - if we didn't do this, then renaming a tree item (ie changing rowNode.key) wouldn't get\n        // refreshed into the gui.\n        // this is needed to kick off the event that rowComp listens to for refresh. this in turn\n        // then will get each cell in the row to refresh - which is what we need as we don't know which\n        // columns will be displaying the rowNode.key info.\n        childNode.setData(childNode.data);\n\n        // we add both old and new parents to changed path, as both will need to be refreshed.\n        // we already added the old parent (in calling method), so just add the new parent here\n        if (details.changedPath.isActive()) {\n            const newParent = childNode.parent;\n            details.changedPath.addParentNode(newParent);\n        }\n    }\n\n    private removeNodes(leafRowNodes: RowNode[], details: GroupingDetails, batchRemover: BatchRemover | undefined): void {\n        this.removeNodesInStages(leafRowNodes, details, batchRemover);\n        if (details.changedPath.isActive()) {\n            leafRowNodes.forEach(rowNode => details.changedPath.addParentNode(rowNode.parent));\n        }\n    }\n\n    private removeNodesInStages(leafRowNodes: RowNode[], details: GroupingDetails, batchRemover: BatchRemover | undefined): void {\n        this.removeNodesFromParents(leafRowNodes, details, batchRemover);\n        if (details.usingTreeData) {\n            this.postRemoveCreateFillerNodes(leafRowNodes, details);\n\n            // When not TreeData, then removeEmptyGroups is called just before the BatchRemover is flushed.\n            // However for TreeData, there is no BatchRemover, so we have to call removeEmptyGroups here.\n            const nodeParents = leafRowNodes.map(n => n.parent!);\n            this.removeEmptyGroups(nodeParents, details);\n        }\n    }\n\n    private forEachParentGroup(details: GroupingDetails, group: RowNode, callback: (parent: RowNode) => void): void {\n        let pointer: RowNode | null = group;\n        while (pointer && pointer !== details.rootNode) {\n            callback(pointer);\n            pointer = pointer.parent;\n        }\n    }\n\n    private removeNodesFromParents(nodesToRemove: RowNode[], details: GroupingDetails, provided: BatchRemover | undefined): void {\n        // this method can be called with BatchRemover as optional. if it is missed, we created a local version\n        // and flush it at the end. if one is provided, we add to the provided one and it gets flushed elsewhere.\n        const batchRemoverIsLocal = provided == null;\n        const batchRemoverToUse = provided ? provided : new BatchRemover();\n\n        nodesToRemove.forEach(nodeToRemove => {\n            this.removeFromParent(nodeToRemove, batchRemoverToUse);\n\n            // remove from allLeafChildren. we clear down all parents EXCEPT the Root Node, as\n            // the ClientSideNodeManager is responsible for the Root Node.\n            this.forEachParentGroup(details, nodeToRemove.parent!, parentNode => {\n                batchRemoverToUse.removeFromAllLeafChildren(parentNode, nodeToRemove);\n            });\n        });\n\n        if (batchRemoverIsLocal) {\n            batchRemoverToUse.flush();\n        }\n    }\n\n    private postRemoveCreateFillerNodes(nodesToRemove: RowNode[], details: GroupingDetails): void {\n        nodesToRemove.forEach(nodeToRemove => {\n\n            // if not group, and children are present, need to move children to a group.\n            // otherwise if no children, we can just remove without replacing.\n            const replaceWithGroup = nodeToRemove.hasChildren();\n            if (replaceWithGroup) {\n                const oldPath = this.getExistingPathForNode(nodeToRemove, details);\n                // because we just removed the userGroup, this will always return new support group\n                const newGroupNode = this.findParentForNode(nodeToRemove, oldPath, details);\n\n                // these properties are the ones that will be incorrect in the newly created group,\n                // so copy them from the old childNode\n                newGroupNode.expanded = nodeToRemove.expanded;\n                newGroupNode.allLeafChildren = nodeToRemove.allLeafChildren;\n                newGroupNode.childrenAfterGroup = nodeToRemove.childrenAfterGroup;\n                newGroupNode.childrenMapped = nodeToRemove.childrenMapped;\n                newGroupNode.updateHasChildren();\n\n                newGroupNode.childrenAfterGroup!.forEach(rowNode => rowNode.parent = newGroupNode);\n            }\n\n        });\n    }\n\n    private removeEmptyGroups(possibleEmptyGroups: RowNode[], details: GroupingDetails): void {\n        // we do this multiple times, as when we remove groups, that means the parent of just removed\n        // group can then be empty. to get around this, if we remove, then we check everything again for\n        // newly emptied groups. the max number of times this will execute is the depth of the group tree.\n        let checkAgain = true;\n\n        const groupShouldBeRemoved = (rowNode: RowNode): boolean => {\n\n            // because of the while loop below, it's possible we already moved the node,\n            // so double check before trying to remove again.\n            const mapKey = this.getChildrenMappedKey(rowNode.key!, rowNode.rowGroupColumn);\n            const parentRowNode = rowNode.parent;\n            const groupAlreadyRemoved = (parentRowNode && parentRowNode.childrenMapped) ?\n                !parentRowNode.childrenMapped[mapKey] : true;\n\n            if (groupAlreadyRemoved) {\n                // if not linked, then group was already removed\n                return false;\n            }\n            // if still not removed, then we remove if this group is empty\n            return !!rowNode.isEmptyRowGroupNode();\n        };\n\n        while (checkAgain) {\n            checkAgain = false;\n            const batchRemover: BatchRemover = new BatchRemover();\n            possibleEmptyGroups.forEach(possibleEmptyGroup => {\n                // remove empty groups\n                this.forEachParentGroup(details, possibleEmptyGroup, rowNode => {\n                    if (groupShouldBeRemoved(rowNode)) {\n                        checkAgain = true;\n                        this.removeFromParent(rowNode, batchRemover);\n                        // we remove selection on filler nodes here, as the selection would not be removed\n                        // from the RowNodeManager, as filler nodes don't exist on the RowNodeManager\n                        rowNode.setSelectedParams({ newValue: false, source: 'rowGroupChanged' });\n                    }\n                });\n            });\n            batchRemover.flush();\n        }\n    }\n\n    // removes the node from the parent by:\n    // a) removing from childrenAfterGroup (using batchRemover if present, otherwise immediately)\n    // b) removing from childrenMapped (immediately)\n    // c) setRowTop(null) - as the rowRenderer uses this to know the RowNode is no longer needed\n    // d) setRowIndex(null) - as the rowNode will no longer be displayed.\n    private removeFromParent(child: RowNode, batchRemover?: BatchRemover) {\n        if (child.parent) {\n            if (batchRemover) {\n                batchRemover.removeFromChildrenAfterGroup(child.parent, child);\n            } else {\n                _.removeFromArray(child.parent.childrenAfterGroup!, child);\n                child.parent.updateHasChildren();\n            }\n        }\n        const mapKey = this.getChildrenMappedKey(child.key!, child.rowGroupColumn);\n        if (child.parent && child.parent.childrenMapped) {\n            child.parent.childrenMapped[mapKey] = undefined;\n        }\n        // this is important for transition, see rowComp removeFirstPassFuncs. when doing animation and\n        // remove, if rowTop is still present, the rowComp thinks it's just moved position.\n        child.setRowTop(null);\n        child.setRowIndex(null);\n    }\n\n    private addToParent(child: RowNode, parent: RowNode | null) {\n        const mapKey = this.getChildrenMappedKey(child.key!, child.rowGroupColumn);\n        if (parent) {\n            const children = parent.childrenMapped != null;\n            if (children) {\n                parent.childrenMapped![mapKey] = child;\n            }\n            parent.childrenAfterGroup!.push(child);\n            parent.updateHasChildren();\n        }\n    }\n\n    private areGroupColsEqual(d1: GroupingDetails, d2: GroupingDetails): boolean {\n        if (d1 == null || d2 == null || d1.pivotMode !== d2.pivotMode) { return false; }\n\n        return _.areEqual(d1.groupedCols, d2.groupedCols) && _.areEqual(d1.keyCreators, d2.keyCreators);\n    }\n\n    private checkAllGroupDataAfterColsChanged(details: GroupingDetails): void {\n\n        const recurse = (rowNodes: RowNode[] | null) => {\n            if (!rowNodes) { return; }\n            rowNodes.forEach(rowNode => {\n                const isLeafNode = !details.usingTreeData && !rowNode.group;\n                if (isLeafNode) { return; }\n                const groupInfo: GroupInfo = {\n                    field: rowNode.field,\n                    key: rowNode.key!,\n                    rowGroupColumn: rowNode.rowGroupColumn,\n                    leafNode: rowNode.allLeafChildren[0],\n                };\n                this.setGroupData(rowNode, groupInfo, details);\n                recurse(rowNode.childrenAfterGroup);\n            });\n        };\n\n        recurse(details.rootNode.childrenAfterGroup);\n    }\n\n    private shotgunResetEverything(details: GroupingDetails, afterColumnsChanged: boolean): void {\n\n        if (this.noChangeInGroupingColumns(details, afterColumnsChanged)) {\n            return;\n        }\n\n        // groups are about to get disposed, so need to deselect any that are selected\n        this.selectionService.filterFromSelection((node: RowNode) => node && !node.group);\n\n        const { rootNode, groupedCols } = details;\n        // because we are not creating the root node each time, we have the logic\n        // here to change leafGroup once.\n        // we set .leafGroup to false for tree data, as .leafGroup is only used when pivoting, and pivoting\n        // isn't allowed with treeData, so the grid never actually use .leafGroup when doing treeData.\n        rootNode.leafGroup = details.usingTreeData ? false : groupedCols.length === 0;\n\n        // we are doing everything from scratch, so reset childrenAfterGroup and childrenMapped from the rootNode\n        rootNode.childrenAfterGroup = [];\n        rootNode.childrenMapped = {};\n        rootNode.updateHasChildren();\n\n        const sibling = rootNode.sibling;\n        if (sibling) {\n            sibling.childrenAfterGroup = rootNode.childrenAfterGroup;\n            sibling.childrenMapped = rootNode.childrenMapped;\n        }\n\n        this.insertNodes(rootNode.allLeafChildren, details, false);\n    }\n\n    private noChangeInGroupingColumns(details: GroupingDetails, afterColumnsChanged: boolean): boolean {\n        let noFurtherProcessingNeeded = false;\n\n        const groupDisplayColumns = this.columnModel.getGroupDisplayColumns();\n        const newGroupDisplayColIds = groupDisplayColumns ?\n            groupDisplayColumns.map(c => c.getId()).join('-') : '';\n\n        if (afterColumnsChanged) {\n            // we only need to redo grouping if doing normal grouping (ie not tree data)\n            // and the group cols have changed.\n            noFurtherProcessingNeeded = details.usingTreeData || this.areGroupColsEqual(details, this.oldGroupingDetails);\n\n            // if the group display cols have changed, then we need to update rowNode.groupData\n            // (regardless of tree data or row grouping)\n            if (this.oldGroupDisplayColIds !== newGroupDisplayColIds) {\n                this.checkAllGroupDataAfterColsChanged(details);\n            }\n        }\n\n        this.oldGroupingDetails = details;\n        this.oldGroupDisplayColIds = newGroupDisplayColIds;\n\n        return noFurtherProcessingNeeded;\n    }\n\n    private insertNodes(newRowNodes: RowNode[], details: GroupingDetails, isMove: boolean): void {\n        newRowNodes.forEach(rowNode => {\n            this.insertOneNode(rowNode, details, isMove);\n            if (details.changedPath.isActive()) {\n                details.changedPath.addParentNode(rowNode.parent);\n            }\n        });\n    }\n\n    private insertOneNode(childNode: RowNode, details: GroupingDetails, isMove: boolean, batchRemover?: BatchRemover): void {\n\n        const path: GroupInfo[] = this.getGroupInfo(childNode, details);\n\n        const parentGroup = this.findParentForNode(childNode, path, details, batchRemover);\n        if (!parentGroup.group) {\n            console.warn(`AG Grid: duplicate group keys for row data, keys should be unique`,\n                [parentGroup.data, childNode.data]);\n        }\n\n        if (details.usingTreeData) {\n            this.swapGroupWithUserNode(parentGroup, childNode, isMove);\n        } else {\n            childNode.parent = parentGroup;\n            childNode.level = path.length;\n            parentGroup.childrenAfterGroup!.push(childNode);\n            parentGroup.updateHasChildren();\n        }\n    }\n\n    private findParentForNode(childNode: RowNode, path: GroupInfo[], details: GroupingDetails, batchRemover?: BatchRemover): RowNode {\n        let nextNode: RowNode = details.rootNode;\n\n        path.forEach((groupInfo, level) => {\n            nextNode = this.getOrCreateNextNode(nextNode, groupInfo, level, details);\n            // node gets added to all group nodes.\n            // note: we do not add to rootNode here, as the rootNode is the master list of rowNodes\n\n            if (!batchRemover?.isRemoveFromAllLeafChildren(nextNode, childNode)) {\n                nextNode.allLeafChildren.push(childNode);\n            } else {\n                // if this node is about to be removed, prevent that\n                batchRemover?.preventRemoveFromAllLeafChildren(nextNode, childNode);\n            }\n        });\n\n        return nextNode;\n    }\n\n    private swapGroupWithUserNode(fillerGroup: RowNode, userGroup: RowNode, isMove: boolean) {\n        userGroup.parent = fillerGroup.parent;\n        userGroup.key = fillerGroup.key;\n        userGroup.field = fillerGroup.field;\n        userGroup.groupData = fillerGroup.groupData;\n        userGroup.level = fillerGroup.level;\n        // AG-3441 - preserve the existing expanded status of the node if we're moving it, so that\n        // you can drag a sub tree from one parent to another without changing its expansion\n        if (!isMove) {\n            userGroup.expanded = fillerGroup.expanded;\n        }\n\n        // we set .leafGroup to false for tree data, as .leafGroup is only used when pivoting, and pivoting\n        // isn't allowed with treeData, so the grid never actually use .leafGroup when doing treeData.\n        userGroup.leafGroup = fillerGroup.leafGroup;\n\n        // always null for userGroups, as row grouping is not allowed when doing tree data\n        userGroup.rowGroupIndex = fillerGroup.rowGroupIndex;\n\n        userGroup.allLeafChildren = fillerGroup.allLeafChildren;\n        userGroup.childrenAfterGroup = fillerGroup.childrenAfterGroup;\n        userGroup.childrenMapped = fillerGroup.childrenMapped;\n        userGroup.sibling = fillerGroup.sibling;\n        userGroup.updateHasChildren();\n\n        this.removeFromParent(fillerGroup);\n        userGroup.childrenAfterGroup!.forEach((rowNode: RowNode) => rowNode.parent = userGroup);\n        this.addToParent(userGroup, fillerGroup.parent);\n    }\n\n    private getOrCreateNextNode(parentGroup: RowNode, groupInfo: GroupInfo, level: number,\n        details: GroupingDetails): RowNode {\n\n        const key = this.getChildrenMappedKey(groupInfo.key, groupInfo.rowGroupColumn);\n        let nextNode = parentGroup.childrenMapped ? parentGroup.childrenMapped[key] : undefined;\n\n        if (!nextNode) {\n            nextNode = this.createGroup(groupInfo, parentGroup, level, details);\n            // attach the new group to the parent\n            this.addToParent(nextNode, parentGroup);\n        }\n\n        return nextNode;\n    }\n\n    private createGroup(groupInfo: GroupInfo, parent: RowNode, level: number, details: GroupingDetails): RowNode {\n        const groupNode = new RowNode(this.beans);\n\n        groupNode.group = true;\n        groupNode.field = groupInfo.field;\n        groupNode.rowGroupColumn = groupInfo.rowGroupColumn;\n\n        this.setGroupData(groupNode, groupInfo, details);\n\n        groupNode.key = groupInfo.key;\n        groupNode.id = this.createGroupId(groupNode, parent, details.usingTreeData, level);\n\n        groupNode.level = level;\n        groupNode.leafGroup = details.usingTreeData ? false : level === (details.groupedColCount - 1);\n\n        groupNode.allLeafChildren = [];\n\n        // why is this done here? we are not updating the children count as we go,\n        // i suspect this is updated in the filter stage\n        groupNode.setAllChildrenCount(0);\n\n        groupNode.rowGroupIndex = details.usingTreeData ? null : level;\n\n        groupNode.childrenAfterGroup = [];\n        groupNode.childrenMapped = {};\n        groupNode.updateHasChildren();\n\n        groupNode.parent = details.includeParents ? parent : null;\n\n        this.setExpandedInitialValue(details, groupNode);\n\n        return groupNode;\n    }\n\n    private createGroupId(node: RowNode, parent: RowNode, usingTreeData: boolean, level: number): string {\n        let createGroupId: (node: RowNode, parent: RowNode | null, level: number) => string | null;\n        if (usingTreeData) {\n            createGroupId = (node, parent, level) => {\n                if (level < 0) { return null; } // root node\n                const parentId = parent ? createGroupId(parent, parent.parent, level - 1) : null;\n                return `${parentId == null ? '' : parentId + '-'}${level}-${node.key}`;\n            };\n        } else {\n            createGroupId = (node, parent) => {\n                if (!node.rowGroupColumn) { return null; } // root node\n                const parentId = parent ? createGroupId(parent, parent.parent, 0) : null;\n                return `${parentId == null ? '' : parentId + '-'}${node.rowGroupColumn.getColId()}-${node.key}`;\n            };\n        }\n\n        // we put 'row-group-' before the group id, so it doesn't clash with standard row id's. we also use 't-' and 'b-'\n        // for top pinned and bottom pinned rows.\n        return RowNode.ID_PREFIX_ROW_GROUP + createGroupId(node, parent, level);\n    }\n\n    private setGroupData(groupNode: RowNode, groupInfo: GroupInfo, details: GroupingDetails): void {\n        groupNode.groupData = {};\n        const groupDisplayCols: Column[] = this.columnModel.getGroupDisplayColumns();\n        groupDisplayCols.forEach(col => {\n            // newGroup.rowGroupColumn=null when working off GroupInfo, and we always display the group in the group column\n            // if rowGroupColumn is present, then it's grid row grouping and we only include if configuration says so\n            const isTreeData = details.usingTreeData;\n            if (isTreeData) {\n                groupNode.groupData![col.getColId()] = groupInfo.key;\n                return;\n            }\n\n            const groupColumn = groupNode.rowGroupColumn;\n            const isRowGroupDisplayed = groupColumn !== null && col.isRowGroupDisplayed(groupColumn.getId());\n            if (isRowGroupDisplayed) {\n                if (details.suppressGroupMaintainValueType) {\n                    groupNode.groupData![col.getColId()] = groupInfo.key;\n                } else {\n                    // if maintain group value type, get the value from any leaf node.\n                    groupNode.groupData![col.getColId()] = this.valueService.getValue(groupColumn, groupInfo.leafNode);\n                }\n            }\n        });\n    }\n\n    private getChildrenMappedKey(key: string, rowGroupColumn: Column | null): string {\n        if (rowGroupColumn) {\n            // grouping by columns\n            return rowGroupColumn.getId() + '-' + key;\n        }\n        // tree data - we don't have rowGroupColumns\n        return key;\n    }\n\n    private setExpandedInitialValue(details: GroupingDetails, groupNode: RowNode): void {\n        // if pivoting the leaf group is never expanded as we do not show leaf rows\n        if (details.pivotMode && groupNode.leafGroup) {\n            groupNode.expanded = false;\n            return;\n        }\n\n        // use callback if exists\n        const userCallback = details.isGroupOpenByDefault;\n        if (userCallback) {\n            const params: WithoutGridCommon<IsGroupOpenByDefaultParams> = {\n                rowNode: groupNode,\n                field: groupNode.field!,\n                key: groupNode.key!,\n                level: groupNode.level,\n                rowGroupColumn: groupNode.rowGroupColumn!\n            };\n            groupNode.expanded = userCallback(params) == true;\n            return;\n        }\n\n        // use expandByDefault if exists\n        const { expandByDefault } = details;\n        if (details.expandByDefault === -1) {\n            groupNode.expanded = true;\n            return;\n        }\n\n        // otherwise\n        groupNode.expanded = groupNode.level < expandByDefault;\n    }\n\n    private getGroupInfo(rowNode: RowNode, details: GroupingDetails): GroupInfo[] {\n        if (details.usingTreeData) {\n            return this.getGroupInfoFromCallback(rowNode, details);\n        }\n        return this.getGroupInfoFromGroupColumns(rowNode, details);\n    }\n\n    private getGroupInfoFromCallback(rowNode: RowNode, details: GroupingDetails): GroupInfo[] {        \n        const keys: string[] | null = details.getDataPath ? details.getDataPath(rowNode.data) : null;\n\n        if (keys === null || keys === undefined || keys.length === 0) {\n            _.warnOnce(`getDataPath() should not return an empty path for data ${rowNode.data}`);\n        }\n        const groupInfoMapper = (key: string | null) => ({ key, field: null, rowGroupColumn: null }) as GroupInfo;\n        return keys ? keys.map(groupInfoMapper) : [];\n    }\n\n    private getGroupInfoFromGroupColumns(rowNode: RowNode, details: GroupingDetails) {\n        const res: GroupInfo[] = [];\n        details.groupedCols.forEach(groupCol => {\n            let key: string = this.valueService.getKeyForNode(groupCol, rowNode);\n            let keyExists = key !== null && key !== undefined && key !== '';\n\n            // unbalanced tree and pivot mode don't work together - not because of the grid, it doesn't make\n            // mathematical sense as you are building up a cube. so if pivot mode, we put in a blank key where missing.\n            // this keeps the tree balanced and hence can be represented as a group.\n            const createGroupForEmpty = details.pivotMode || !details.groupAllowUnbalanced;\n            if (createGroupForEmpty && !keyExists) {\n                key = '';\n                keyExists = true;\n            }\n\n            if (keyExists) {\n                const item = {\n                    key: key,\n                    field: groupCol.getColDef().field,\n                    rowGroupColumn: groupCol,\n                    leafNode: rowNode,\n                } as GroupInfo;\n                res.push(item);\n            }\n        });\n        return res;\n    }\n}", "import { RowNode } from \"@ag-grid-community/core\";\n\n// doing _.removeFromArray() multiple times on a large list can be a bottleneck.\n// when doing large deletes (eg removing 1,000 rows) then we would be calling _.removeFromArray()\n// a thousands of times, in particular RootNode.allGroupChildren could be a large list, and\n// 1,000 removes is time consuming as each one requires traversing the full list.\n// to get around this, we do all the removes in a batch. this class manages the batch.\n//\n// This problem was brought to light by a client (AG-2879), with dataset of 20,000\n// in 10,000 groups (2 items per group), then deleting all rows with transaction,\n// it took about 20 seconds to delete. with the BathRemoved, the reduced to less than 1 second.\n\ninterface RemoveDetails {\n    removeFromChildrenAfterGroup: { [id: string]: boolean; };\n    removeFromAllLeafChildren: { [id: string]: boolean; };\n}\n\nexport class BatchRemover {\n\n    private allSets: { [parentId: string]: RemoveDetails; } = {};\n    private allParents: RowNode[] = [];\n\n    public removeFromChildrenAfterGroup(parent: RowNode, child: RowNode): void {\n        const set = this.getSet(parent);\n        set.removeFromChildrenAfterGroup[child.id!] = true;\n    }\n\n    public isRemoveFromAllLeafChildren(parent: RowNode, child: RowNode): boolean {\n        const set = this.getSet(parent);\n        return !!set.removeFromAllLeafChildren[child.id!];\n    }\n\n    public preventRemoveFromAllLeafChildren(parent: RowNode, child: RowNode): void {\n        const set = this.getSet(parent);\n        delete set.removeFromAllLeafChildren[child.id!];\n    }\n    \n    public removeFromAllLeafChildren(parent: RowNode, child: RowNode): void {\n        const set = this.getSet(parent);\n        set.removeFromAllLeafChildren[child.id!] = true;\n    }\n\n    private getSet(parent: RowNode): RemoveDetails {\n        if (!this.allSets[parent.id!]) {\n            this.allSets[parent.id!] = {\n                removeFromAllLeafChildren: {},\n                removeFromChildrenAfterGroup: {}\n            };\n            this.allParents.push(parent);\n        }\n        return this.allSets[parent.id!];\n    }\n\n    public getAllParents(): RowNode[] {\n        return this.allParents;\n    }\n\n    public flush(): void {\n        this.allParents.forEach(parent => {\n            const nodeDetails = this.allSets[parent.id!];\n\n            parent.childrenAfterGroup = parent.childrenAfterGroup!.filter(\n                child => !nodeDetails.removeFromChildrenAfterGroup[child.id!]\n            );\n            parent.allLeafChildren = parent.allLeafChildren.filter(\n                child => !nodeDetails.removeFromAllLeafChildren[child.id!]\n            );\n            parent.updateHasChildren();\n\n            if (parent.sibling) {\n                parent.sibling.childrenAfterGroup = parent.childrenAfterGroup;\n                parent.sibling.allLeafChildren = parent.allLeafChildren;\n            }\n        });\n        this.allSets = {};\n        this.allParents.length = 0;\n    }\n}\n", "import {\n    Autowired,\n    Bean,\n    BeanStub,\n    ColDef,\n    ColGroupDef,\n    Column,\n    ColumnModel,\n    GridOptionsService,\n    IPivotColDefService,\n    PostConstruct,\n    _\n} from \"@ag-grid-community/core\";\n\nexport interface PivotColDefServiceResult {\n    pivotColumnGroupDefs: (ColDef | ColGroupDef)[];\n    pivotColumnDefs: ColDef[];\n}\n\n@Bean('pivotColDefService')\nexport class PivotColDefService extends BeanStub implements IPivotColDefService {\n\n    public static PIVOT_ROW_TOTAL_PREFIX = 'PivotRowTotal_';\n\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('gridOptionsService') private gos: GridOptionsService;\n\n    private fieldSeparator: string;\n    private pivotDefaultExpanded: number;\n\n    @PostConstruct\n    public init(): void {\n        const getFieldSeparator = () => this.gos.get('serverSidePivotResultFieldSeparator') ?? '_';\n        this.fieldSeparator = getFieldSeparator();\n        this.addManagedPropertyListener('serverSidePivotResultFieldSeparator', () => {this.fieldSeparator = getFieldSeparator();});\n\n        const getPivotDefaultExpanded = () => this.gos.get('pivotDefaultExpanded');\n        this.pivotDefaultExpanded = getPivotDefaultExpanded();\n        this.addManagedPropertyListener('pivotDefaultExpanded', () => {this.pivotDefaultExpanded = getPivotDefaultExpanded();});\n    }\n\n    public createPivotColumnDefs(uniqueValues: any): PivotColDefServiceResult {\n        // this is passed to the columnModel, to configure the columns and groups we show\n\n        const pivotColumnGroupDefs: (ColDef | ColGroupDef)[] = this.createPivotColumnsFromUniqueValues(uniqueValues);\n\n        function extractColDefs(input: (ColDef | ColGroupDef)[], arr: ColDef[] = []): ColDef[] {\n            input.forEach((def: any) => {\n                if (def.children !== undefined) {\n                    extractColDefs(def.children, arr);\n                } else {\n                    arr.push(def);\n                }\n            });\n            return arr;\n        }\n        const pivotColumnDefs = extractColDefs(pivotColumnGroupDefs);\n\n        // additional columns that contain the aggregated total for each value column per row\n        this.addRowGroupTotals(pivotColumnGroupDefs, pivotColumnDefs);\n\n        // additional group columns that contain child totals for each collapsed child column / group\n        this.addExpandablePivotGroups(pivotColumnGroupDefs, pivotColumnDefs);\n\n        // additional group columns that contain an aggregated total across all child columns\n        this.addPivotTotalsToGroups(pivotColumnGroupDefs, pivotColumnDefs);\n\n        // we clone, so the colDefs in pivotColumnsGroupDefs and pivotColumnDefs are not shared. this is so that\n        // any changes the user makes (via processSecondaryColumnDefinitions) don't impact the internal aggregations,\n        // as these use the col defs also\n        const pivotColumnDefsClone: ColDef[] = pivotColumnDefs.map(colDef => _.cloneObject(colDef));\n\n        return {\n            pivotColumnGroupDefs: pivotColumnGroupDefs,\n            pivotColumnDefs: pivotColumnDefsClone\n        };\n    }\n\n    private createPivotColumnsFromUniqueValues(uniqueValues: any): (ColDef | ColGroupDef)[] {\n        const pivotColumns = this.columnModel.getPivotColumns();\n        const maxDepth = pivotColumns.length;\n\n        const pivotColumnGroupDefs: (ColDef | ColGroupDef)[] = this.recursivelyBuildGroup(0, uniqueValues, [], maxDepth, pivotColumns);\n        return pivotColumnGroupDefs;\n    }\n\n    private recursivelyBuildGroup(\n        index: number,\n        uniqueValue: any,\n        pivotKeys: string[],\n        maxDepth: number,\n        primaryPivotColumns: Column[]\n    ): ColGroupDef[] | ColDef[]  {\n        const measureColumns = this.columnModel.getValueColumns();\n        if (index >= maxDepth) { // Base case - build the measure columns\n            return this.buildMeasureCols(pivotKeys);\n        }\n\n        // sort by either user provided comparator, or our own one\n        const primaryPivotColumnDefs = primaryPivotColumns[index].getColDef();\n        const comparator = this.headerNameComparator.bind(this, primaryPivotColumnDefs.pivotComparator);\n\n        // Base case for the compact layout, instead of recursing build the last layer of groups as measure columns instead\n        if (measureColumns.length === 1 && this.gridOptionsService.get('removePivotHeaderRowWhenSingleValueColumn') && index === maxDepth - 1) {\n            const leafCols: ColDef[] = [];\n\n            _.iterateObject(uniqueValue, (key) => {\n                const newPivotKeys = [...pivotKeys, key];\n                const colDef = this.createColDef(measureColumns[0], key, newPivotKeys);\n                colDef.columnGroupShow = 'open';\n                leafCols.push(colDef);\n            });\n            leafCols.sort(comparator);\n            return leafCols;\n        }\n        // Recursive case\n        const groups: ColGroupDef[] = [];\n        _.iterateObject(uniqueValue, (key, value) => {\n            // expand group by default based on depth of group. (pivotDefaultExpanded provides desired level of depth for expanding group by default)\n            const openByDefault = this.pivotDefaultExpanded === -1 || (index < this.pivotDefaultExpanded);\n\n            const newPivotKeys = [...pivotKeys, key];\n            groups.push({\n                children: this.recursivelyBuildGroup(index + 1, value, newPivotKeys, maxDepth, primaryPivotColumns),\n                headerName: key,\n                pivotKeys: newPivotKeys,\n                columnGroupShow: 'open',\n                openByDefault: openByDefault,\n                groupId: this.generateColumnGroupId(newPivotKeys),\n            });\n        });\n        groups.sort(comparator);\n        return groups;\n    }\n\n    private buildMeasureCols(\n        pivotKeys: string[],\n    ): ColDef[] {\n        const measureColumns = this.columnModel.getValueColumns();\n        if (measureColumns.length === 0) {\n            // if no value columns selected, then we insert one blank column, so the user at least sees columns\n            // rendered. otherwise the grid would render with no columns (just empty groups) which would give the\n            // impression that the grid is broken\n            return [this.createColDef(null, '-', pivotKeys)];\n        }\n        return measureColumns.map((measureCol) => {\n            const columnName = this.columnModel.getDisplayNameForColumn(measureCol, 'header');\n            return {\n                ...this.createColDef(measureCol, columnName, pivotKeys),\n                columnGroupShow: 'open'\n            };\n        });\n    };\n\n    private addExpandablePivotGroups(\n        pivotColumnGroupDefs: (ColDef | ColGroupDef)[],\n        pivotColumnDefs: ColDef[],\n    ) {\n        if (\n            this.gridOptionsService.get('suppressExpandablePivotGroups') ||\n            this.gridOptionsService.get('pivotColumnGroupTotals')\n        ) {\n            return;\n        }\n\n        const recursivelyAddSubTotals = (\n            groupDef: (ColGroupDef | ColDef),\n            currentPivotColumnDefs: ColDef[],\n            acc: Map<string, string[]>\n        ) => {\n            const group = groupDef as ColGroupDef;\n\n            if (group.children) {\n                const childAcc = new Map();\n\n                group.children.forEach((grp: ColDef | ColGroupDef) => {\n                    recursivelyAddSubTotals(grp, currentPivotColumnDefs, childAcc);\n                });\n\n                const firstGroup = !group.children.some(child => (child as ColGroupDef).children);\n\n                this.columnModel.getValueColumns().forEach(valueColumn => {\n                    const columnName: string | null = this.columnModel.getDisplayNameForColumn(valueColumn, 'header');\n                    const totalColDef = this.createColDef(valueColumn, columnName, groupDef.pivotKeys);\n                    totalColDef.pivotTotalColumnIds = childAcc.get(valueColumn.getColId());\n\n                    totalColDef.columnGroupShow = 'closed';\n\n                    totalColDef.aggFunc = valueColumn.getAggFunc();\n\n                    if (!firstGroup) {\n                        // add total colDef to group and pivot colDefs array\n                        const children = (groupDef as ColGroupDef).children;\n                        children.push(totalColDef);\n                        currentPivotColumnDefs.push(totalColDef);\n                    }\n                });\n\n                this.merge(acc, childAcc);\n\n            } else {\n                const def: ColDef = groupDef as ColDef;\n\n                // check that value column exists, i.e. aggFunc is supplied\n                if (!def.pivotValueColumn) { return; }\n\n                const pivotValueColId = def.pivotValueColumn.getColId();\n\n                const arr = acc.has(pivotValueColId) ? acc.get(pivotValueColId) : [];\n                arr!.push(def.colId!);\n                acc.set(pivotValueColId, arr!);\n            }\n        };\n\n        pivotColumnGroupDefs.forEach((groupDef: (ColGroupDef | ColDef)) => {\n            recursivelyAddSubTotals(groupDef, pivotColumnDefs, new Map());\n        });\n    }\n\n    private addPivotTotalsToGroups(pivotColumnGroupDefs: (ColDef | ColGroupDef)[], pivotColumnDefs: ColDef[]) {\n        if (!this.gridOptionsService.get('pivotColumnGroupTotals')) { return; }\n\n        const insertAfter = this.gridOptionsService.get('pivotColumnGroupTotals') === 'after';\n\n        const valueCols = this.columnModel.getValueColumns();\n        const aggFuncs = valueCols.map(valueCol => valueCol.getAggFunc());\n\n        // don't add pivot totals if there is less than 1 aggFunc or they are not all the same\n        if (!aggFuncs || aggFuncs.length < 1 || !this.sameAggFuncs(aggFuncs)) {\n            // console.warn('AG Grid: aborting adding pivot total columns - value columns require same aggFunc');\n            return;\n        }\n\n        // arbitrarily select a value column to use as a template for pivot columns\n        const valueColumn = valueCols[0];\n\n        pivotColumnGroupDefs.forEach((groupDef: (ColGroupDef | ColDef)) => {\n            this.recursivelyAddPivotTotal(groupDef, pivotColumnDefs, valueColumn, insertAfter);\n        });\n    }\n\n    private recursivelyAddPivotTotal(groupDef: (ColGroupDef | ColDef),\n                                     pivotColumnDefs: ColDef[],\n                                     valueColumn: Column,\n                                     insertAfter: boolean): string[] | null {\n        const group = groupDef as ColGroupDef;\n        if (!group.children) {\n            const def: ColDef = groupDef as ColDef;\n            return def.colId ? [def.colId] : null;\n        }\n\n        let colIds: string[] = [];\n\n        // need to recurse children first to obtain colIds used in the aggregation stage\n        group.children\n            .forEach((grp: ColDef | ColGroupDef) => {\n                const childColIds = this.recursivelyAddPivotTotal(grp, pivotColumnDefs, valueColumn, insertAfter);\n                if (childColIds) {\n                    colIds = colIds.concat(childColIds);\n                }\n            });\n\n        // only add total colDef if there is more than 1 child node\n        if (group.children.length > 1) {\n\n            const localeTextFunc = this.localeService.getLocaleTextFunc();\n            const headerName = localeTextFunc('pivotColumnGroupTotals', 'Total');\n\n            //create total colDef using an arbitrary value column as a template\n            const totalColDef = this.createColDef(valueColumn, headerName, groupDef.pivotKeys, true);\n            totalColDef.pivotTotalColumnIds = colIds;\n            totalColDef.aggFunc = valueColumn.getAggFunc();\n\n            // add total colDef to group and pivot colDefs array\n            const children = (groupDef as ColGroupDef).children;\n            insertAfter ? children.push(totalColDef) : children.unshift(totalColDef);\n            pivotColumnDefs.push(totalColDef);\n        }\n\n        return colIds;\n    }\n\n    private addRowGroupTotals(pivotColumnGroupDefs: (ColDef | ColGroupDef)[],\n                              pivotColumnDefs: ColDef[]) {\n        if (!this.gridOptionsService.get('pivotRowTotals')) { return; }\n\n        const insertAfter = this.gridOptionsService.get('pivotRowTotals') === 'after';\n\n        const valueColumns = this.columnModel.getValueColumns();\n        // order of row group totals depends on position\n        const valueCols = insertAfter ? valueColumns.slice() : valueColumns.slice().reverse();\n\n        for (let i = 0; i < valueCols.length; i++) {\n            const valueCol = valueCols[i];\n\n            let colIds: any[] = [];\n            pivotColumnGroupDefs.forEach((groupDef: (ColGroupDef | ColDef)) => {\n                colIds = colIds.concat(this.extractColIdsForValueColumn(groupDef, valueCol));\n            });\n\n            const withGroup = valueCols.length > 1 || !this.gridOptionsService.get('removePivotHeaderRowWhenSingleValueColumn');\n            this.createRowGroupTotal(pivotColumnGroupDefs, pivotColumnDefs, valueCol, colIds, insertAfter, withGroup);\n        }\n    }\n\n    private extractColIdsForValueColumn(groupDef: (ColGroupDef | ColDef), valueColumn: Column): string[] {\n        const group = groupDef as ColGroupDef;\n        if (!group.children) {\n            const colDef = (group as ColDef);\n            return colDef.pivotValueColumn === valueColumn && colDef.colId ? [colDef.colId] : [];\n        }\n\n        let colIds: string[] = [];\n        group.children\n            .forEach((grp: ColDef | ColGroupDef) => {\n                this.extractColIdsForValueColumn(grp, valueColumn);\n                const childColIds = this.extractColIdsForValueColumn(grp, valueColumn);\n                colIds = colIds.concat(childColIds);\n            });\n\n        return colIds;\n    }\n\n    private createRowGroupTotal(parentChildren: (ColGroupDef | ColDef)[],\n                                pivotColumnDefs: ColDef[],\n                                valueColumn: Column,\n                                colIds: string[],\n                                insertAfter: boolean,\n                                addGroup: boolean): void {\n\n        const measureColumns = this.columnModel.getValueColumns();\n\n        let colDef: ColDef;\n\n        if (measureColumns.length === 0) {\n            colDef = this.createColDef(null, '-', []);\n        } else {\n            const columnName: string | null = this.columnModel.getDisplayNameForColumn(valueColumn, 'header');\n            colDef = this.createColDef(valueColumn, columnName, []);\n            colDef.pivotTotalColumnIds = colIds;\n        }\n\n        colDef.colId = PivotColDefService.PIVOT_ROW_TOTAL_PREFIX + colDef.colId;\n        pivotColumnDefs.push(colDef);\n\n        const valueGroup: ColGroupDef | ColDef = addGroup ? {\n            children: [colDef],\n            pivotKeys: [],\n            groupId: `${PivotColDefService.PIVOT_ROW_TOTAL_PREFIX}_pivotGroup_${valueColumn.getColId()}`,\n        } : colDef;\n\n        insertAfter ? parentChildren.push(valueGroup) : parentChildren.unshift(valueGroup);\n    }\n\n    private createColDef(valueColumn: Column | null, headerName: any, pivotKeys: string[] | undefined, totalColumn: boolean = false): ColDef {\n\n        const colDef: ColDef = {};\n\n        // This is null when there are no measure columns and we're creating placeholder columns\n        if (valueColumn) {\n            const colDefToCopy = valueColumn.getColDef();\n            Object.assign(colDef, colDefToCopy);\n            // even if original column was hidden, we always show the pivot value column, otherwise it would be\n            // very confusing for people thinking the pivot is broken\n            colDef.hide = false;\n        }\n\n        colDef.headerName = headerName;\n        colDef.colId = this.generateColumnId(pivotKeys || [], valueColumn && !totalColumn ? valueColumn.getColId() : '');\n\n        // pivot columns repeat over field, so it makes sense to use the unique id instead. For example if you want to\n        // assign values to pinned bottom rows using setPinnedBottomRowData the value service will use this colId.\n        colDef.field = colDef.colId;\n        // this is to support using pinned rows, normally the data will be extracted from the aggData object using the colId\n        // however pinned rows still access the data object by field, this prevents values with dots from being treated as complex objects\n        colDef.valueGetter = (params) => params.data?.[params.colDef.field!];\n\n        colDef.pivotKeys = pivotKeys;\n        colDef.pivotValueColumn = valueColumn;\n        if (colDef.filter === true) {\n            colDef.filter = 'agNumberColumnFilter';\n        }\n\n        return colDef;\n    }\n\n    private sameAggFuncs(aggFuncs: any[]) {\n        if (aggFuncs.length == 1) { return true; }\n        //check if all aggFunc's match\n        for (let i = 1; i < aggFuncs.length; i++) {\n            if (aggFuncs[i] !== aggFuncs[0]) { return false; }\n        }\n        return true;\n    }\n\n    private headerNameComparator(userComparator: (a: string | undefined, b: string | undefined) => number, a: ColGroupDef | ColDef, b: ColGroupDef | ColDef): number {\n        if (userComparator) {\n            return userComparator(a.headerName, b.headerName);\n        } else {\n            if (a.headerName && !b.headerName) {\n                return 1;\n            } else if (!a.headerName && b.headerName) {\n                return -1;\n            }\n\n            // slightly naff here - just to satify typescript\n            // really should be &&, but if so ts complains\n            // the above if/else checks would deal with either being falsy, so at this stage if either are falsy, both are\n            // ..still naff though\n            if (!a.headerName || !b.headerName) {\n                return 0;\n            }\n\n            if (a.headerName < b.headerName) {\n                return -1;\n            }\n\n            if (a.headerName > b.headerName) {\n                return 1;\n            }\n\n            return 0;\n        }\n    }\n\n    private merge(m1: Map<string, string[]>, m2: Map<any, any>) {\n        m2.forEach((value, key, map) => {\n            const existingList = m1.has(key) ? m1.get(key) : [];\n            const updatedList = [...existingList!, ...value];\n            m1.set(key, updatedList);\n        });\n    }\n\n    private generateColumnGroupId(pivotKeys: string[]): string {\n        const pivotCols = this.columnModel.getPivotColumns().map((col) => col.getColId());\n        return `pivotGroup_${pivotCols.join('-')}_${pivotKeys.join('-')}`;\n    }\n\n    private generateColumnId(pivotKeys: string[], measureColumnId: string) {\n        const pivotCols = this.columnModel.getPivotColumns().map((col) => col.getColId());\n        return `pivot_${pivotCols.join('-')}_${pivotKeys.join('-')}_${measureColumnId}`;\n    }\n\n    /**\n     * Used by the SSRM to create secondary columns from provided fields\n     * @param fields \n     */\n    public createColDefsFromFields(fields: string[]): (ColDef | ColGroupDef)[] {\n        interface UniqueValue {\n            [key: string]: UniqueValue;\n        };\n        // tear the ids down into groups, while this could be done in-step with the next stage, the lookup is faster \n        // than searching col group children array for the right group\n        const uniqueValues: UniqueValue = {};\n        for (let i = 0; i < fields.length; i++) {\n            const field = fields[i];\n            const parts = field.split(this.fieldSeparator);\n\n            let level: UniqueValue = uniqueValues;\n            for (let p = 0; p < parts.length; p++) {\n                const part = parts[p];\n                if (level[part] == null) {\n                    level[part] = {};\n                }\n                level = level[part];\n            }\n        }\n\n        const uniqueValuesToGroups = (id: string, key: string, uniqueValues: UniqueValue, depth: number): ColDef | ColGroupDef => {\n            const children: (ColDef | ColGroupDef)[] = [];\n            for (let key in uniqueValues) {\n                const item = uniqueValues[key];\n                const child = uniqueValuesToGroups(`${id}${this.fieldSeparator}${key}`, key, item, depth + 1);\n                children.push(child);\n            }\n\n            if (children.length === 0) {\n                const potentialAggCol = this.columnModel.getPrimaryColumn(key);\n                if (potentialAggCol) {\n                    const headerName = this.columnModel.getDisplayNameForColumn(potentialAggCol, 'header') ?? key;\n                    const colDef = this.createColDef(potentialAggCol, headerName, undefined, false);\n                    colDef.colId = id;\n                    colDef.aggFunc = potentialAggCol.getAggFunc();\n                    colDef.valueGetter = (params) => params.data?.[id];\n                    return colDef;\n                }\n\n                const col: ColDef = {\n                    colId: id,\n                    headerName: key,\n                    // this is to support using pinned rows, normally the data will be extracted from the aggData object using the colId\n                    // however pinned rows still access the data object by field, this prevents values with dots from being treated as complex objects\n                    valueGetter: (params) => params.data?.[id],\n                };\n                return col;\n            }\n\n            // this is a bit sketchy. As the fields can be anything we just build groups as deep as the fields go.\n            // nothing says user has to give us groups the same depth.\n            const collapseSingleChildren = this.gridOptionsService.get('removePivotHeaderRowWhenSingleValueColumn');\n            if (collapseSingleChildren && children.length === 1 && 'colId' in children[0]) {\n                children[0].headerName = key;\n                return children[0];\n            }\n\n            const group: ColGroupDef = {\n                openByDefault: this.pivotDefaultExpanded === -1 || depth < this.pivotDefaultExpanded,\n                groupId: id,\n                headerName: key,\n                children,\n            };\n            return group;\n        }\n\n        const res: (ColDef | ColGroupDef)[] = [];\n        for (let key in uniqueValues) {\n            const item = uniqueValues[key];\n            const col = uniqueValuesToGroups(key, key, item, 0);\n            res.push(col);\n        }\n        return res;\n    }\n}\n", "import {\n    Autowired,\n    Bean,\n    BeanStub,\n    ChangedPath,\n    ColDef,\n    Column,\n    ColumnModel,\n    Events,\n    PivotMaxColumnsExceededEvent,\n    GridOptions,\n    IRowNodeStage,\n    RowNode,\n    StageExecuteParams,\n    ValueService,\n    WithoutGridCommon,\n    _\n} from \"@ag-grid-community/core\";\nimport { PivotColDefService } from \"./pivotColDefService\";\n\n@Bean('pivotStage')\nexport class PivotStage extends BeanStub implements IRowNodeStage {\n\n    // these should go into the pivot column creator\n    @Autowired('valueService') private valueService: ValueService;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('pivotColDefService') private pivotColDefService: PivotColDefService;\n\n    private uniqueValues: any = {};\n\n    private pivotColumnDefs: ColDef[];\n\n    private aggregationColumnsHashLastTime: string | null;\n    private aggregationFuncsHashLastTime: string;\n\n    private groupColumnsHashLastTime: string | null;\n\n    private pivotRowTotalsLastTime: GridOptions['pivotRowTotals'];\n    private pivotColumnGroupTotalsLastTime: GridOptions['pivotColumnGroupTotals'];\n    private suppressExpandablePivotGroupsLastTime: GridOptions['suppressExpandablePivotGroups'];\n    private removePivotHeaderRowWhenSingleValueColumnLastTime: GridOptions['removePivotHeaderRowWhenSingleValueColumn'];\n\n    private lastTimeFailed = false;\n\n    private maxUniqueValues: number = -1;\n    private static EXCEEDED_MAX_UNIQUE_VALUES = 'Exceeded maximum allowed pivot column count.';\n\n    public execute(params: StageExecuteParams): void {\n        const changedPath = params.changedPath;\n        if (this.columnModel.isPivotActive()) {\n            this.executePivotOn(changedPath!);\n        } else {\n            this.executePivotOff(changedPath!);\n        }\n    }\n\n    private executePivotOff(changedPath: ChangedPath): void {\n        this.aggregationColumnsHashLastTime = null;\n        this.uniqueValues = {};\n        if (this.columnModel.isSecondaryColumnsPresent()) {\n            this.columnModel.setSecondaryColumns(null, \"rowModelUpdated\");\n            if (changedPath) {\n                changedPath.setInactive();\n            }\n        }\n    }\n\n    private executePivotOn(changedPath: ChangedPath): void {\n        const numberOfAggregationColumns = this.columnModel.getValueColumns().length ?? 1;\n\n        // As unique values creates one column per aggregation column, divide max columns by number of aggregation columns\n        // to get the max number of unique values.\n        const configuredMaxCols = this.gridOptionsService.get('pivotMaxGeneratedColumns');\n        this.maxUniqueValues = configuredMaxCols === -1 ? -1 : configuredMaxCols / numberOfAggregationColumns;\n        let uniqueValues;\n        try {\n            // try catch is used to force execution to stop when the max count is exceeded.\n            uniqueValues = this.bucketUpRowNodes(changedPath);\n        } catch(e) {\n            // message is checked rather than inheritance as the build seems to break instanceof\n            if (e.message === PivotStage.EXCEEDED_MAX_UNIQUE_VALUES) {\n                this.columnModel.setSecondaryColumns([], \"rowModelUpdated\");\n                const event: WithoutGridCommon<PivotMaxColumnsExceededEvent> = {\n                    type: Events.EVENT_PIVOT_MAX_COLUMNS_EXCEEDED,\n                    message: e.message,\n                };\n                this.eventService.dispatchEvent(event);\n                this.lastTimeFailed = true;\n                return;\n            }\n            throw e;\n        }\n\n        const uniqueValuesChanged = this.setUniqueValues(uniqueValues);\n\n        const aggregationColumns = this.columnModel.getValueColumns();\n        const aggregationColumnsHash = aggregationColumns.map((column) => `${column.getId()}-${column.getColDef().headerName}`).join('#');\n        const aggregationFuncsHash = aggregationColumns.map((column) => column.getAggFunc()!.toString()).join('#');\n\n        const aggregationColumnsChanged = this.aggregationColumnsHashLastTime !== aggregationColumnsHash;\n        const aggregationFuncsChanged = this.aggregationFuncsHashLastTime !== aggregationFuncsHash;\n        this.aggregationColumnsHashLastTime = aggregationColumnsHash;\n        this.aggregationFuncsHashLastTime = aggregationFuncsHash;\n\n        const groupColumnsHash = this.columnModel.getRowGroupColumns().map((column) => column.getId()).join('#');\n        const groupColumnsChanged = groupColumnsHash !== this.groupColumnsHashLastTime;\n        this.groupColumnsHashLastTime = groupColumnsHash;\n\n        const pivotRowTotals = this.gridOptionsService.get('pivotRowTotals');\n        const pivotColumnGroupTotals = this.gridOptionsService.get('pivotColumnGroupTotals');\n        const suppressExpandablePivotGroups = this.gridOptionsService.get('suppressExpandablePivotGroups');\n        const removePivotHeaderRowWhenSingleValueColumn = this.gridOptionsService.get('removePivotHeaderRowWhenSingleValueColumn');\n\n        const anyGridOptionsChanged = (\n            pivotRowTotals !== this.pivotRowTotalsLastTime || pivotColumnGroupTotals !== this.pivotColumnGroupTotalsLastTime ||\n            suppressExpandablePivotGroups !== this.suppressExpandablePivotGroupsLastTime || removePivotHeaderRowWhenSingleValueColumn !== this.removePivotHeaderRowWhenSingleValueColumnLastTime\n        );\n\n        this.pivotRowTotalsLastTime = pivotRowTotals;\n        this.pivotColumnGroupTotalsLastTime = pivotColumnGroupTotals;\n        this.suppressExpandablePivotGroupsLastTime = suppressExpandablePivotGroups;\n        this.removePivotHeaderRowWhenSingleValueColumnLastTime = removePivotHeaderRowWhenSingleValueColumn;\n\n        if (this.lastTimeFailed || uniqueValuesChanged || aggregationColumnsChanged || groupColumnsChanged || aggregationFuncsChanged || anyGridOptionsChanged) {\n            const {pivotColumnGroupDefs, pivotColumnDefs} = this.pivotColDefService.createPivotColumnDefs(this.uniqueValues);\n            this.pivotColumnDefs = pivotColumnDefs;\n            this.columnModel.setSecondaryColumns(pivotColumnGroupDefs, \"rowModelUpdated\");\n            // because the secondary columns have changed, then the aggregation needs to visit the whole\n            // tree again, so we make the changedPath not active, to force aggregation to visit all paths.\n            if (changedPath) {\n                changedPath.setInactive();\n            }\n        }\n        this.lastTimeFailed = false;\n    }\n\n    private setUniqueValues(newValues: any): boolean {\n        const json1 = JSON.stringify(newValues);\n        const json2 = JSON.stringify(this.uniqueValues);\n\n        const uniqueValuesChanged = json1 !== json2;\n\n        // we only continue the below if the unique values are different, as otherwise\n        // the result will be the same as the last time we did it\n        if (uniqueValuesChanged) {\n            this.uniqueValues = newValues;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    private currentUniqueCount = 0;\n    private bucketUpRowNodes(changedPath: ChangedPath): any {\n        this.currentUniqueCount = 0;\n        // accessed from inside inner function\n        const uniqueValues: any = {};\n\n        // ensure childrenMapped is cleared, as if a node has been filtered out it should not have mapped children.\n        changedPath.forEachChangedNodeDepthFirst(node => {\n            if (node.leafGroup) {\n                node.childrenMapped = null;\n            }\n        });\n\n        const recursivelyBucketFilteredChildren = (node: RowNode) => {\n            if (node.leafGroup) {\n                this.bucketRowNode(node, uniqueValues);\n            } else {\n                node.childrenAfterFilter?.forEach(recursivelyBucketFilteredChildren);\n            }\n        }\n\n        changedPath.executeFromRootNode(recursivelyBucketFilteredChildren);\n\n        return uniqueValues;\n    }\n\n    private bucketRowNode(rowNode: RowNode, uniqueValues: any): void {\n\n        const pivotColumns = this.columnModel.getPivotColumns();\n\n        if (pivotColumns.length === 0) {\n            rowNode.childrenMapped = null;\n        } else {\n            rowNode.childrenMapped = this.bucketChildren(rowNode.childrenAfterFilter!, pivotColumns, 0, uniqueValues);\n        }\n\n        if (rowNode.sibling) {\n            rowNode.sibling.childrenMapped = rowNode.childrenMapped;\n        }\n    }\n\n    private bucketChildren(children: RowNode[], pivotColumns: Column[], pivotIndex: number, uniqueValues: any): any {\n\n        const mappedChildren: any = {};\n        const pivotColumn = pivotColumns[pivotIndex];\n\n        // map the children out based on the pivot column\n        children.forEach((child: RowNode) => {\n            let key: string = this.valueService.getKeyForNode(pivotColumn, child);\n\n            if (_.missing(key)) {\n                key = '';\n            }\n\n            if (!uniqueValues[key]) {\n                this.currentUniqueCount += 1;\n                uniqueValues[key] = {};\n\n                const doesGeneratedColMaxExist = this.maxUniqueValues !== -1;\n                const hasExceededColMax = this.currentUniqueCount > this.maxUniqueValues;\n                if (doesGeneratedColMaxExist && hasExceededColMax) {\n                    // throw an error to prevent all additional execution and escape the loops.\n                    throw Error(PivotStage.EXCEEDED_MAX_UNIQUE_VALUES);\n                }\n            }\n\n            if (!mappedChildren[key]) {\n                mappedChildren[key] = [];\n            }\n            mappedChildren[key].push(child);\n        });\n\n        // if it's the last pivot column, return as is, otherwise go one level further in the map\n        if (pivotIndex === pivotColumns.length - 1) {\n            return mappedChildren;\n        } else {\n            const result: any = {};\n\n            _.iterateObject(mappedChildren, (key: string, value: RowNode[]) => {\n                result[key] = this.bucketChildren(value, pivotColumns, pivotIndex + 1, uniqueValues[key]);\n            });\n\n            return result;\n        }\n    }\n\n    public getPivotColumnDefs(): ColDef[] {\n        return this.pivotColumnDefs;\n    }\n\n}\n", "import {\n    Bean,\n    BeanStub,\n    Column,\n    IAggFunc,\n    IAggFuncService,\n    PostConstruct,\n    _,\n    IAggFuncParams\n} from '@ag-grid-community/core';\n\n// @ts-ignore\nconst AGBigInt = typeof BigInt === 'undefined' ? null : BigInt;\n\nconst defaultAggFuncNames: { [key: string]: string } = {\n    sum: 'Sum',\n    first: 'First',\n    last: 'Last',\n    min: 'Min',\n    max: 'Max',\n    count: 'Count',\n    avg: 'Average',\n};\n\n@Bean('aggFuncService')\nexport class AggFuncService extends BeanStub implements IAggFuncService {\n\n    private static AGG_SUM = 'sum';\n    private static AGG_FIRST = 'first';\n    private static AGG_LAST = 'last';\n    private static AGG_MIN = 'min';\n    private static AGG_MAX = 'max';\n    private static AGG_COUNT = 'count';\n    private static AGG_AVG = 'avg';\n\n    private aggFuncsMap: { [key: string]: IAggFunc; } = {};\n    private initialised = false;\n\n    @PostConstruct\n    private init() {\n        if (this.initialised) {\n            return;\n        }\n\n        this.initialiseWithDefaultAggregations();\n        this.addAggFuncs(this.gridOptionsService.get('aggFuncs'));\n    }\n\n    private initialiseWithDefaultAggregations(): void {\n        this.aggFuncsMap[AggFuncService.AGG_SUM] = aggSum;\n        this.aggFuncsMap[AggFuncService.AGG_FIRST] = aggFirst;\n        this.aggFuncsMap[AggFuncService.AGG_LAST] = aggLast;\n        this.aggFuncsMap[AggFuncService.AGG_MIN] = aggMin;\n        this.aggFuncsMap[AggFuncService.AGG_MAX] = aggMax;\n        this.aggFuncsMap[AggFuncService.AGG_COUNT] = aggCount;\n        this.aggFuncsMap[AggFuncService.AGG_AVG] = aggAvg;\n        this.initialised = true;\n    }\n    \n    private isAggFuncPossible(column: Column, func: string): boolean {\n        const allKeys = this.getFuncNames(column);\n        const allowed = _.includes(allKeys, func);\n        const funcExists = _.exists(this.aggFuncsMap[func]);\n        return allowed && funcExists;\n    }\n\n    public getDefaultFuncLabel(fctName: string): string {\n        return defaultAggFuncNames[fctName] ?? fctName;\n    }\n\n    public getDefaultAggFunc(column: Column): string | null {\n        const defaultAgg = column.getColDef().defaultAggFunc;\n\n        if (_.exists(defaultAgg) && this.isAggFuncPossible(column, defaultAgg)) {\n            return defaultAgg;\n        }\n\n        if (this.isAggFuncPossible(column, AggFuncService.AGG_SUM)) {\n            return AggFuncService.AGG_SUM;\n        }\n\n        const allKeys = this.getFuncNames(column);\n        return _.existsAndNotEmpty(allKeys) ? allKeys[0] : null;\n    }\n\n    public addAggFuncs(aggFuncs?: { [key: string]: IAggFunc; }): void {\n        this.init();\n        _.iterateObject(aggFuncs, (key: string, aggFunc: IAggFunc) => {\n            this.aggFuncsMap[key] = aggFunc;\n        });\n    }\n\n    public getAggFunc(name: string): IAggFunc {\n        this.init();\n        return this.aggFuncsMap[name];\n    }\n\n    public getFuncNames(column: Column): string[] {\n        const userAllowedFuncs = column.getColDef().allowedAggFuncs;\n\n        return userAllowedFuncs == null ? Object.keys(this.aggFuncsMap).sort() : userAllowedFuncs;\n    }\n\n    public clear(): void {\n        this.aggFuncsMap = {};\n    }\n}\n\nfunction aggSum(params: IAggFuncParams): number | bigint {\n    const { values } = params;\n    let result: any = null; // the logic ensures that we never combine bigint arithmetic with numbers, but TS is hard to please\n\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n\n        if (typeof value === 'number') {\n            if (result === null) {\n                result = value;\n            } else {\n                if (AGBigInt) {\n                    result += typeof result === 'number' ? value : AGBigInt(value);\n                } else {\n                    result += value;\n                }\n            }\n        } else if (typeof value === 'bigint') {\n            if (result === null) {\n                result = value;\n            } else {\n                result = (typeof result === 'bigint' ? result : AGBigInt(result)) + value;\n            }\n        }\n    }\n\n    return result;\n}\n\nfunction aggFirst(params: IAggFuncParams): any {\n    return params.values.length > 0 ? params.values[0] : null;\n}\n\nfunction aggLast(params: IAggFuncParams): any {\n    return params.values.length > 0 ? _.last(params.values) : null;\n}\n\nfunction aggMin(params: IAggFuncParams): number | bigint | null {\n    const { values } = params;\n    let result: number | bigint | null = null;\n\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n\n        if ((typeof value === 'number' || typeof value === 'bigint') && (result === null || result > value)) {\n            result = value;\n        }\n    }\n\n    return result;\n}\n\nfunction aggMax(params: IAggFuncParams): number | bigint | null {\n    const { values } = params;\n    let result: number | bigint | null = null;\n\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n\n        if ((typeof value === 'number' || typeof value === 'bigint') && (result === null || result < value)) {\n            result = value;\n        }\n    }\n\n    return result;\n}\n\nfunction aggCount(params: IAggFuncParams) {\n    const { values } = params;\n    let result = 0;\n\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n\n        // check if the value is from a group, in which case use the group's count\n        result += value != null && typeof value.value === 'number' ? value.value : 1;\n    }\n\n\n    // the previous aggregation data\n    const existingAggData = params.rowNode?.aggData?.[params.column.getColId()];\n    if (existingAggData && existingAggData.value === result) {\n        // the underlying values haven't changed, return the old object to avoid triggering change detection\n        return existingAggData;\n    }\n\n    // it's important to wrap it in the object so we can determine if this is a group level\n    return {\n        value: result,\n        toString: function() {\n            return this.value.toString();\n        },\n        // used for sorting\n        toNumber: function() {\n            return this.value;\n        }\n    };\n}\n\n// the average function is tricky as the multiple levels require weighted averages\n// for the non-leaf node aggregations.\nfunction aggAvg(params: IAggFuncParams): { value: number | bigint | null; count: number; toString(): string; toNumber(): number; } {\n    const { values } = params;\n    let sum: any = 0; // the logic ensures that we never combine bigint arithmetic with numbers, but TS is hard to please\n    let count = 0;\n\n    // for optimum performance, we use a for loop here rather than calling any helper methods or using functional code\n    for (let i = 0; i < values.length; i++) {\n        const currentValue = values[i];\n        let valueToAdd = null;\n\n        if (typeof currentValue === 'number' || typeof currentValue === 'bigint') {\n            valueToAdd = currentValue;\n            count++;\n        } else if (currentValue != null && (typeof currentValue.value === 'number' || typeof currentValue.value === 'bigint') && typeof currentValue.count === 'number') {\n            // we are aggregating groups, so we take the aggregated values to calculated a weighted average\n            if (AGBigInt) {\n                valueToAdd = currentValue.value * (typeof currentValue.value === 'number' ? currentValue.count : AGBigInt(currentValue.count));\n            } else {\n                valueToAdd = currentValue.value * currentValue.count;\n            }\n            count += currentValue.count;\n        }\n\n        if (typeof valueToAdd === 'number') {\n            if (AGBigInt) {\n                sum += typeof sum === 'number' ? valueToAdd : AGBigInt(valueToAdd);\n            } else {\n                sum += valueToAdd;\n            }\n        } else if (typeof valueToAdd === 'bigint') {\n            sum = (typeof sum === 'bigint' ? sum : AGBigInt(sum)) + valueToAdd;\n        }\n    }\n\n    let value = null;\n\n    // avoid divide by zero error\n    if (count > 0) {\n        if (AGBigInt) {\n            value = sum / ((typeof sum === 'number' ? count : AGBigInt(count)) as any);\n        } else {\n            value = sum / count;\n        }\n\n    }\n\n    // the previous aggregation data\n    const existingAggData = params.rowNode?.aggData?.[params.column?.getColId()];\n    if (existingAggData && existingAggData.count === count && existingAggData.value === value) {\n        // the underlying values haven't changed, return the old object to avoid triggering change detection\n        return existingAggData;\n    }\n\n    // the result will be an object. when this cell is rendered, only the avg is shown.\n    // however when this cell is part of another aggregation, the count is also needed\n    // to create a weighted average for the next level.\n    return {\n        count,\n        value,\n        // the grid by default uses toString to render values for an object, so this\n        // is a trick to get the default cellRenderer to display the avg value\n        toString: function() {\n            return typeof this.value === 'number' || typeof this.value === 'bigint' ? this.value.toString() : '';\n        },\n        // used for sorting\n        toNumber: function() {\n            return this.value;\n        }\n    };\n}\n", "import {\n    Autowired,\n    ColumnModel,\n    Component,\n    Events,\n    PostConstruct,\n    _\n} from \"@ag-grid-community/core\";\nimport { RowGroupDropZonePanel } from \"./rowGroupDropZonePanel\";\nimport { PivotDropZonePanel } from \"./pivotDropZonePanel\";\n\nexport class GridHeaderDropZones extends Component {\n\n    @Autowired('columnModel') private columnModel: ColumnModel;\n\n    private rowGroupComp: Component;\n    private pivotComp: Component;\n\n    constructor() {\n        super();\n    }\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.setGui(this.createNorthPanel());\n\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onRowGroupChanged());\n        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, () => this.onRowGroupChanged());\n        this.addManagedPropertyListener('rowGroupPanelShow', () => this.onRowGroupChanged());\n        this.addManagedPropertyListener('pivotPanelShow', () => this.onPivotPanelShow());\n\n        this.onRowGroupChanged();\n    }\n\n    private createNorthPanel(): HTMLElement {\n        const topPanelGui = document.createElement('div');\n\n        topPanelGui.classList.add('ag-column-drop-wrapper');\n        _.setAriaRole(topPanelGui, 'presentation');\n\n        this.rowGroupComp = new RowGroupDropZonePanel(true);\n        this.createManagedBean(this.rowGroupComp);\n\n        this.pivotComp = new PivotDropZonePanel(true);\n        this.createManagedBean(this.pivotComp);\n\n        topPanelGui.appendChild(this.rowGroupComp.getGui());\n        topPanelGui.appendChild(this.pivotComp.getGui());\n\n        this.addManagedListener(this.rowGroupComp, Component.EVENT_DISPLAYED_CHANGED, () => this.onDropPanelVisible());\n        this.addManagedListener(this.pivotComp, Component.EVENT_DISPLAYED_CHANGED, () => this.onDropPanelVisible());\n\n        this.onDropPanelVisible();\n\n        return topPanelGui;\n    }\n\n    private onDropPanelVisible(): void {\n        const bothDisplayed = this.rowGroupComp.isDisplayed() && this.pivotComp.isDisplayed();\n        this.rowGroupComp.addOrRemoveCssClass('ag-column-drop-horizontal-half-width', bothDisplayed);\n        this.pivotComp.addOrRemoveCssClass('ag-column-drop-horizontal-half-width', bothDisplayed);\n    }\n\n    private onRowGroupChanged(): void {\n        if (!this.rowGroupComp) {\n            return;\n        }\n\n        const rowGroupPanelShow = this.gridOptionsService.get('rowGroupPanelShow');\n\n        if (rowGroupPanelShow === 'always') {\n            this.rowGroupComp.setDisplayed(true);\n        } else if (rowGroupPanelShow === 'onlyWhenGrouping') {\n            const grouping = !this.columnModel.isRowGroupEmpty();\n            this.rowGroupComp.setDisplayed(grouping);\n        } else {\n            this.rowGroupComp.setDisplayed(false);\n        }\n    }\n\n    private onPivotPanelShow() {\n        if (!this.pivotComp) {\n            return;\n        }\n\n        const pivotPanelShow = this.gridOptionsService.get('pivotPanelShow');\n\n        if (pivotPanelShow === 'always') {\n            this.pivotComp.setDisplayed(true);\n        } else if (pivotPanelShow === 'onlyWhenPivoting') {\n            const pivoting = this.columnModel.isPivotActive();\n            this.pivotComp.setDisplayed(pivoting);\n        } else {\n            this.pivotComp.setDisplayed(false);\n        }\n    }\n}\n", "import {\n    _,\n    Column,\n    ColumnRowGroupChangeRequestEvent,\n    DragAndDropService,\n    DraggingEvent,\n    Events,\n    ITooltipParams,\n    PostConstruct,\n    WithoutGridCommon\n} from \"@ag-grid-community/core\";\nimport { BaseDropZonePanel } from \"./baseDropZonePanel\";\n\nexport class RowGroupDropZonePanel extends BaseDropZonePanel {\n    constructor(horizontal: boolean) {\n        super(horizontal, 'rowGroup');\n    }\n\n    @PostConstruct\n    private passBeansUp(): void {\n        const localeTextFunc = this.localeService.getLocaleTextFunc();\n        const emptyMessage = localeTextFunc('rowGroupColumnsEmptyMessage', 'Drag here to set row groups');\n        const title = localeTextFunc('groups', 'Row Groups');\n\n        super.init({\n            icon: _.createIconNoSpan('rowGroupPanel', this.gridOptionsService, null)!,\n            emptyMessage: emptyMessage,\n            title\n        });\n\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, this.refreshGui.bind(this));\n    }\n\n    protected getAriaLabel(): string {\n        const translate = this.localeService.getLocaleTextFunc();\n        const label = translate('ariaRowGroupDropZonePanelLabel', 'Row Groups');\n\n        return label;\n    }\n\n    public getTooltipParams(): WithoutGridCommon<ITooltipParams> {\n        const res = super.getTooltipParams();\n        res.location = 'rowGroupColumnsList';\n\n        return res;\n    }\n\n    protected isItemDroppable(column: Column, draggingEvent: DraggingEvent): boolean {\n        // we never allow grouping of secondary columns\n        if (this.gridOptionsService.get('functionsReadOnly') || !column.isPrimary()) { return false; }\n\n        return column.isAllowRowGroup() && (!column.isRowGroupActive() || this.isSourceEventFromTarget(draggingEvent));\n    }\n\n    protected updateItems(columns: Column[]) {\n        if (this.gridOptionsService.get('functionsPassive')) {\n            const event: WithoutGridCommon<ColumnRowGroupChangeRequestEvent> = {\n                type: Events.EVENT_COLUMN_ROW_GROUP_CHANGE_REQUEST,\n                columns: columns\n            };\n\n            this.eventService.dispatchEvent(event);\n        } else {\n            this.columnModel.setRowGroupColumns(columns, \"toolPanelUi\");\n        }\n    }\n\n    protected getIconName(): string {\n        return this.isPotentialDndItems() ? DragAndDropService.ICON_GROUP : DragAndDropService.ICON_NOT_ALLOWED;\n    }\n\n    protected getExistingItems(): Column[] {\n        return this.columnModel.getRowGroupColumns();\n    }\n}\n", "import {\n    Column,\n    DraggingEvent,\n    DropTarget,\n    _,\n    PillDropZonePanel,\n    PillDropZonePanelParams,\n    DragItem,\n    Autowired,\n    ColumnModel,\n    ColumnEventType,\n    Events,\n    DragSourceType\n} from \"@ag-grid-community/core\";\nimport { DropZoneColumnComp } from \"./dropZoneColumnComp\";\n\nexport type TDropZone = 'rowGroup' | 'pivot' | 'aggregation';\n\nexport abstract class BaseDropZonePanel extends PillDropZonePanel<DropZoneColumnComp, Column> {\n    @Autowired('columnModel') protected readonly columnModel: ColumnModel;\n\n    constructor(horizontal: boolean, private dropZonePurpose: TDropZone) {\n        super(horizontal);\n    }\n\n    public init(params: PillDropZonePanelParams): void {\n        super.init(params);\n\n        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.refreshGui.bind(this));\n\n        this.addManagedPropertyListeners(['functionsReadOnly', 'rowGroupPanelSuppressSort', 'groupLockGroupColumns'], this.refreshGui.bind(this));\n    }\n\n    protected getItems(dragItem: DragItem): Column[] {\n        return dragItem.columns ?? [];\n    }\n\n    protected isInterestedIn(type: DragSourceType): boolean {\n        // not interested in row drags\n        return type === DragSourceType.HeaderCell || type === DragSourceType.ToolPanel;\n    }\n\n    protected minimumAllowedNewInsertIndex(): number {\n        const numberOfLockedCols = this.gridOptionsService.get('groupLockGroupColumns');\n        const numberOfGroupCols = this.columnModel.getRowGroupColumns().length;\n        if (numberOfLockedCols === -1) {\n            return numberOfGroupCols;\n        }\n        return Math.min(numberOfLockedCols, numberOfGroupCols);\n    }\n\n    private showOrHideColumnOnExit(draggingEvent: DraggingEvent): boolean {\n        return this.isRowGroupPanel() && !this.gridOptionsService.get('suppressRowGroupHidesColumns') && !draggingEvent.fromNudge;\n    }\n\n    protected handleDragEnterEnd(draggingEvent: DraggingEvent): void {\n        const hideColumnOnExit = this.showOrHideColumnOnExit(draggingEvent);\n\n        if (hideColumnOnExit) {\n            const dragItem = draggingEvent.dragSource.getDragItem();\n            const columns = dragItem.columns;\n            this.setColumnsVisible(columns, false, \"uiColumnDragged\");\n        }\n    }\n\n    protected handleDragLeaveEnd(draggingEvent: DraggingEvent): void {\n        const showColumnOnExit = this.showOrHideColumnOnExit(draggingEvent);\n\n        if (showColumnOnExit) {\n            const dragItem = draggingEvent.dragSource.getDragItem();\n\n            this.setColumnsVisible(dragItem.columns, true, \"uiColumnDragged\");\n    }\n    }\n\n    public setColumnsVisible(columns: Column[] | null | undefined, visible: boolean, source: ColumnEventType) {\n        if (columns) {\n            const allowedCols = columns.filter(c => !c.getColDef().lockVisible);\n            this.columnModel.setColumnsVisible(allowedCols, visible, source);\n        }\n    }\n\n    private isRowGroupPanel() {\n        return this.dropZonePurpose === 'rowGroup';\n    }\n\n    protected refreshOnDragStop(): boolean {\n        // If the function is passive, then we don't refresh, as we assume the client application\n        // is going to call setRowGroups / setPivots / setValues at a later point which will then\n        // cause a refresh. This gives a nice GUI where the ghost stays until the app has caught\n        // up with the changes. However, if there was no change in the order, then we do need to\n        // refresh to reset the columns\n        return !this.gridOptionsService.get('functionsPassive');\n    }\n\n    protected createPillComponent(column: Column, dropTarget: DropTarget, ghost: boolean, horizontal: boolean): DropZoneColumnComp {\n        return new DropZoneColumnComp(column, dropTarget, ghost, this.dropZonePurpose, horizontal);\n    }\n}", "import {\n    PopupService,\n    Component,\n    Autowired,\n    Events,\n    DropTarget,\n    Column,\n    ColumnAggFuncChangeRequestEvent,\n    RefSelector,\n    Optional,\n    IAggFuncService,\n    VirtualList,\n    KeyCode,\n    _,\n    SortController,\n    SortIndicatorComp,\n    WithoutGridCommon,\n    PillDragComp,\n    ColumnModel,\n    DragItem,\n    DragSourceType,\n    DragAndDropService\n} from \"@ag-grid-community/core\";\nimport { TDropZone } from \"./baseDropZonePanel\";\n\nexport class DropZoneColumnComp extends PillDragComp<Column> {\n    @Autowired('popupService') private readonly popupService: PopupService;\n    @Optional('aggFuncService') private readonly aggFuncService: IAggFuncService;\n    @Autowired('sortController') private readonly sortController: SortController;\n    @Autowired('columnModel') protected readonly columnModel: ColumnModel;\n\n    @RefSelector('eSortIndicator') private eSortIndicator: SortIndicatorComp;\n\n    private displayName: string | null;\n    private popupShowing = false;\n\n    constructor(\n        private column: Column,\n        dragSourceDropTarget: DropTarget,\n        ghost: boolean,\n        private dropZonePurpose: TDropZone,\n        horizontal: boolean\n    ) {\n        super(\n            dragSourceDropTarget, ghost, horizontal,\n            /* html */`\n                <span role=\"option\">\n                    <span ref=\"eDragHandle\" class=\"ag-drag-handle ag-column-drop-cell-drag-handle\" role=\"presentation\"></span>\n                    <span ref=\"eText\" class=\"ag-column-drop-cell-text\" aria-hidden=\"true\"></span>\n                    <ag-sort-indicator ref=\"eSortIndicator\"></ag-sort-indicator>\n                    <span ref=\"eButton\" class=\"ag-column-drop-cell-button\" role=\"presentation\"></span>\n                </span>\n            `);\n    }\n\n    public init(): void {\n        this.displayName = this.columnModel.getDisplayNameForColumn(this.column, 'columnDrop');\n\n        super.init();\n\n        this.setupSort();\n\n        this.addManagedListener(this.eventService, Column.EVENT_SORT_CHANGED, () => {\n            this.setupAria();\n        });\n\n        if (this.isGroupingZone()) {\n            this.addManagedPropertyListener('groupLockGroupColumns', () => {\n                this.refreshRemove();\n                this.refreshDraggable();\n                this.setupAria();\n            });\n        }\n    }\n\n    public getItem(): Column {\n        return this.column;\n    }\n\n    protected getDisplayName(): string {\n        return this.displayName!;\n    }\n\n    protected getTooltip(): string | null | undefined {\n        return this.column.getColDef().headerTooltip;\n    }\n\n    protected addAdditionalAriaInstructions(ariaInstructions: string[], translate: (key: string, defaultValue: string) => string): void {\n        const isSortSuppressed = this.gridOptionsService.get('rowGroupPanelSuppressSort');\n        const isFunctionsReadOnly = this.gridOptionsService.get('functionsReadOnly')\n        if (this.isAggregationZone() && !isFunctionsReadOnly) {\n            const aggregationMenuAria = translate('ariaDropZoneColumnValueItemDescription', 'Press ENTER to change the aggregation type');\n            ariaInstructions.push(aggregationMenuAria);\n        }\n\n        if (this.isGroupingZone() && this.column.isSortable() && !isSortSuppressed) {\n            const sortProgressAria = translate('ariaDropZoneColumnGroupItemDescription', 'Press ENTER to sort');\n            ariaInstructions.push(sortProgressAria);\n        }\n\n        super.addAdditionalAriaInstructions(ariaInstructions, translate);\n    }\n\n    protected isDraggable(): boolean {\n        return this.isReadOnly();\n    }\n\n    protected isRemovable(): boolean {\n         return this.isReadOnly();\n    }\n\n    private isReadOnly(): boolean {\n        return !this.isGroupingAndLocked() && !this.gridOptionsService.get('functionsReadOnly');\n    }\n\n    protected getAriaDisplayName(): string {\n        const translate = this.localeService.getLocaleTextFunc();\n\n        const { name, aggFuncName } = this.getColumnAndAggFuncName();\n        const aggSeparator = translate('ariaDropZoneColumnComponentAggFuncSeparator', ' of ');\n        const sortDirection = {\n            asc: translate('ariaDropZoneColumnComponentSortAscending', 'ascending'),\n            desc: translate('ariaDropZoneColumnComponentSortDescending', 'descending'),\n        };\n        const columnSort = this.column.getSort();\n        const isSortSuppressed = this.gridOptionsService.get('rowGroupPanelSuppressSort');\n        return [\n            aggFuncName && `${aggFuncName}${aggSeparator}`,\n            name,\n            this.isGroupingZone() && !isSortSuppressed && columnSort && `, ${sortDirection[columnSort]}`\n        ].filter(part => !!part).join('');\n    }\n\n    private getColumnAndAggFuncName(): { name: string, aggFuncName: string } {\n        const name = this.displayName as string;\n        let aggFuncName: string = '';\n\n        if (this.isAggregationZone()) {\n            const aggFunc = this.column.getAggFunc();\n            // if aggFunc is a string, we can use it, but if it's a function, then we swap with 'func'\n            const aggFuncString = typeof aggFunc === 'string' ? aggFunc : 'agg';\n            const localeTextFunc = this.localeService.getLocaleTextFunc();\n            aggFuncName = localeTextFunc(aggFuncString, aggFuncString);\n        }\n\n        return { name, aggFuncName };\n    }\n\n    public setupSort(): void {\n        const canSort = this.column.isSortable();\n        const isGroupingZone = this.isGroupingZone();\n        if (!canSort || !isGroupingZone) {\n            return;\n        }\n\n        if (!this.gridOptionsService.get('rowGroupPanelSuppressSort')) {\n            this.eSortIndicator.setupSort(this.column, true);\n            const performSort = (event: MouseEvent | KeyboardEvent) => {\n                event.preventDefault();\n                const sortUsingCtrl = this.gridOptionsService.get('multiSortKey') === 'ctrl';\n                const multiSort = sortUsingCtrl ? (event.ctrlKey || event.metaKey) : event.shiftKey;\n                this.sortController.progressSort(this.column, multiSort, 'uiColumnSorted');\n            };\n\n            this.addGuiEventListener('click', performSort);\n            this.addGuiEventListener('keydown', (e: KeyboardEvent) => {\n                const isEnter = e.key === KeyCode.ENTER;\n                if (isEnter && this.isGroupingZone()) {\n                    performSort(e);\n                }\n            });\n        }\n    }\n\n    protected getDefaultIconName(): string {\n        return DragAndDropService.ICON_HIDE;\n    }\n\n    protected createGetDragItem(): () => DragItem {\n        const { column } = this;\n        return () => {\n            const visibleState: { [key: string]: boolean } = {};\n            visibleState[column.getId()] = column.isVisible();\n            return {\n                columns: [column],\n                visibleState: visibleState\n            };\n        };\n    }\n\n    protected setupComponents(): void {\n        super.setupComponents();\n\n        if (this.isAggregationZone() && !this.gridOptionsService.get('functionsReadOnly')) {\n            this.addGuiEventListener('click', this.onShowAggFuncSelection.bind(this));\n        }\n    }\n\n    protected onKeyDown(e: KeyboardEvent): void {\n        super.onKeyDown(e);\n\n        const isEnter = e.key === KeyCode.ENTER;\n        if (isEnter && this.isAggregationZone() && !this.gridOptionsService.get('functionsReadOnly')) {\n            e.preventDefault();\n            this.onShowAggFuncSelection();\n        }\n    }\n\n    protected getDisplayValue(): string {\n        const { name, aggFuncName } = this.getColumnAndAggFuncName();\n        return this.isAggregationZone() ? `${aggFuncName}(${name})` : name;\n    }\n\n    private onShowAggFuncSelection(): void {\n        if (this.popupShowing) { return; }\n\n        this.popupShowing = true;\n\n        const virtualList = new VirtualList({ cssIdentifier: 'select-agg-func' });\n        const rows = this.aggFuncService.getFuncNames(this.column);\n        const eGui = this.getGui();\n        const virtualListGui = virtualList.getGui();\n\n        virtualList.setModel({\n            getRow: function (index: number) { return rows[index]; },\n            getRowCount: function () { return rows.length; }\n        });\n\n        this.getContext().createBean(virtualList);\n\n        const ePopup = _.loadTemplate(/* html*/ `<div class=\"ag-select-agg-func-popup\"></div>`);\n        ePopup.style.top = '0px';\n        ePopup.style.left = '0px';\n        ePopup.appendChild(virtualListGui);\n        ePopup.style.width = `${eGui.clientWidth}px`;\n\n        const focusoutListener = this.addManagedListener(ePopup, 'focusout', (e: FocusEvent) => {\n            if (!ePopup.contains(e.relatedTarget as HTMLElement) && addPopupRes) {\n                addPopupRes.hideFunc();\n            }\n        });\n\n        const popupHiddenFunc = (callbackEvent?: KeyboardEvent) => {\n            this.destroyBean(virtualList);\n            this.popupShowing = false;\n\n            if (callbackEvent?.key === 'Escape') {\n                eGui.focus();\n            }\n\n            if (focusoutListener) {\n                focusoutListener();\n            }\n        };\n\n        const translate = this.localeService.getLocaleTextFunc();\n\n        const addPopupRes = this.popupService.addPopup({\n            modal: true,\n            eChild: ePopup,\n            closeOnEsc: true,\n            closedCallback: popupHiddenFunc,\n            ariaLabel: translate('ariaLabelAggregationFunction', 'Aggregation Function')\n        });\n\n        if (addPopupRes) {\n            virtualList.setComponentCreator(\n                this.createAggSelect.bind(this, addPopupRes.hideFunc)\n            );\n        }\n\n        virtualList.addGuiEventListener('keydown', (e: KeyboardEvent) => {\n            if (e.key === KeyCode.ENTER || e.key === KeyCode.SPACE) {\n                const row = virtualList.getLastFocusedRow();\n\n                if (row == null) { return; }\n\n                const comp = virtualList.getComponentAt(row) as AggItemComp;\n\n                if (comp) {\n                    comp.selectItem();\n                }\n            }\n        });\n\n        this.popupService.positionPopupByComponent({\n            type: 'aggFuncSelect',\n            eventSource: eGui,\n            ePopup: ePopup,\n            keepWithinBounds: true,\n            column: this.column,\n            position: 'under'\n        });\n\n        virtualList.refresh();\n\n        let rowToFocus = rows.findIndex(r => r === this.column.getAggFunc());\n        if (rowToFocus === -1) { rowToFocus = 0; }\n\n        virtualList.focusRow(rowToFocus);\n    }\n\n    private createAggSelect(hidePopup: () => void, value: any): Component {\n\n        const itemSelected = () => {\n            hidePopup();\n            if (this.gridOptionsService.get('functionsPassive')) {\n                const event: WithoutGridCommon<ColumnAggFuncChangeRequestEvent> = {\n                    type: Events.EVENT_COLUMN_AGG_FUNC_CHANGE_REQUEST,\n                    columns: [this.column],\n                    aggFunc: value\n                };\n                this.eventService.dispatchEvent(event);\n            } else {\n                this.columnModel.setColumnAggFunc(this.column, value, \"toolPanelDragAndDrop\");\n            }\n        };\n\n        const localeTextFunc = this.localeService.getLocaleTextFunc();\n        const aggFuncString = value.toString();\n        const aggFuncStringTranslated = localeTextFunc(aggFuncString, aggFuncString);\n        const comp = new AggItemComp(itemSelected, aggFuncStringTranslated);\n\n        return comp;\n    }\n\n    private isGroupingAndLocked(): boolean {\n        return this.isGroupingZone() && this.columnModel.isColumnGroupingLocked(this.column);\n    }\n\n    private isAggregationZone() {\n        return this.dropZonePurpose === 'aggregation';\n    }\n\n    private isGroupingZone() {\n        return this.dropZonePurpose === 'rowGroup';\n    }\n\n    protected getDragSourceType(): DragSourceType {\n        return DragSourceType.ToolPanel;\n    }\n\n    protected destroy(): void {\n        super.destroy();\n        (this.column as any) = null;\n    }\n}\n\nclass AggItemComp extends Component {\n\n    public selectItem: () => void;\n\n    constructor(itemSelected: () => void, value: string) {\n        super(/* html */ `<div class=\"ag-select-agg-func-item\"/>`);\n        this.selectItem = itemSelected;\n        this.getGui().innerText = value;\n        this.addGuiEventListener('click', this.selectItem);\n    }\n\n}\n", "import {\n    _,\n    Column,\n    ColumnPivotChangeRequestEvent,\n    DragAndDropService,\n    DraggingEvent,\n    Events,\n    ITooltipParams,\n    PostConstruct,\n    WithoutGridCommon\n} from \"@ag-grid-community/core\";\nimport { BaseDropZonePanel } from \"./baseDropZonePanel\";\n\nexport class PivotDropZonePanel extends BaseDropZonePanel {\n    constructor(horizontal: boolean) {\n        super(horizontal, 'pivot');\n    }\n\n    @PostConstruct\n    private passBeansUp(): void {\n        const localeTextFunc = this.localeService.getLocaleTextFunc();\n        const emptyMessage = localeTextFunc('pivotColumnsEmptyMessage', 'Drag here to set column labels');\n        const title = localeTextFunc('pivots', 'Column Labels');\n\n        super.init({\n            icon: _.createIconNoSpan('pivotPanel', this.gridOptionsService, null)!,\n            emptyMessage: emptyMessage,\n            title: title\n        });\n\n        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.refresh.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.refresh.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, this.checkVisibility.bind(this));\n\n        this.refresh();\n    }\n\n    protected getAriaLabel(): string {\n        const translate = this.localeService.getLocaleTextFunc();\n        const label = translate('ariaPivotDropZonePanelLabel', 'Column Labels');\n\n        return label;\n    }\n\n    public getTooltipParams(): WithoutGridCommon<ITooltipParams> {\n        const res = super.getTooltipParams();\n        res.location = 'pivotColumnsList';\n        return res;\n    }\n\n    private refresh(): void {\n        this.checkVisibility();\n        this.refreshGui();\n    }\n\n    private checkVisibility(): void {\n        const pivotMode = this.columnModel.isPivotMode();\n\n        if (this.isHorizontal()) {\n            // what we do for horizontal (ie the pivot panel at the top) depends\n            // on the user property as well as pivotMode.\n            switch (this.gridOptionsService.get('pivotPanelShow')) {\n                case 'always':\n                    this.setDisplayed(pivotMode);\n                    break;\n                case 'onlyWhenPivoting':\n                    const pivotActive = this.columnModel.isPivotActive();\n                    this.setDisplayed(pivotMode && pivotActive);\n                    break;\n                default:\n                    // never show it\n                    this.setDisplayed(false);\n                    break;\n            }\n        } else {\n            // in toolPanel, the pivot panel is always shown when pivot mode is on\n            this.setDisplayed(pivotMode);\n        }\n    }\n\n    protected isItemDroppable(column: Column, draggingEvent: DraggingEvent): boolean {\n        // we never allow grouping of secondary columns\n        if (this.gridOptionsService.get('functionsReadOnly') || !column.isPrimary()) { return false; }\n\n        return column.isAllowPivot() && (!column.isPivotActive() || this.isSourceEventFromTarget(draggingEvent));\n    }\n\n    protected updateItems(columns: Column[]): void {\n        if (this.gridOptionsService.get('functionsPassive')) {\n            const event: WithoutGridCommon<ColumnPivotChangeRequestEvent> = {\n                type: Events.EVENT_COLUMN_PIVOT_CHANGE_REQUEST,\n                columns: columns\n            };\n\n            this.eventService.dispatchEvent(event);\n        } else {\n            this.columnModel.setPivotColumns(columns, \"toolPanelUi\");\n        }\n    }\n\n    protected getIconName(): string {\n        return this.isPotentialDndItems() ? DragAndDropService.ICON_PIVOT : DragAndDropService.ICON_NOT_ALLOWED;\n    }\n\n    protected getExistingItems(): Column[] {\n        return this.columnModel.getPivotColumns();\n    }\n}\n", "import {\n    Autowired,\n    Bean,\n    IRowNodeStage,\n    StageExecuteParams,\n    BeanStub,\n    FilterManager,\n    RowNode,\n    ColumnModel,\n    GridOptions,\n} from \"@ag-grid-community/core\";\n\n@Bean('filterAggregatesStage')\nexport class FilterAggregatesStage extends BeanStub implements IRowNodeStage {\n\n    @Autowired('filterManager') private filterManager: FilterManager;\n    @Autowired('columnModel') private columnModel: ColumnModel;\n\n    public execute(params: StageExecuteParams): void {\n        const isPivotMode = this.columnModel.isPivotMode();\n        const isAggFilterActive = this.filterManager.isAggregateFilterPresent()\n            || this.filterManager.isAggregateQuickFilterPresent();\n\n        // This is the default filter for applying only to leaf nodes, realistically this should not apply as primary agg columns,\n        // should not be applied by the filterManager if getGroupAggFiltering is missing. Predicate will apply filters to leaf level.\n        const defaultPrimaryColumnPredicate = (params: { node: RowNode }) => !params.node.group;\n\n        // Default secondary column predicate, selecting only leaf level groups.\n        const defaultSecondaryColumnPredicate = ((params: { node: RowNode }) => params.node.leafGroup);\n\n        // The predicate to determine whether filters should apply to this row. Either defined by the user in groupAggFiltering or a default depending\n        // on current pivot mode status.\n        const applyFilterToNode = this.gridOptionsService.getGroupAggFiltering()\n            || (isPivotMode ? defaultSecondaryColumnPredicate : defaultPrimaryColumnPredicate);\n\n        const { changedPath } = params;\n\n        const preserveChildren = (node: RowNode, recursive = false) => {\n            if (node.childrenAfterFilter) {\n                node.childrenAfterAggFilter = node.childrenAfterFilter;\n                if (recursive) {\n                    node.childrenAfterAggFilter.forEach((child) => preserveChildren(child, recursive));\n                }\n                this.setAllChildrenCount(node);\n            }\n\n            if (node.sibling) {\n                node.sibling.childrenAfterAggFilter = node.childrenAfterAggFilter;\n            }\n        }\n\n        const filterChildren = (node: RowNode) => {\n            node.childrenAfterAggFilter = node.childrenAfterFilter?.filter((child: RowNode) => {\n                const shouldFilterRow = applyFilterToNode({ node: child });\n                if (shouldFilterRow) {\n                    const doesNodePassFilter = this.filterManager.doesRowPassAggregateFilters({ rowNode: child });\n                    if (doesNodePassFilter) {\n                        // Node has passed, so preserve children\n                        preserveChildren(child, true);\n                        return true;\n                    }\n                }\n                const hasChildPassed = child.childrenAfterAggFilter?.length;\n                return hasChildPassed;\n            }) || null;\n\n            this.setAllChildrenCount(node);\n            if (node.sibling) {\n                node.sibling.childrenAfterAggFilter = node.childrenAfterAggFilter;\n            }\n        };\n\n        changedPath!.forEachChangedNodeDepthFirst(\n            isAggFilterActive ? filterChildren : preserveChildren,\n            true,\n        );\n    }\n\n    private setAllChildrenCountTreeData(rowNode: RowNode) {\n        // for tree data, we include all children, groups and leafs\n        let allChildrenCount = 0;\n        rowNode.childrenAfterAggFilter!.forEach((child: RowNode) => {\n            // include child itself\n            allChildrenCount++;\n            // include children of children\n            allChildrenCount += child.allChildrenCount as any;\n        });\n        rowNode.setAllChildrenCount(allChildrenCount);\n    }\n\n    private setAllChildrenCountGridGrouping(rowNode: RowNode) {\n        // for grid data, we only count the leafs\n        let allChildrenCount = 0;\n        rowNode.childrenAfterAggFilter!.forEach((child: RowNode) => {\n            if (child.group) {\n                allChildrenCount += child.allChildrenCount as any;\n            } else {\n                allChildrenCount++;\n            }\n        });\n        rowNode.setAllChildrenCount(allChildrenCount);\n    }\n\n    private setAllChildrenCount(rowNode: RowNode) {\n        if (!rowNode.hasChildren()) {\n            rowNode.setAllChildrenCount(null);\n            return;\n        }\n\n        if (this.gridOptionsService.get('treeData')) {\n            this.setAllChildrenCountTreeData(rowNode);\n        } else {\n            this.setAllChildrenCountGridGrouping(rowNode);\n        }\n    }\n}", "// DO NOT UPDATE MANUALLY: Generated from script during build time\nexport const VERSION = '31.2.0';", "import {\n    _,\n    AgPromise,\n    AgSelect,\n    Autowired,\n    Column,\n    ColumnModel,\n    Events,\n    FilterManager,\n    IAfterGuiAttachedParams,\n    IFilterComp,\n    IFilterParams,\n    PostConstruct,\n    RefSelector,\n    TabGuardComp,\n} from '@ag-grid-community/core';\n\ninterface FilterColumnPair {\n    filter: IFilterComp;\n    column: Column;\n}\n\nexport class GroupFilter extends TabGuardComp implements IFilterComp {\n    public static EVENT_COLUMN_ROW_GROUP_CHANGED = 'columnRowGroupChanged';\n    public static EVENT_SELECTED_COLUMN_CHANGED = 'selectedColumnChanged';\n\n    @Autowired('filterManager') private readonly filterManager: FilterManager;\n    @Autowired('columnModel') private readonly columnModel: ColumnModel;\n\n    @RefSelector('eGroupField') private readonly eGroupField: HTMLElement;\n    @RefSelector('eUnderlyingFilter') private readonly eUnderlyingFilter: HTMLElement;\n\n    private params: IFilterParams;\n    private groupColumn: Column;\n    private selectedColumn: Column | undefined;\n    private selectedFilter: IFilterComp | undefined;\n    private filterColumnPairs: FilterColumnPair[] | undefined;\n    private eGroupFieldSelect: AgSelect;\n    private afterGuiAttachedParams: IAfterGuiAttachedParams | undefined;\n\n    constructor() {\n        super(/* html */ `\n            <div class=\"ag-group-filter\">\n                <div ref=\"eGroupField\"></div>\n                <div ref=\"eUnderlyingFilter\"></div>\n            </div>\n        `);\n    }\n\n    @PostConstruct\n    private postConstruct() {\n        this.initialiseTabGuard({});\n    }\n\n    public init(params: IFilterParams): AgPromise<void> {\n        this.params = params;\n        this.validateParams();\n        return this.updateGroups().then(() => {\n            this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onColumnRowGroupChanged());\n        });\n    }\n\n    private validateParams(): void {\n        const { colDef } = this.params;\n        if (colDef.field) {\n            _.warnOnce('Group Column Filter does not work with the colDef property \"field\". This property will be ignored.');\n        }\n        if (colDef.filterValueGetter) {\n            _.warnOnce('Group Column Filter does not work with the colDef property \"filterValueGetter\". This property will be ignored.');\n        }\n        if (colDef.filterParams) {\n            _.warnOnce('Group Column Filter does not work with the colDef property \"filterParams\". This property will be ignored.');\n        }\n    }\n\n    private updateGroups(): AgPromise<void> {\n        const sourceColumns = this.updateGroupField();\n        return this.getUnderlyingFilters(sourceColumns);\n    }\n\n    private getSourceColumns(): Column[] {\n        this.groupColumn = this.params.column;\n        if (this.gridOptionsService.get('treeData')) {\n            _.warnOnce('Group Column Filter does not work with Tree Data enabled. Please disable Tree Data, or use a different filter.');\n            return [];\n        }\n        const sourceColumns = this.columnModel.getSourceColumnsForGroupColumn(this.groupColumn);\n        if (!sourceColumns) {\n            _.warnOnce('Group Column Filter only works on group columns. Please use a different filter.');\n            return [];\n        }\n        return sourceColumns;\n    }\n\n    private updateGroupField(): Column[] | null {\n        _.clearElement(this.eGroupField);\n        if (this.eGroupFieldSelect) {\n            this.destroyBean(this.eGroupFieldSelect);\n        }\n        const allSourceColumns = this.getSourceColumns();\n        const sourceColumns = allSourceColumns.filter(sourceColumn => sourceColumn.isFilterAllowed());\n        if (!sourceColumns.length) {\n            this.selectedColumn = undefined;\n            _.setDisplayed(this.eGroupField, false);\n            return null;\n        }\n        if (allSourceColumns.length === 1) {\n            // we only want to hide the group field element if there's only one group column.\n            // If there's one group column that has a filter, but multiple columns in total,\n            // we should still show the select so the user knows which column it's for.\n            this.selectedColumn = sourceColumns[0];\n            _.setDisplayed(this.eGroupField, false);\n        } else {\n            // keep the old selected column if it's still valid\n            if (!this.selectedColumn || !sourceColumns.some(column => column.getId() === this.selectedColumn!.getId())) {\n                this.selectedColumn = sourceColumns[0];\n            }\n            this.createGroupFieldSelectElement(sourceColumns);\n            this.eGroupField.appendChild(this.eGroupFieldSelect.getGui());\n            this.eGroupField.appendChild(_.loadTemplate(/* html */ `<div class=\"ag-filter-separator\"></div>`));\n            _.setDisplayed(this.eGroupField, true);\n        }\n\n        return sourceColumns;\n    }\n\n    private createGroupFieldSelectElement(sourceColumns: Column[]): void {\n        this.eGroupFieldSelect = this.createManagedBean(new AgSelect());\n        const localeTextFunc = this.localeService.getLocaleTextFunc();\n        this.eGroupFieldSelect.setLabel(localeTextFunc('groupFilterSelect', 'Select field:'));\n        this.eGroupFieldSelect.setLabelAlignment('top');\n        this.eGroupFieldSelect.addOptions(sourceColumns.map(sourceColumn => ({\n            value: sourceColumn.getId(),\n            text: this.columnModel.getDisplayNameForColumn(sourceColumn, 'groupFilter', false) ?? undefined\n        })));\n        this.eGroupFieldSelect.setValue(this.selectedColumn!.getId());\n        this.eGroupFieldSelect.onValueChange((newValue) => this.updateSelectedColumn(newValue));\n        this.eGroupFieldSelect.addCssClass('ag-group-filter-field-select-wrapper');\n        if (sourceColumns.length === 1) {\n            this.eGroupFieldSelect.setDisabled(true);\n        }\n    }\n\n    private getUnderlyingFilters(sourceColumns: Column[] | null): AgPromise<void> {\n        if (!sourceColumns) {\n            this.filterColumnPairs = undefined;\n            this.selectedFilter = undefined;\n            this.groupColumn.setFilterActive(false, 'columnRowGroupChanged');\n            return AgPromise.resolve();\n        }\n        const filterPromises: AgPromise<IFilterComp>[] = [];\n        const filterColumnPairs: FilterColumnPair[] = [];\n        sourceColumns.forEach(column => {\n            const filterWrapper = this.filterManager.getOrCreateFilterWrapper(column, 'COLUMN_MENU');\n            if (filterWrapper?.filterPromise) {\n                filterPromises.push(filterWrapper.filterPromise.then(filter => {\n                    if (filter) {\n                        filterColumnPairs.push({\n                            filter,\n                            column\n                        });\n                    }\n                    if (column.getId() === this.selectedColumn!.getId()) {\n                        this.selectedFilter = filter ?? undefined;\n                    }\n                    return filter!;\n                }));\n            }\n        });\n        return AgPromise.all(filterPromises).then(() => {\n            this.filterColumnPairs = filterColumnPairs;\n            this.groupColumn.setFilterActive(this.isFilterActive(), 'columnRowGroupChanged');\n        });\n    }\n\n    private addUnderlyingFilterElement(): AgPromise<void> {\n        _.clearElement(this.eUnderlyingFilter);\n        if (!this.selectedColumn) {\n            return AgPromise.resolve();\n        }\n        const filterWrapper = this.filterManager.getOrCreateFilterWrapper(this.selectedColumn, 'COLUMN_MENU');\n        if (!filterWrapper) {\n            return AgPromise.resolve();\n        }\n        return filterWrapper.guiPromise.then(gui => {\n            this.eUnderlyingFilter.appendChild(gui!);\n            filterWrapper.filterPromise?.then(filter => {\n                filter?.afterGuiAttached?.(this.afterGuiAttachedParams);\n                if (!this.afterGuiAttachedParams?.suppressFocus && this.eGroupFieldSelect && !this.eGroupFieldSelect.isDisabled()) {\n                    this.eGroupFieldSelect.getFocusableElement().focus();\n                }\n            });\n        });\n    }\n\n    private updateSelectedColumn(columnId: string | null | undefined): void {\n        if (!columnId) {\n            return;\n        }\n        this.selectedFilter?.afterGuiDetached?.();\n        const selectedFilterColumnPair = this.getFilterColumnPair(columnId);\n        this.selectedColumn = selectedFilterColumnPair?.column;\n        this.selectedFilter = selectedFilterColumnPair?.filter;\n\n        this.dispatchEvent({\n            type: GroupFilter.EVENT_SELECTED_COLUMN_CHANGED\n        });\n        this.addUnderlyingFilterElement();\n    }\n\n    public isFilterActive(): boolean {\n        return !!this.filterColumnPairs?.some(({ filter }) => filter.isFilterActive());\n    }\n\n    public doesFilterPass(): boolean {\n        return true;\n    }\n\n    public getModel(): null {\n        return null;\n    }\n\n    public setModel(): AgPromise<void> {\n        return AgPromise.resolve();\n    }\n\n    public afterGuiAttached(params?: IAfterGuiAttachedParams): void {\n        this.afterGuiAttachedParams = params;\n        this.addUnderlyingFilterElement();\n    }\n\n    public afterGuiDetached(): void {\n        _.clearElement(this.eUnderlyingFilter);\n        this.selectedFilter?.afterGuiDetached?.();\n    }\n\n    private onColumnRowGroupChanged(): void {\n        this.updateGroups().then(() => {\n            this.dispatchEvent({\n                type: GroupFilter.EVENT_COLUMN_ROW_GROUP_CHANGED\n            });\n            this.eventService.dispatchEvent({\n                type: 'filterAllowedUpdated'\n            })\n        });\n    }\n\n    private getFilterColumnPair(columnId: string | undefined): FilterColumnPair | undefined {\n        if (!columnId) {\n            return undefined;\n        }\n        return this.filterColumnPairs?.find(({ column }) => column.getId() === columnId);\n    }\n\n    public getSelectedFilter(): IFilterComp | undefined {\n        return this.selectedFilter;\n    }\n\n    public getSelectedColumn(): Column | undefined {\n        return this.selectedColumn;\n    }\n\n    public isFilterAllowed(): boolean {\n        return !!this.selectedColumn;\n    }\n\n    public destroy(): void {\n        super.destroy();\n    }\n}\n", "import {\n    _,\n    AgInputTextField,\n    AgPromise,\n    Autowired,\n    ColumnModel,\n    Column,\n    Component,\n    FilterChangedEvent,\n    FilterManager,\n    IFloatingFilterComp,\n    IFloatingFilterParams,\n    RefSelector,\n    UserCompDetails,\n    ColumnEvent,\n} from '@ag-grid-community/core';\nimport { GroupFilter } from './groupFilter';\n\nexport class GroupFloatingFilterComp extends Component implements IFloatingFilterComp<GroupFilter> {\n    @Autowired('columnModel') private readonly columnModel: ColumnModel;\n    @Autowired('filterManager') private readonly filterManager: FilterManager;\n\n    @RefSelector('eFloatingFilter') private readonly eFloatingFilter: HTMLElement;\n    \n    private params: IFloatingFilterParams<GroupFilter>;\n    private eFloatingFilterText: AgInputTextField;\n    private parentFilterInstance: GroupFilter;\n    private underlyingFloatingFilter: IFloatingFilterComp | undefined;\n    private showingUnderlyingFloatingFilter: boolean;\n    private compDetails: UserCompDetails;\n    private haveAddedColumnListeners: boolean = false;\n    \n    constructor() {\n        super(/* html */ `\n            <div ref=\"eFloatingFilter\" class=\"ag-group-floating-filter ag-floating-filter-input\" role=\"presentation\"></div>\n        `);\n    }\n\n    public init(params: IFloatingFilterParams<GroupFilter>): AgPromise<void> {\n        this.params = params;\n\n        // we only support showing the underlying floating filter for multiple group columns\n        const canShowUnderlyingFloatingFilter = this.gridOptionsService.get('groupDisplayType') === 'multipleColumns';\n\n        return new AgPromise<void>(resolve => {\n            this.params.parentFilterInstance(parentFilterInstance => {\n                this.parentFilterInstance = parentFilterInstance;\n\n                if (canShowUnderlyingFloatingFilter) {\n                    this.setupUnderlyingFloatingFilterElement().then(() => resolve());\n                } else {\n                    this.setupReadOnlyFloatingFilterElement();\n                    resolve();\n                }\n            });\n        }).then(() => {\n            this.addManagedListener(this.parentFilterInstance, GroupFilter.EVENT_SELECTED_COLUMN_CHANGED, () => this.onSelectedColumnChanged());\n            this.addManagedListener(this.parentFilterInstance, GroupFilter.EVENT_COLUMN_ROW_GROUP_CHANGED, () => this.onColumnRowGroupChanged());\n        });\n    }\n\n    public onParamsUpdated(params: IFloatingFilterParams<GroupFilter>): void {\n        this.refresh(params);\n    }\n\n    public refresh(params: IFloatingFilterParams<GroupFilter>): void {\n        this.params = params;\n        this.setParams();\n    }\n\n    private setParams(): void {\n        const displayName = this.columnModel.getDisplayNameForColumn(this.params.column, 'header', true);\n        const translate = this.localeService.getLocaleTextFunc();\n        this.eFloatingFilterText?.setInputAriaLabel(`${displayName} ${translate('ariaFilterInput', 'Filter Input')}`);\n    }\n\n    private setupReadOnlyFloatingFilterElement(): void {\n        if (!this.eFloatingFilterText) {\n            this.eFloatingFilterText = this.createManagedBean(new AgInputTextField());\n            \n            this.eFloatingFilterText\n                .setDisabled(true)\n                .addGuiEventListener('click', () => this.params.showParentFilter());\n\n            this.setParams();\n        }\n\n        this.updateDisplayedValue();\n\n        this.eFloatingFilter.appendChild(this.eFloatingFilterText.getGui());\n    }\n\n    private setupUnderlyingFloatingFilterElement(): AgPromise<void> {\n        this.showingUnderlyingFloatingFilter = false;\n        this.underlyingFloatingFilter = undefined;\n        _.clearElement(this.eFloatingFilter);\n        const column = this.parentFilterInstance.getSelectedColumn();\n        // we can only show the underlying filter if there is one instance (e.g. the underlying column is not visible)\n        if (column && !column.isVisible()) {\n            const compDetails = this.filterManager.getFloatingFilterCompDetails(column, this.params.showParentFilter);\n            if (compDetails) {\n                this.compDetails = compDetails;\n                if (!this.haveAddedColumnListeners) {\n                    this.haveAddedColumnListeners = true;\n                    this.addManagedListener(column, Column.EVENT_VISIBLE_CHANGED, this.onColumnVisibleChanged.bind(this));\n                    this.addManagedListener(column, Column.EVENT_COL_DEF_CHANGED, this.onColDefChanged.bind(this));\n                }\n                return compDetails.newAgStackInstance().then(floatingFilter => {\n                    this.underlyingFloatingFilter = floatingFilter;\n                    this.underlyingFloatingFilter?.onParentModelChanged(this.parentFilterInstance.getSelectedFilter()?.getModel());\n                    this.appendChild(floatingFilter.getGui());\n                    this.showingUnderlyingFloatingFilter = true;\n                });\n            }\n        }\n        // fallback to the read-only version\n        this.setupReadOnlyFloatingFilterElement();\n        return AgPromise.resolve();\n    }\n\n    private onColumnVisibleChanged(): void {\n        this.setupUnderlyingFloatingFilterElement();\n    }\n\n    private onColDefChanged(event: ColumnEvent): void {\n        if (!event.column) { return; }\n        const compDetails = this.filterManager.getFloatingFilterCompDetails(event.column, this.params.showParentFilter);\n        if (compDetails) {\n            if (this.underlyingFloatingFilter?.refresh) {\n                this.underlyingFloatingFilter.refresh(compDetails.params);\n            } else {\n                this.underlyingFloatingFilter?.onParamsUpdated?.(compDetails.params);\n            }\n        }\n    }\n\n    public onParentModelChanged(_model: null, event: FilterChangedEvent): void {\n        if (this.showingUnderlyingFloatingFilter) {\n            this.underlyingFloatingFilter?.onParentModelChanged(this.parentFilterInstance.getSelectedFilter()?.getModel(), event);\n        } else {\n            this.updateDisplayedValue();\n        }\n\n    }\n\n    private updateDisplayedValue(): void {\n        if (!this.parentFilterInstance || !this.eFloatingFilterText) {\n            return;\n        }\n        const selectedFilter = this.parentFilterInstance.getSelectedFilter();\n        if (!selectedFilter) {\n            this.eFloatingFilterText.setValue('');\n            this.eFloatingFilterText.setDisplayed(false);\n            return;\n        }\n        this.eFloatingFilterText.setDisplayed(true);\n        if (selectedFilter.getModelAsString) {\n            const filterModel = selectedFilter.getModel();\n            this.eFloatingFilterText.setValue(filterModel == null ? '' : selectedFilter.getModelAsString(filterModel));\n        } else {\n            this.eFloatingFilterText.setValue('');\n        }\n    }\n\n    private onSelectedColumnChanged(): void {\n        if (!this.showingUnderlyingFloatingFilter) {\n            this.updateDisplayedValue();\n        }\n    }\n\n    private onColumnRowGroupChanged(): void {\n        if (!this.showingUnderlyingFloatingFilter) {\n            this.updateDisplayedValue();\n        }\n    }\n\n    public destroy(): void {\n        super.destroy();\n    }\n}\n", "import {\n    _,\n    Column,\n    ColumnValueChangeRequestEvent,\n    DragAndDropService,\n    DraggingEvent,\n    Events,\n    ITooltipParams,\n    PostConstruct,\n    WithoutGridCommon\n} from \"@ag-grid-community/core\";\nimport { BaseDropZonePanel } from \"./baseDropZonePanel\";\n\nexport class ValuesDropZonePanel extends BaseDropZonePanel {\n    constructor(horizontal: boolean) {\n        super(horizontal, 'aggregation');\n    }\n\n    @PostConstruct\n    private passBeansUp(): void {\n        const localeTextFunc = this.localeService.getLocaleTextFunc();\n        const emptyMessage = localeTextFunc('valueColumnsEmptyMessage', 'Drag here to aggregate');\n        const title = localeTextFunc('values', 'Values');\n\n        super.init({\n            icon: _.createIconNoSpan('valuePanel', this.gridOptionsService, null)!,\n            emptyMessage: emptyMessage,\n            title: title\n        });\n\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.refreshGui.bind(this));\n    }\n\n    protected getAriaLabel(): string {\n        const translate = this.localeService.getLocaleTextFunc();\n        const label = translate('ariaValuesDropZonePanelLabel', 'Values');\n\n        return label;\n    }\n\n    public getTooltipParams(): WithoutGridCommon<ITooltipParams> {\n        const res = super.getTooltipParams();\n        res.location = 'valueColumnsList';\n        return res;\n    }\n\n    protected getIconName(): string {\n        return this.isPotentialDndItems() ? DragAndDropService.ICON_AGGREGATE : DragAndDropService.ICON_NOT_ALLOWED;\n    }\n\n    protected isItemDroppable(column: Column, draggingEvent: DraggingEvent): boolean {\n        // we never allow grouping of secondary columns\n        if (this.gridOptionsService.get('functionsReadOnly') || !column.isPrimary()) { return false; }\n\n        return column.isAllowValue() && (!column.isValueActive() || this.isSourceEventFromTarget(draggingEvent));\n    }\n\n    protected updateItems(columns: Column[]): void {\n        if (this.gridOptionsService.get('functionsPassive')) {\n            const event: WithoutGridCommon<ColumnValueChangeRequestEvent> = {\n                type: Events.EVENT_COLUMN_VALUE_CHANGE_REQUEST,\n                columns: columns\n            };\n            this.eventService.dispatchEvent(event);\n        } else {\n            this.columnModel.setValueColumns(columns, \"toolPanelUi\");\n        }\n    }\n\n    protected getExistingItems(): Column[] {\n        return this.columnModel.getValueColumns();\n    }\n}\n"],
  "mappings": "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",
  "names": ["_", "Autowired", "Bean", "BeanStub", "RowNode", "BeanStub", "_", "RowNode", "node", "parent", "level", "Autowired", "Bean", "Autowired", "Bean", "BeanStub", "_", "BeanStub", "_", "uniqueValues", "key", "_a", "Autowired", "Bean", "Autowired", "Bean", "BeanStub", "_", "BeanStub", "_", "Autowired", "Bean", "Bean", "BeanStub", "PostConstruct", "_", "BeanStub", "_", "PostConstruct", "Bean", "Autowired", "Component", "Events", "PostConstruct", "_", "_", "DragAndDropService", "Events", "PostConstruct", "Autowired", "Events", "DragSourceType", "Autowired", "Events", "Column", "_", "Column", "_", "Events", "Autowired", "Events", "DragSourceType", "Autowired", "_", "Events", "DragAndDropService", "PostConstruct", "_", "DragAndDropService", "Events", "PostConstruct", "_", "Events", "DragAndDropService", "PostConstruct", "Component", "Events", "_", "Autowired", "PostConstruct", "Autowired", "Bean", "BeanStub", "BeanStub", "params", "_a", "Autowired", "Bean", "_", "Autowired", "Events", "PostConstruct", "RefSelector", "Events", "_", "_a", "Autowired", "RefSelector", "PostConstruct", "_", "AgPromise", "Autowired", "Column", "Component", "RefSelector", "Component", "AgPromise", "_", "Column", "Autowired", "RefSelector", "_", "DragAndDropService", "Events", "PostConstruct", "_", "Events", "DragAndDropService", "PostConstruct"]
}
