{"version":3,"sources":["../../../src/ts/rendering/features/stickyRowFeature.ts"],"names":[],"mappings":"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","file":"stickyRowFeature.js","sourcesContent":["import { RowNode } from \"../../entities/rowNode\";\nimport { BeanStub } from \"../../context/beanStub\";\nimport { RowCtrl } from \"../row/rowCtrl\";\nimport { RowCtrlMap, RowRenderer } from \"../rowRenderer\";\nimport { Autowired, PostConstruct } from \"../../context/context\";\nimport { IRowModel } from \"../../interfaces/iRowModel\";\nimport { GridBodyCtrl } from \"../../gridBodyComp/gridBodyCtrl\";\nimport { CtrlsService } from \"../../ctrlsService\";\nimport { last } from \"../../utils/array\";\n\nexport class StickyRowFeature extends BeanStub {\n\n    @Autowired(\"rowModel\") private rowModel: IRowModel;\n    @Autowired(\"rowRenderer\") private rowRenderer: RowRenderer;\n    @Autowired(\"ctrlsService\") private ctrlsService: CtrlsService;\n\n    private stickyRowCtrls: RowCtrl[] = [];\n    private gridBodyCtrl: GridBodyCtrl;\n    private containerHeight = 0;\n\n    constructor(\n        private readonly createRowCon: (rowNode: RowNode, animate: boolean, afterScroll: boolean) => RowCtrl,\n        private readonly destroyRowCtrls: (rowCtrlsMap: RowCtrlMap | null | undefined, animate: boolean) => void\n    ) {\n        super();\n    }\n\n    @PostConstruct\n    private postConstruct(): void {\n        this.ctrlsService.whenReady(params => {\n            this.gridBodyCtrl = params.gridBodyCtrl;\n        });\n    }\n\n    public getStickyRowCtrls(): RowCtrl[] {\n        return this.stickyRowCtrls;\n    }\n\n    public checkStickyRows(): void {\n        let height = 0;\n\n        if (!this.gridOptionsWrapper.isGroupRowsSticky()) {\n            this.refreshNodesAndContainerHeight([], height);\n            return;\n        }\n\n        const stickyRows: RowNode[] = [];\n        const firstPixel = this.rowRenderer.getFirstVisibleVerticalPixel();\n\n        const addStickyRow = (stickyRow: RowNode) => {\n            stickyRows.push(stickyRow);\n\n            let lastAncester = stickyRow;\n            while (lastAncester.expanded) {\n                lastAncester = last(lastAncester.childrenAfterSort!);\n            }\n            const lastChildBottom = lastAncester.rowTop! + lastAncester.rowHeight!;\n            const stickRowBottom = firstPixel + height + stickyRow.rowHeight!;\n            if (lastChildBottom < stickRowBottom) {\n                stickyRow.stickyRowTop = height + (lastChildBottom - stickRowBottom);\n            } else {\n                stickyRow.stickyRowTop = height;\n            }\n\n            height = 0;\n            stickyRows.forEach(rowNode => {\n                const thisRowLastPx = rowNode.stickyRowTop + rowNode.rowHeight!;\n                if (height < thisRowLastPx) {\n                    height = thisRowLastPx;\n                }\n            });\n\n        };\n\n        while (true) {\n            const firstPixelAfterStickyRows = firstPixel + height;\n            const firstIndex = this.rowModel.getRowIndexAtPixel(firstPixelAfterStickyRows);\n            const firstRow = this.rowModel.getRow(firstIndex);\n\n            if (firstRow == null) {  break; }\n\n            // only happens when pivoting, and we are showing root node\n            if (firstRow.level < 0) { break; }\n\n            const parents: RowNode[] = [];\n            let p = firstRow.parent!;\n            while (p.level >= 0) {\n                parents.push(p);\n                p = p.parent!;\n            }\n            const firstMissingParent = parents.reverse().find(parent => stickyRows.indexOf(parent) < 0);\n            if (firstMissingParent) {\n                addStickyRow(firstMissingParent);\n                continue;\n            }\n\n            // if first row is an open group, and practically shown, it needs\n            // to be stuck\n            if (firstRow.group && firstRow.expanded && !firstRow.footer && firstRow.rowTop! < firstPixelAfterStickyRows) {\n                addStickyRow(firstRow);\n                continue;\n            }\n\n            break;\n        }\n\n        this.refreshNodesAndContainerHeight(stickyRows, height);\n    }\n\n    private refreshNodesAndContainerHeight(allStickyNodes: RowNode[], height: number): void {\n        const removedCtrls = this.stickyRowCtrls.filter(ctrl => allStickyNodes.indexOf(ctrl.getRowNode()) === -1);\n        const addedNodes = allStickyNodes.filter(rowNode => this.stickyRowCtrls.findIndex(ctrl => ctrl.getRowNode() === rowNode) === -1);\n\n        const ctrlsToDestroy: RowCtrlMap = {};\n        removedCtrls.forEach(removedCtrl => {\n            ctrlsToDestroy[removedCtrl.getRowNode().id!] = removedCtrl;\n            this.stickyRowCtrls = this.stickyRowCtrls.filter(ctrl => ctrl !== removedCtrl);\n        });\n\n        for (const ctrl of Object.values(ctrlsToDestroy)) {\n            ctrl.getRowNode().sticky = false;\n        }\n\n        this.destroyRowCtrls(ctrlsToDestroy, false);\n\n        const newCtrls = addedNodes.map(rowNode => {\n            rowNode.sticky = true;\n            return this.createRowCon(rowNode, false, false);\n        });\n\n        this.stickyRowCtrls.push(...newCtrls);\n        this.stickyRowCtrls.forEach(ctrl => ctrl.setRowTop(ctrl.getRowNode().stickyRowTop));\n        this.stickyRowCtrls.sort((a, b) => b.getRowNode().rowIndex! - a.getRowNode().rowIndex!);\n\n        if (this.containerHeight !== height) {\n            this.containerHeight = height;\n            this.gridBodyCtrl.setStickyTopHeight(height);\n        }\n    }\n}"]}