{
  "version": 3,
  "sources": ["../../src/infiniteRowModelModule.ts", "../../src/infiniteRowModel/infiniteRowModel.ts", "../../src/infiniteRowModel/infiniteCache.ts", "../../src/infiniteRowModel/infiniteBlock.ts", "../../src/version.ts"],
  "sourcesContent": ["import { Module, ModuleNames } from \"@ag-grid-community/core\";\nimport { InfiniteRowModel } from \"./infiniteRowModel/infiniteRowModel\";\nimport { VERSION } from \"./version\";\n\nexport const InfiniteRowModelModule: Module = {\n    version: VERSION,\n    moduleName: ModuleNames.InfiniteRowModelModule,\n    rowModel: 'infinite',\n    beans: [InfiniteRowModel],\n};\n", "import {\n    _,\n    Autowired,\n    Bean,\n    BeanStub,\n    Events,\n    FilterManager,\n    IDatasource,\n    ModelUpdatedEvent,\n    NumberSequence,\n    PostConstruct,\n    PreDestroy,\n    RowBounds,\n    RowNode,\n    RowNodeBlockLoader,\n    RowRenderer,\n    ISelectionService,\n    SortController,\n    IInfiniteRowModel,\n    WithoutGridCommon,\n    RowModelType\n} from \"@ag-grid-community/core\";\nimport { InfiniteCache, InfiniteCacheParams } from \"./infiniteCache\";\n\n@Bean('rowModel')\nexport class InfiniteRowModel extends BeanStub implements IInfiniteRowModel {\n\n    @Autowired('filterManager') private readonly filterManager: FilterManager;\n    @Autowired('sortController') private readonly sortController: SortController;\n    @Autowired('selectionService') private readonly selectionService: ISelectionService;\n    @Autowired('rowRenderer') private readonly rowRenderer: RowRenderer;\n    @Autowired('rowNodeBlockLoader') private readonly rowNodeBlockLoader: RowNodeBlockLoader;\n\n    private infiniteCache: InfiniteCache | null | undefined;\n    private datasource: IDatasource | null | undefined;\n    private rowHeight: number;\n    private cacheParams: InfiniteCacheParams;\n\n    public getRowBounds(index: number): RowBounds {\n        return {\n            rowHeight: this.rowHeight,\n            rowTop: this.rowHeight * index\n        };\n    }\n\n    // we don't implement as lazy row heights is not supported in this row model\n    public ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number): boolean {\n        return false;\n    }\n\n    @PostConstruct\n    public init(): void {\n        if (!this.gridOptionsService.isRowModelType('infinite')) {\n            return;\n        }\n\n        this.rowHeight = this.gridOptionsService.getRowHeightAsNumber();\n\n        this.addEventListeners();\n\n        this.addDestroyFunc(() => this.destroyCache());\n\n        this.verifyProps();\n    }\n\n    private verifyProps(): void {\n        if (this.gridOptionsService.exists('initialGroupOrderComparator')) {\n            _.warnOnce('initialGroupOrderComparator cannot be used with Infinite Row Model as sorting is done on the server side');\n        }\n    }\n\n    public start(): void {\n        this.setDatasource(this.gridOptionsService.get('datasource'));\n    }\n\n    @PreDestroy\n    private destroyDatasource(): void {\n        if (this.datasource) {\n            this.getContext().destroyBean(this.datasource);\n            this.rowRenderer.datasourceChanged();\n            this.datasource = null;\n        }\n    }\n\n    private addEventListeners(): void {\n        this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, this.onColumnEverything.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_STORE_UPDATED, this.onCacheUpdated.bind(this));\n        this.addManagedPropertyListener('datasource', () => this.setDatasource(this.gridOptionsService.get('datasource')));\n        this.addManagedPropertyListener('cacheBlockSize', () => this.resetCache());\n        this.addManagedPropertyListener('rowHeight', () => {\n            this.rowHeight = this.gridOptionsService.getRowHeightAsNumber();\n            this.cacheParams.rowHeight = this.rowHeight;\n            this.updateRowHeights();\n        });\n    }\n\n    private onFilterChanged(): void {\n        this.reset();\n    }\n\n    private onSortChanged(): void {\n        this.reset();\n    }\n\n    private onColumnEverything(): void {\n        let resetRequired;\n        // if cache params, we require reset only if sort model has changed. we don't need to check\n        // for filter model, as the filter manager will fire an event when columns change that result\n        // in the filter changing.\n        if (this.cacheParams) {\n            resetRequired = this.isSortModelDifferent();\n        } else {\n            // if no cacheParams, means first time creating the cache, so always create one\n            resetRequired = true;\n        }\n        if (resetRequired) {\n            this.reset();\n        }\n    }\n\n    private isSortModelDifferent(): boolean {\n        return !_.jsonEquals(this.cacheParams.sortModel, this.sortController.getSortModel());\n    }\n\n    public getType(): RowModelType {\n        return 'infinite';\n    }\n\n    public setDatasource(datasource: IDatasource | undefined): void {\n        this.destroyDatasource();\n        this.datasource = datasource;\n\n        // only reset if we have a valid datasource to working with\n        if (datasource) {\n            this.reset();\n        }\n    }\n\n    public isEmpty(): boolean {\n        return !this.infiniteCache;\n    }\n\n    public isRowsToRender(): boolean {\n        return !!this.infiniteCache;\n    }\n\n    public getNodesInRangeForSelection(firstInRange: RowNode, lastInRange: RowNode): RowNode[] {\n        return this.infiniteCache ? this.infiniteCache.getRowNodesInRange(firstInRange, lastInRange) : [];\n    }\n\n    private reset() {\n        // important to return here, as the user could be setting filter or sort before\n        // data-source is set\n        if (!this.datasource) {\n            return;\n        }\n\n        // if user is providing id's, then this means we can keep the selection between datasource hits,\n        // as the rows will keep their unique id's even if, for example, server side sorting or filtering\n        // is done.\n        const getRowIdFunc = this.gridOptionsService.getCallback('getRowId');\n        const userGeneratingIds = getRowIdFunc != null;\n\n        if (!userGeneratingIds) {\n            this.selectionService.reset('rowDataChanged');\n        }\n\n        this.resetCache();\n    }\n\n    private createModelUpdatedEvent(): WithoutGridCommon<ModelUpdatedEvent> {\n        return {\n            type: Events.EVENT_MODEL_UPDATED,\n            // not sure if these should all be false - noticed if after implementing,\n            // maybe they should be true?\n            newPage: false,\n            newPageSize: false,\n            newData: false,\n            keepRenderedRows: true,\n            animate: false\n        };\n    }\n\n    private resetCache(): void {\n        // if not first time creating a cache, need to destroy the old one\n        this.destroyCache();\n\n        this.cacheParams = {\n            // the user provided datasource\n            datasource: this.datasource,\n\n            // sort and filter model\n            filterModel: this.filterManager.getFilterModel(),\n            sortModel: this.sortController.getSortModel(),\n\n            rowNodeBlockLoader: this.rowNodeBlockLoader,\n\n            // properties - this way we take a snapshot of them, so if user changes any, they will be\n            // used next time we create a new cache, which is generally after a filter or sort change,\n            // or a new datasource is set\n            initialRowCount: this.gridOptionsService.get('infiniteInitialRowCount'),\n            maxBlocksInCache: this.gridOptionsService.get('maxBlocksInCache'),\n            rowHeight: this.gridOptionsService.getRowHeightAsNumber(),\n\n            // if user doesn't provide overflow, we use default overflow of 1, so user can scroll past\n            // the current page and request first row of next page\n            overflowSize: this.gridOptionsService.get('cacheOverflowSize'),\n\n            // page size needs to be 1 or greater. having it at 1 would be silly, as you would be hitting the\n            // server for one page at a time. so the default if not specified is 100.\n            blockSize: this.gridOptionsService.get('cacheBlockSize'),\n\n            // the cache could create this, however it is also used by the pages, so handy to create it\n            // here as the settings are also passed to the pages\n            lastAccessedSequence: new NumberSequence()\n        } as InfiniteCacheParams;\n\n        this.infiniteCache = this.createBean(new InfiniteCache(this.cacheParams));\n\n        this.eventService.dispatchEventOnce({\n            type: Events.EVENT_ROW_COUNT_READY\n        });\n\n        const event = this.createModelUpdatedEvent();\n        this.eventService.dispatchEvent(event);\n    }\n\n    private updateRowHeights() {\n        this.forEachNode(node => {\n            node.setRowHeight(this.rowHeight);\n            node.setRowTop(this.rowHeight * node.rowIndex!);\n        });\n\n        const event = this.createModelUpdatedEvent();\n        this.eventService.dispatchEvent(event);\n    }\n\n    private destroyCache(): void {\n        if (this.infiniteCache) {\n            this.infiniteCache = this.destroyBean(this.infiniteCache);\n        }\n    }\n\n    private onCacheUpdated(): void {\n        const event = this.createModelUpdatedEvent();\n        this.eventService.dispatchEvent(event);\n    }\n\n    public getRow(rowIndex: number): RowNode | undefined {\n        if (!this.infiniteCache) { return undefined; }\n        if (rowIndex >= this.infiniteCache.getRowCount()) { return undefined; }\n        return this.infiniteCache.getRow(rowIndex);\n    }\n\n    public getRowNode(id: string): RowNode | undefined {\n        let result: RowNode | undefined;\n        this.forEachNode(rowNode => {\n            if (rowNode.id === id) {\n                result = rowNode;\n            }\n        });\n        return result;\n    }\n\n    public forEachNode(callback: (rowNode: RowNode, index: number) => void): void {\n        if (this.infiniteCache) {\n            this.infiniteCache.forEachNodeDeep(callback);\n        }\n    }\n\n    public getTopLevelRowCount(): number {\n        return this.getRowCount();\n    }\n\n    public getTopLevelRowDisplayedIndex(topLevelIndex: number): number {\n        return topLevelIndex;\n    }\n\n    public getRowIndexAtPixel(pixel: number): number {\n        if (this.rowHeight !== 0) { // avoid divide by zero error\n            const rowIndexForPixel = Math.floor(pixel / this.rowHeight);\n            const lastRowIndex = this.getRowCount() - 1;\n            if (rowIndexForPixel > lastRowIndex) {\n                return lastRowIndex;\n            }\n            return rowIndexForPixel;\n        }\n        return 0;\n    }\n\n    public getRowCount(): number {\n        return this.infiniteCache ? this.infiniteCache.getRowCount() : 0;\n    }\n\n    public isRowPresent(rowNode: RowNode): boolean {\n        const foundRowNode = this.getRowNode(rowNode.id!);\n        return !!foundRowNode;\n    }\n\n    public refreshCache(): void {\n        if (this.infiniteCache) {\n            this.infiniteCache.refreshCache();\n        }\n    }\n\n    public purgeCache(): void {\n        if (this.infiniteCache) {\n            this.infiniteCache.purgeCache();\n        }\n    }\n\n    // for iRowModel\n    public isLastRowIndexKnown(): boolean {\n        if (this.infiniteCache) {\n            return this.infiniteCache.isLastRowIndexKnown();\n        }\n        return false;\n    }\n\n    public setRowCount(rowCount: number, lastRowIndexKnown?: boolean): void {\n        if (this.infiniteCache) {\n            this.infiniteCache.setRowCount(rowCount, lastRowIndexKnown);\n        }\n    }\n}\n", "import {\n    Autowired,\n    BeanStub,\n    StoreUpdatedEvent,\n    Events,\n    IDatasource,\n    Logger,\n    LoggerFactory,\n    NumberSequence,\n    PreDestroy,\n    Qualifier,\n    RowNode,\n    RowNodeBlockLoader,\n    RowRenderer,\n    _,\n    FocusService,\n    SortModelItem,\n    WithoutGridCommon\n} from \"@ag-grid-community/core\";\nimport { InfiniteBlock } from \"./infiniteBlock\";\n\nexport interface InfiniteCacheParams {\n    datasource: IDatasource;\n    initialRowCount: number;\n    blockSize?: number;\n    overflowSize: number;\n    sortModel: SortModelItem[];\n    filterModel: any;\n    maxBlocksInCache?: number;\n    rowHeight: number;\n    lastAccessedSequence: NumberSequence;\n    rowNodeBlockLoader?: RowNodeBlockLoader;\n    dynamicRowHeight: boolean;\n}\n\nexport class InfiniteCache extends BeanStub {\n\n    // this property says how many empty blocks should be in a cache, eg if scrolls down fast and creates 10\n    // blocks all for loading, the grid will only load the last 2 - it will assume the blocks the user quickly\n    // scrolled over are not needed to be loaded.\n    private static MAX_EMPTY_BLOCKS_TO_KEEP = 2;\n\n    @Autowired('rowRenderer') protected rowRenderer: RowRenderer;\n    @Autowired(\"focusService\") private focusService: FocusService;\n\n    private readonly params: InfiniteCacheParams;\n\n    private rowCount: number;\n    private lastRowIndexKnown = false;\n\n    private blocks: { [blockNumber: string]: InfiniteBlock; } = {};\n    private blockCount = 0;\n\n    private logger: Logger;\n\n    constructor(params: InfiniteCacheParams) {\n        super();\n        this.rowCount = params.initialRowCount;\n        this.params = params;\n    }\n\n    private setBeans(@Qualifier('loggerFactory') loggerFactory: LoggerFactory) {\n        this.logger = loggerFactory.create('InfiniteCache');\n    }\n\n    // the rowRenderer will not pass dontCreatePage, meaning when rendering the grid,\n    // it will want new pages in the cache as it asks for rows. only when we are inserting /\n    // removing rows via the api is dontCreatePage set, where we move rows between the pages.\n    public getRow(rowIndex: number, dontCreatePage = false): RowNode | undefined {\n        const blockId = Math.floor(rowIndex / this.params.blockSize!);\n        let block = this.blocks[blockId];\n\n        if (!block) {\n            if (dontCreatePage) {\n                return undefined;\n            }\n            block = this.createBlock(blockId);\n        }\n\n        return block.getRow(rowIndex);\n    }\n\n    private createBlock(blockNumber: number): InfiniteBlock {\n        const newBlock = this.createBean(new InfiniteBlock(blockNumber, this, this.params));\n\n        this.blocks[newBlock.getId()] = newBlock;\n        this.blockCount++;\n\n        this.purgeBlocksIfNeeded(newBlock);\n\n        this.params.rowNodeBlockLoader!.addBlock(newBlock);\n\n        return newBlock;\n    }\n\n    // we have this on infinite row model only, not server side row model,\n    // because for server side, it would leave the children in inconsistent\n    // state - eg if a node had children, but after the refresh it had data\n    // for a different row, then the children would be with the wrong row node.\n    public refreshCache(): void {\n        const nothingToRefresh = this.blockCount == 0;\n        if (nothingToRefresh) {\n            this.purgeCache();\n            return;\n        }\n\n        this.getBlocksInOrder().forEach(block => block.setStateWaitingToLoad());\n        this.params.rowNodeBlockLoader!.checkBlockToLoad();\n    }\n\n    @PreDestroy\n    private destroyAllBlocks(): void {\n        this.getBlocksInOrder().forEach(block => this.destroyBlock(block));\n    }\n\n    public getRowCount(): number {\n        return this.rowCount;\n    }\n\n    public isLastRowIndexKnown(): boolean {\n        return this.lastRowIndexKnown;\n    }\n\n    // block calls this, when page loaded\n    public pageLoaded(block: InfiniteBlock, lastRow?: number): void {\n        // if we are not active, then we ignore all events, otherwise we could end up getting the\n        // grid to refresh even though we are no longer the active cache\n        if (!this.isAlive()) {\n            return;\n        }\n\n        this.logger.log(`onPageLoaded: page = ${block.getId()}, lastRow = ${lastRow}`);\n\n        this.checkRowCount(block, lastRow);\n        // we fire cacheUpdated even if the row count has not changed, as some items need updating even\n        // if no new rows to render. for example the pagination panel has '?' as the total rows when loading\n        // is underway, which would need to get updated when loading finishes.\n        this.onCacheUpdated();\n    }\n\n    private purgeBlocksIfNeeded(blockToExclude: InfiniteBlock): void {\n        // we exclude checking for the page just created, as this has yet to be accessed and hence\n        // the lastAccessed stamp will not be updated for the first time yet\n        const blocksForPurging = this.getBlocksInOrder().filter(b => b != blockToExclude);\n        const lastAccessedComparator = (a: InfiniteBlock, b: InfiniteBlock) => b.getLastAccessed() - a.getLastAccessed();\n        blocksForPurging.sort(lastAccessedComparator);\n\n        // we remove (maxBlocksInCache - 1) as we already excluded the 'just created' page.\n        // in other words, after the splice operation below, we have taken out the blocks\n        // we want to keep, which means we are left with blocks that we can potentially purge\n        const maxBlocksProvided = this.params.maxBlocksInCache! > 0;\n        const blocksToKeep = maxBlocksProvided ? this.params.maxBlocksInCache! - 1 : null;\n        const emptyBlocksToKeep = InfiniteCache.MAX_EMPTY_BLOCKS_TO_KEEP - 1;\n\n        blocksForPurging.forEach((block: InfiniteBlock, index: number) => {\n            const purgeBecauseBlockEmpty = block.getState() === InfiniteBlock.STATE_WAITING_TO_LOAD && index >= emptyBlocksToKeep;\n\n            const purgeBecauseCacheFull = maxBlocksProvided ? index >= blocksToKeep! : false;\n\n            if (purgeBecauseBlockEmpty || purgeBecauseCacheFull) {\n\n                // if the block currently has rows been displayed, then don't remove it either.\n                // this can happen if user has maxBlocks=2, and blockSize=5 (thus 10 max rows in cache)\n                // but the screen is showing 20 rows, so at least 4 blocks are needed.\n                if (this.isBlockCurrentlyDisplayed(block)) { return; }\n\n                // don't want to loose keyboard focus, so keyboard navigation can continue. so keep focused blocks.\n                if (this.isBlockFocused(block)) { return; }\n\n                // at this point, block is not needed, so burn baby burn\n                this.removeBlockFromCache(block);\n            }\n\n        });\n    }\n\n    private isBlockFocused(block: InfiniteBlock): boolean {\n        const focusedCell = this.focusService.getFocusCellToUseAfterRefresh();\n        if (!focusedCell) { return false; }\n        if (focusedCell.rowPinned != null) { return false; }\n\n        const blockIndexStart = block.getStartRow();\n        const blockIndexEnd = block.getEndRow();\n\n        const hasFocus = focusedCell.rowIndex >= blockIndexStart && focusedCell.rowIndex < blockIndexEnd;\n        return hasFocus;\n    }\n\n    private isBlockCurrentlyDisplayed(block: InfiniteBlock): boolean {\n        const startIndex = block.getStartRow();\n        const endIndex = block.getEndRow() - 1;\n        return this.rowRenderer.isRangeInRenderedViewport(startIndex, endIndex);\n    }\n\n    private removeBlockFromCache(blockToRemove: InfiniteBlock): void {\n        if (!blockToRemove) { return; }\n\n        this.destroyBlock(blockToRemove);\n\n        // we do not want to remove the 'loaded' event listener, as the\n        // concurrent loads count needs to be updated when the load is complete\n        // if the purged page is in loading state\n    }\n\n    private checkRowCount(block: InfiniteBlock, lastRow?: number): void {\n        // if client provided a last row, we always use it, as it could change between server calls\n        // if user deleted data and then called refresh on the grid.\n        if (typeof lastRow === 'number' && lastRow >= 0) {\n            this.rowCount = lastRow;\n            this.lastRowIndexKnown = true;\n        } else if (!this.lastRowIndexKnown) {\n            // otherwise, see if we need to add some virtual rows\n            const lastRowIndex = (block.getId() + 1) * this.params.blockSize!;\n            const lastRowIndexPlusOverflow = lastRowIndex + this.params.overflowSize;\n\n            if (this.rowCount < lastRowIndexPlusOverflow) {\n                this.rowCount = lastRowIndexPlusOverflow;\n            }\n        }\n    }\n\n    public setRowCount(rowCount: number, lastRowIndexKnown?: boolean): void {\n        this.rowCount = rowCount;\n\n        // if undefined is passed, we do not set this value, if one of {true,false}\n        // is passed, we do set the value.\n        if (_.exists(lastRowIndexKnown)) {\n            this.lastRowIndexKnown = lastRowIndexKnown;\n        }\n\n        // if we are still searching, then the row count must not end at the end\n        // of a particular page, otherwise the searching will not pop into the\n        // next page\n        if (!this.lastRowIndexKnown) {\n            if (this.rowCount % this.params.blockSize! === 0) {\n                this.rowCount++;\n            }\n        }\n\n        this.onCacheUpdated();\n    }\n\n    public forEachNodeDeep(callback: (rowNode: RowNode, index: number) => void): void {\n        const sequence = new NumberSequence();\n        this.getBlocksInOrder().forEach(block => block.forEachNode(callback, sequence, this.rowCount));\n    }\n\n    public getBlocksInOrder(): InfiniteBlock[] {\n        // get all page id's as NUMBERS (not strings, as we need to sort as numbers) and in descending order\n        const blockComparator = (a: InfiniteBlock, b: InfiniteBlock) => a.getId() - b.getId();\n        const blocks = _.getAllValuesInObject(this.blocks).sort(blockComparator);\n        return blocks;\n    }\n\n    private destroyBlock(block: InfiniteBlock): void {\n        delete this.blocks[block.getId()];\n        this.destroyBean(block);\n        this.blockCount--;\n        this.params.rowNodeBlockLoader!.removeBlock(block);\n    }\n\n    // gets called 1) row count changed 2) cache purged 3) items inserted\n    private onCacheUpdated(): void {\n        if (this.isAlive()) {\n\n            // if the virtualRowCount is shortened, then it's possible blocks exist that are no longer\n            // in the valid range. so we must remove these. this can happen if user explicitly sets\n            // the virtual row count, or the datasource returns a result and sets lastRow to something\n            // less than virtualRowCount (can happen if user scrolls down, server reduces dataset size).\n            this.destroyAllBlocksPastVirtualRowCount();\n\n            // this results in both row models (infinite and server side) firing ModelUpdated,\n            // however server side row model also updates the row indexes first\n            const event: WithoutGridCommon<StoreUpdatedEvent> = {\n                type: Events.EVENT_STORE_UPDATED\n            };\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    private destroyAllBlocksPastVirtualRowCount(): void {\n        const blocksToDestroy: InfiniteBlock[] = [];\n        this.getBlocksInOrder().forEach(block => {\n            const startRow = block.getId() * this.params.blockSize!;\n            if (startRow >= this.rowCount) {\n                blocksToDestroy.push(block);\n            }\n        });\n        if (blocksToDestroy.length > 0) {\n            blocksToDestroy.forEach(block => this.destroyBlock(block));\n        }\n    }\n\n    public purgeCache(): void {\n        this.getBlocksInOrder().forEach(block => this.removeBlockFromCache(block));\n        this.lastRowIndexKnown = false;\n        // if zero rows in the cache, we need to get the SSRM to start asking for rows again.\n        // otherwise if set to zero rows last time, and we don't update the row count, then after\n        // the purge there will still be zero rows, meaning the SSRM won't request any rows.\n        // to kick things off, at least one row needs to be asked for.\n        if (this.rowCount === 0) {\n            this.rowCount = this.params.initialRowCount;\n        }\n\n        this.onCacheUpdated();\n    }\n\n    public getRowNodesInRange(firstInRange: RowNode, lastInRange: RowNode): RowNode[] {\n        const result: RowNode[] = [];\n\n        let lastBlockId = -1;\n        let inActiveRange = false;\n        const numberSequence: NumberSequence = new NumberSequence();\n\n        // if only one node passed, we start the selection at the top\n        if (_.missing(firstInRange)) {\n            inActiveRange = true;\n        }\n\n        let foundGapInSelection = false;\n\n        this.getBlocksInOrder().forEach(block => {\n            if (foundGapInSelection) { return; }\n\n            if (inActiveRange && (lastBlockId + 1 !== block.getId())) {\n                foundGapInSelection = true;\n                return;\n            }\n\n            lastBlockId = block.getId();\n\n            block.forEachNode(rowNode => {\n                const hitFirstOrLast = rowNode === firstInRange || rowNode === lastInRange;\n                if (inActiveRange || hitFirstOrLast) {\n                    result.push(rowNode);\n                }\n\n                if (hitFirstOrLast) {\n                    inActiveRange = !inActiveRange;\n                }\n\n            }, numberSequence, this.rowCount);\n        });\n\n        // inActiveRange will be still true if we never hit the second rowNode\n        const invalidRange = foundGapInSelection || inActiveRange;\n        return invalidRange ? [] : result;\n    }\n}\n", "import {\n    _,\n    IGetRowsParams,\n    NumberSequence,\n    PostConstruct,\n    PreDestroy,\n    RowNode,\n    RowNodeBlock,\n    LoadSuccessParams,\n    Beans,\n    Autowired\n} from \"@ag-grid-community/core\";\nimport { InfiniteCache, InfiniteCacheParams } from \"./infiniteCache\";\n\nexport class InfiniteBlock extends RowNodeBlock {\n    @Autowired('beans') private beans: Beans;\n\n    private readonly startRow: number;\n    private readonly endRow: number;\n    private readonly parentCache: InfiniteCache;\n\n    private params: InfiniteCacheParams;\n\n    private lastAccessed: number;\n\n    public rowNodes: RowNode[];\n\n    constructor(id: number, parentCache: InfiniteCache, params: InfiniteCacheParams) {\n        super(id);\n\n        this.parentCache = parentCache;\n        this.params = params;\n\n        // we don't need to calculate these now, as the inputs don't change,\n        // however it makes the code easier to read if we work them out up front\n        this.startRow = id * params.blockSize!;\n        this.endRow = this.startRow + params.blockSize!;\n    }\n\n    @PostConstruct\n    protected postConstruct(): void {\n        this.createRowNodes();\n    }\n\n    public getBlockStateJson(): {id: string, state: any} {\n        return {\n            id: '' + this.getId(),\n            state: {\n                blockNumber: this.getId(),\n                startRow: this.getStartRow(),\n                endRow: this.getEndRow(),\n                pageStatus: this.getState()\n            }\n        };\n    }\n\n    protected setDataAndId(rowNode: RowNode, data: any, index: number): void {\n        if (_.exists(data)) {\n            // this means if the user is not providing id's we just use the\n            // index for the row. this will allow selection to work (that is based\n            // on index) as long user is not inserting or deleting rows,\n            // or wanting to keep selection between server side sorting or filtering\n            rowNode.setDataAndId(data, index.toString());\n        } else {\n            rowNode.setDataAndId(undefined, undefined);\n        }\n    }\n\n    protected loadFromDatasource(): void {\n        const params = this.createLoadParams();\n        if (_.missing(this.params.datasource.getRows)) {\n            console.warn(`AG Grid: datasource is missing getRows method`);\n            return;\n        }\n\n        // put in timeout, to force result to be async\n        window.setTimeout(() => {\n            this.params.datasource.getRows(params);\n        }, 0);\n    }\n\n    protected processServerFail(): void {\n        // todo - this method has better handling in SSRM\n    }\n\n    protected createLoadParams(): any {\n        // PROBLEM . . . . when the user sets sort via colDef.sort, then this code\n        // is executing before the sort is set up, so server is not getting the sort\n        // model. need to change with regards order - so the server side request is\n        // AFTER thus it gets the right sort model.\n        const params: IGetRowsParams = {\n            startRow: this.getStartRow(),\n            endRow: this.getEndRow(),\n            successCallback: this.pageLoaded.bind(this, this.getVersion()),\n            failCallback: this.pageLoadFailed.bind(this, this.getVersion()),\n            sortModel: this.params.sortModel,\n            filterModel: this.params.filterModel,\n            context: this.gridOptionsService.getGridCommonParams().context\n        };\n        return params;\n    }\n\n    public forEachNode(callback: (rowNode: RowNode, index: number) => void,\n                       sequence: NumberSequence,\n                       rowCount: number): void {\n        this.rowNodes.forEach((rowNode: RowNode, index: number) => {\n            const rowIndex = this.startRow + index;\n            if (rowIndex < rowCount) {\n                callback(rowNode, sequence.next());\n            }\n        });\n    }\n\n    public getLastAccessed(): number {\n        return this.lastAccessed;\n    }\n\n    public getRow(rowIndex: number, dontTouchLastAccessed = false): RowNode {\n        if (!dontTouchLastAccessed) {\n            this.lastAccessed = this.params.lastAccessedSequence.next();\n        }\n        const localIndex = rowIndex - this.startRow;\n        return this.rowNodes[localIndex];\n    }\n\n    public getStartRow(): number {\n        return this.startRow;\n    }\n\n    public getEndRow(): number {\n        return this.endRow;\n    }\n\n    // creates empty row nodes, data is missing as not loaded yet\n    protected createRowNodes(): void {\n        this.rowNodes = [];\n        for (let i = 0; i < this.params.blockSize!; i++) {\n            const rowIndex = this.startRow + i;\n\n            const rowNode = new RowNode(this.beans);\n\n            rowNode.setRowHeight(this.params.rowHeight);\n            rowNode.uiLevel = 0;\n            rowNode.setRowIndex(rowIndex);\n            rowNode.setRowTop(this.params.rowHeight * rowIndex);\n\n            this.rowNodes.push(rowNode);\n        }\n    }\n\n    protected processServerResult(params: LoadSuccessParams): void {\n        this.rowNodes.forEach((rowNode: RowNode, index: number) => {\n            const data = params.rowData ? params.rowData[index] : undefined;\n\n            if (!rowNode.id && rowNode.alreadyRendered && data) {\n                // if the node had no id and was rendered, but we have data for it now, then\n                // destroy the old row and copy its position into new row. This prevents an additional\n                // set of events being fired as the row renderer tries to understand the changing id\n                this.rowNodes[index] = new RowNode(this.beans);\n                this.rowNodes[index].setRowIndex(rowNode.rowIndex!);\n                this.rowNodes[index].setRowTop(rowNode.rowTop!);\n                this.rowNodes[index].setRowHeight(rowNode.rowHeight!);\n\n                // clean up the old row\n                rowNode.clearRowTopAndRowIndex();\n            }\n            this.setDataAndId(this.rowNodes[index], data, this.startRow + index);\n        });\n        const finalRowCount = params.rowCount != null && params.rowCount >= 0 ? params.rowCount : undefined;\n        this.parentCache.pageLoaded(this, finalRowCount);\n    }\n\n    @PreDestroy\n    private destroyRowNodes(): void {\n        this.rowNodes.forEach(rowNode => {\n            // this is needed, so row render knows to fade out the row, otherwise it\n            // sees row top is present, and thinks the row should be shown.\n            rowNode.clearRowTopAndRowIndex();\n        });\n    }\n}\n", "// DO NOT UPDATE MANUALLY: Generated from script during build time\nexport const VERSION = '31.2.0';"],
  "mappings": "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",
  "names": ["_", "Autowired", "BeanStub", "Events", "NumberSequence", "PostConstruct", "PreDestroy", "Autowired", "NumberSequence", "PreDestroy", "_", "_", "NumberSequence", "Autowired", "PreDestroy", "BeanStub", "_", "Events", "NumberSequence", "Autowired", "PostConstruct", "PreDestroy"]
}
