{"version":3,"sources":["reactUi/useEffectOnce.tsx"],"names":[],"mappings":";;;AAAA,iCAAoD;AAEvC,QAAA,aAAa,GAAG,CAAC,MAAiC,EAAE,EAAE;IAC/D,MAAM,WAAW,GAAG,cAAM,EAAuB,CAAC;IAClD,MAAM,YAAY,GAAG,cAAM,CAAC,KAAK,CAAC,CAAC;IACnC,MAAM,iBAAiB,GAAG,cAAM,CAAC,KAAK,CAAC,CAAC;IACxC,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,GAAG,gBAAQ,CAAS,CAAC,CAAC,CAAC;IAE1C,IAAI,YAAY,CAAC,OAAO,EAAE;QACxB,iBAAiB,CAAC,OAAO,GAAG,IAAI,CAAC;KAClC;IAED,iBAAS,CAAC,GAAG,EAAE;QACb,4CAA4C;QAC5C,IAAI,CAAC,YAAY,CAAC,OAAO,EAAE;YACzB,WAAW,CAAC,OAAO,GAAG,MAAM,EAAE,CAAC;YAC/B,YAAY,CAAC,OAAO,GAAG,IAAI,CAAC;SAC7B;QAED,iDAAiD;QACjD,MAAM,CAAC,CAAC,GAAG,EAAE,EAAE,CAAC,GAAG,GAAG,CAAC,CAAC,CAAC;QAEzB,OAAO,GAAG,EAAE;YACV,4DAA4D;YAC5D,qCAAqC;YACrC,IAAI,CAAC,iBAAiB,CAAC,OAAO,EAAE;gBAAE,OAAO;aAAE;YAE3C,kEAAkE;YAClE,IAAI,WAAW,CAAC,OAAO,EAAE;gBAAE,WAAW,CAAC,OAAO,EAAE,CAAC;aAAE;QACrD,CAAC,CAAC;IACJ,CAAC,EAAE,EAAE,CAAC,CAAC;AACT,CAAC,CAAC","file":"useEffectOnce.js","sourcesContent":["import { useEffect, useRef, useState } from 'react';\n\nexport const useEffectOnce = (effect: () => void | (() => void)) => {\n    const destroyFunc = useRef<void | (() => void)>();\n    const effectCalled = useRef(false);\n    const renderAfterCalled = useRef(false);\n    const [val, setVal] = useState<number>(0);\n  \n    if (effectCalled.current) {\n      renderAfterCalled.current = true;\n    }\n  \n    useEffect(() => {\n      // only execute the effect first time around\n      if (!effectCalled.current) {\n        destroyFunc.current = effect();\n        effectCalled.current = true;\n      }\n  \n      // this forces one render after the effect is run\n      setVal((val) => val + 1);\n  \n      return () => {\n        // if the comp didn't render since the useEffect was called,\n        // we know it's the dummy React cycle\n        if (!renderAfterCalled.current) { return; }\n\n        // otherwise this is not a dummy destroy, so call the destroy func\n        if (destroyFunc.current) { destroyFunc.current(); }\n      };\n    }, []);\n  };\n"]}