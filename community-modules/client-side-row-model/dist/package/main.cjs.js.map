{
  "version": 3,
  "sources": ["../../src/main.ts", "../../src/clientSideRowModelModule.ts", "../../src/clientSideRowModel/clientSideRowModel.ts", "../../src/clientSideRowModel/clientSideNodeManager.ts", "../../src/clientSideRowModel/filterStage.ts", "../../src/clientSideRowModel/sortStage.ts", "../../src/clientSideRowModel/flattenStage.ts", "../../src/clientSideRowModel/sortService.ts", "../../src/clientSideRowModel/filterService.ts", "../../src/clientSideRowModel/immutableService.ts", "../../src/version.ts"],
  "sourcesContent": ["export { ClientSideRowModelModule } from \"./clientSideRowModelModule\";\n", "import { Module, ModuleNames } from \"@ag-grid-community/core\";\nimport { ClientSideRowModel } from \"./clientSideRowModel/clientSideRowModel\";\nimport { FilterStage } from \"./clientSideRowModel/filterStage\";\nimport { SortStage } from \"./clientSideRowModel/sortStage\";\nimport { FlattenStage } from \"./clientSideRowModel/flattenStage\";\nimport { SortService } from \"./clientSideRowModel/sortService\";\nimport { FilterService } from \"./clientSideRowModel/filterService\";\nimport { ImmutableService } from \"./clientSideRowModel/immutableService\";\nimport { VERSION } from \"./version\";\n\nexport const ClientSideRowModelModule: Module = {\n    version: VERSION,\n    moduleName: ModuleNames.ClientSideRowModelModule,\n    rowModel: 'clientSide',\n    beans: [ClientSideRowModel, FilterStage, SortStage, FlattenStage, SortService, FilterService, ImmutableService],\n};\n", "import {\n    _,\n    Autowired,\n    Bean,\n    BeanStub,\n    ChangedPath,\n    ColumnModel,\n    Events,\n    ExpandCollapseAllEvent,\n    FilterChangedEvent,\n    IClientSideRowModel,\n    IRowNodeStage,\n    ModelUpdatedEvent,\n    Optional,\n    PostConstruct,\n    RefreshModelParams,\n    ClientSideRowModelSteps,\n    ClientSideRowModelStep,\n    RowBounds,\n    RowDataTransaction,\n    RowDataUpdatedEvent,\n    RowNode,\n    RowHighlightPosition,\n    RowNodeTransaction,\n    ValueCache,\n    AsyncTransactionsFlushed,\n    Beans,\n    FilterManager,\n    WithoutGridCommon,\n    RowModelType,\n    SelectionChangedEvent,\n    ISelectionService,\n    GridOptions,\n} from \"@ag-grid-community/core\";\nimport { ClientSideNodeManager } from \"./clientSideNodeManager\";\n\nenum RecursionType { Normal, AfterFilter, AfterFilterAndSort, PivotNodes }\n\nexport interface BatchTransactionItem<TData = any> {\n    rowDataTransaction: RowDataTransaction<TData>;\n    callback: ((res: RowNodeTransaction<TData>) => void) | undefined;\n}\n\nexport interface RowNodeMap {\n    [id: string]: RowNode;\n}\n\n@Bean('rowModel')\nexport class ClientSideRowModel extends BeanStub implements IClientSideRowModel {\n\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('selectionService') private selectionService: ISelectionService;\n    @Autowired('filterManager') private filterManager: FilterManager;\n    @Autowired('valueCache') private valueCache: ValueCache;\n    @Autowired('beans') private beans: Beans;\n\n    // standard stages\n    @Autowired('filterStage') private filterStage: IRowNodeStage;\n    @Autowired('sortStage') private sortStage: IRowNodeStage;\n    @Autowired('flattenStage') private flattenStage: IRowNodeStage;\n\n    // enterprise stages\n    @Optional('groupStage') private groupStage: IRowNodeStage;\n    @Optional('aggregationStage') private aggregationStage: IRowNodeStage;\n    @Optional('pivotStage') private pivotStage: IRowNodeStage;\n    @Optional('filterAggregatesStage') private filterAggregatesStage: IRowNodeStage;\n\n    private onRowHeightChanged_debounced = _.debounce(this.onRowHeightChanged.bind(this), 100);\n\n    // top most node of the tree. the children are the user provided data.\n    private rootNode: RowNode;\n    private rowsToDisplay: RowNode[] = []; // the rows mapped to rows to display\n    private nodeManager: ClientSideNodeManager;\n    private rowDataTransactionBatch: BatchTransactionItem[] | null;\n    private lastHighlightedRow: RowNode | null;\n    private applyAsyncTransactionsTimeout: number | undefined;\n    /** Has the start method been called */\n    private hasStarted: boolean = false;\n    /** E.g. data has been set into the node manager already */\n    private shouldSkipSettingDataOnStart: boolean = false;\n    /**\n     * This is to prevent refresh model being called when it's already being called.\n     * E.g. the group stage can trigger initial state filter model to be applied. This fires onFilterChanged,\n     * which then triggers the listener here that calls refresh model again but at the filter stage\n     * (which is about to be run by the original call).\n     */\n    private isRefreshingModel: boolean = false;\n    private rowCountReady: boolean = false;\n\n    @PostConstruct\n    public init(): void {\n        const refreshEverythingFunc = this.refreshModel.bind(this, { step: ClientSideRowModelSteps.EVERYTHING });\n        const animate = !this.gridOptionsService.get('suppressAnimationFrame');\n        const refreshEverythingAfterColsChangedFunc = this.refreshModel.bind(this, {\n            step: ClientSideRowModelSteps.EVERYTHING, // after cols change, row grouping (the first stage) could of changed\n            afterColumnsChanged: true,\n            keepRenderedRows: true, // we want animations cos sorting or filtering could be applied\n            animate\n        });\n\n        this.addManagedListener(this.eventService, Events.EVENT_NEW_COLUMNS_LOADED, refreshEverythingAfterColsChangedFunc);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_ROW_GROUP_CHANGED, refreshEverythingFunc);\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_VALUE_CHANGED, this.onValueChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_CHANGED, this.refreshModel.bind(this, { step: ClientSideRowModelSteps.PIVOT }));\n        this.addManagedListener(this.eventService, Events.EVENT_FILTER_CHANGED, this.onFilterChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_SORT_CHANGED, this.onSortChanged.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_COLUMN_PIVOT_MODE_CHANGED, refreshEverythingFunc);\n        this.addManagedListener(this.eventService, Events.EVENT_GRID_STYLES_CHANGED, this.onGridStylesChanges.bind(this));\n        this.addManagedListener(this.eventService, Events.EVENT_GRID_READY, () => this.onGridReady());\n\n        // doesn't need done if doing full reset\n        // Property listeners which call `refreshModel` at different stages\n        this.addPropertyListeners();\n\n        this.rootNode = new RowNode(this.beans);\n        this.nodeManager = new ClientSideNodeManager(this.rootNode,\n            this.gridOptionsService,\n            this.eventService, this.columnModel,\n            this.selectionService, this.beans);\n    }\n\n    private addPropertyListeners() {\n        // Omitted Properties\n        //\n        // We do not act reactively on all functional properties, as it's possible the application is React and\n        // has not memoised the property and it's getting set every render.\n        //\n        // ** LIST OF NON REACTIVE, NO ARGUMENT\n        //\n        // getDataPath, getRowId, isRowMaster -- these are called once for each Node when the Node is created.\n        //                                    -- these are immutable Node properties (ie a Node ID cannot be changed)\n        // \n        // getRowHeight - this is called once when Node is created, if a new getRowHeight function is provided,\n        //              - we do not revisit the heights of each node.\n        //\n        // pivotDefaultExpanded - relevant for initial pivot column creation, no impact on existing pivot columns. \n        //\n        // deltaSort - this changes the type of algorithm used only, it doesn't change the sort order. so no point\n        //           - in doing the sort again as the same result will be got. the new Prop will be used next time we sort.\n        // \n        // ** LIST OF NON REACTIVE, SOME ARGUMENT\n        // ** For these, they could be reactive, but not convinced the business argument is strong enough,\n        // ** so leaving as non-reactive for now, and see if anyone complains.\n        //\n        // processPivotResultColDef, processPivotResultColGroupDef\n        //                       - there is an argument for having these reactive, that if the application changes\n        //                       - these props, we should re-create the Pivot Columns, however it's highly unlikely\n        //                       - the application would change these functions, far more likely the functions were\n        //                       - non memoised correctly.\n        \n        const resetProps: Set<keyof GridOptions> = new Set([\n            'treeData', 'masterDetail',\n        ]);\n        const groupStageRefreshProps: Set<keyof GridOptions> = new Set([\n            'suppressParentsInRowNodes', 'groupDefaultExpanded',\n            'groupAllowUnbalanced', 'initialGroupOrderComparator',\n            'groupHideOpenParents', 'groupDisplayType',\n        ]);\n        const filterStageRefreshProps: Set<keyof GridOptions> = new Set([\n            'excludeChildrenWhenTreeDataFiltering',\n        ]);\n        const pivotStageRefreshProps: Set<keyof GridOptions> = new Set([\n            'removePivotHeaderRowWhenSingleValueColumn', 'pivotRowTotals', 'pivotColumnGroupTotals', 'suppressExpandablePivotGroups',\n        ]);\n        const aggregateStageRefreshProps: Set<keyof GridOptions> = new Set([\n            'getGroupRowAgg', 'alwaysAggregateAtRootLevel', 'groupIncludeTotalFooter', 'suppressAggFilteredOnly',\n        ]);\n        const sortStageRefreshProps: Set<keyof GridOptions> = new Set([\n            'postSortRows', 'groupDisplayType', 'accentedSort',\n        ]);\n        const filterAggStageRefreshProps: Set<keyof GridOptions> = new Set([\n        ]);\n        const flattenStageRefreshProps: Set<keyof GridOptions> = new Set([\n            'groupRemoveSingleChildren', 'groupRemoveLowestSingleChildren', 'groupIncludeFooter',\n        ]);\n\n        const allProps = [\n            ...resetProps, ...groupStageRefreshProps, ...filterStageRefreshProps, ...pivotStageRefreshProps,\n            ...pivotStageRefreshProps, ...aggregateStageRefreshProps, ...sortStageRefreshProps, ...filterAggStageRefreshProps,\n            ...flattenStageRefreshProps,\n        ];\n        this.addManagedPropertyListeners(allProps, params => {\n            const properties = params.changeSet?.properties;\n            if (!properties) { return; };\n\n            const arePropertiesImpacted = (propSet: Set<keyof GridOptions>) => (\n                properties.some(prop => propSet.has(prop))\n            );\n\n            if (arePropertiesImpacted(resetProps)) {\n                this.setRowData(this.rootNode.allLeafChildren.map(child => child.data));\n                return;\n            }\n\n            if (arePropertiesImpacted(groupStageRefreshProps)) {\n                this.refreshModel({ step: ClientSideRowModelSteps.EVERYTHING });\n                return;\n            }\n\n            if (arePropertiesImpacted(filterStageRefreshProps)) {\n                this.refreshModel({ step: ClientSideRowModelSteps.FILTER });\n                return;\n            }\n\n            if (arePropertiesImpacted(pivotStageRefreshProps)) {\n                this.refreshModel({ step: ClientSideRowModelSteps.PIVOT });\n                return;\n            }\n            if (arePropertiesImpacted(aggregateStageRefreshProps)) {\n                this.refreshModel({ step: ClientSideRowModelSteps.AGGREGATE });\n                return;\n            }\n\n            if (arePropertiesImpacted(sortStageRefreshProps)) {\n                this.refreshModel({ step: ClientSideRowModelSteps.SORT });\n                return;\n            }\n\n            if (arePropertiesImpacted(filterAggStageRefreshProps)) {\n                this.refreshModel({ step: ClientSideRowModelSteps.FILTER_AGGREGATES });\n                return;\n            }\n\n            if (arePropertiesImpacted(flattenStageRefreshProps)) {\n                this.refreshModel({ step: ClientSideRowModelSteps.MAP });\n            }\n        });\n\n        this.addManagedPropertyListener('rowHeight', () => this.resetRowHeights());\n    }\n\n    public start(): void {\n        this.hasStarted = true;\n        if (this.shouldSkipSettingDataOnStart) {\n            this.dispatchUpdateEventsAndRefresh();\n        } else {\n            this.setInitialData();\n        }\n    }\n\n    private setInitialData(): void {\n        const rowData = this.gridOptionsService.get('rowData');\n        if (rowData) {\n            this.shouldSkipSettingDataOnStart = true;\n            this.setRowData(rowData);\n        }\n    }\n\n    public ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number): boolean {\n        let atLeastOneChange: boolean;\n        let res = false;\n\n        // we do this multiple times as changing the row heights can also change the first and last rows,\n        // so the first pass can make lots of rows smaller, which means the second pass we end up changing\n        // more rows.\n        do {\n            atLeastOneChange = false;\n\n            const rowAtStartPixel = this.getRowIndexAtPixel(startPixel);\n            const rowAtEndPixel = this.getRowIndexAtPixel(endPixel);\n\n            // keep check to current page if doing pagination\n            const firstRow = Math.max(rowAtStartPixel, startLimitIndex);\n            const lastRow = Math.min(rowAtEndPixel, endLimitIndex);\n\n            for (let rowIndex = firstRow; rowIndex <= lastRow; rowIndex++) {\n                const rowNode = this.getRow(rowIndex);\n                if (rowNode.rowHeightEstimated) {\n                    const rowHeight = this.gridOptionsService.getRowHeightForNode(rowNode);\n                    rowNode.setRowHeight(rowHeight.height);\n                    atLeastOneChange = true;\n                    res = true;\n                }\n            }\n\n            if (atLeastOneChange) {\n                this.setRowTopAndRowIndex();\n            }\n\n        } while (atLeastOneChange);\n\n        return res;\n    }\n\n    private setRowTopAndRowIndex(): Set<string> {\n        const defaultRowHeight = this.environment.getDefaultRowHeight();\n        let nextRowTop = 0;\n\n        // mapping displayed rows is not needed for this method, however it's used in\n        // clearRowTopAndRowIndex(), and given we are looping through this.rowsToDisplay here,\n        // we create the map here for performance reasons, so we don't loop a second time\n        // in clearRowTopAndRowIndex()\n        const displayedRowsMapped = new Set<string>();\n\n        // we don't estimate if doing fullHeight or autoHeight, as all rows get rendered all the time\n        // with these two layouts.\n        const allowEstimate = this.gridOptionsService.isDomLayout('normal');\n\n        for (let i = 0; i < this.rowsToDisplay.length; i++) {\n\n            const rowNode = this.rowsToDisplay[i];\n\n            if (rowNode.id != null) {\n                displayedRowsMapped.add(rowNode.id);\n            }\n\n            if (rowNode.rowHeight == null) {\n                const rowHeight = this.gridOptionsService.getRowHeightForNode(rowNode, allowEstimate, defaultRowHeight);\n                rowNode.setRowHeight(rowHeight.height, rowHeight.estimated);\n            }\n\n            rowNode.setRowTop(nextRowTop);\n            rowNode.setRowIndex(i);\n            nextRowTop += rowNode.rowHeight!;\n        }\n\n        return displayedRowsMapped;\n    }\n\n    private clearRowTopAndRowIndex(changedPath: ChangedPath, displayedRowsMapped: Set<string>): void {\n\n        const changedPathActive = changedPath.isActive();\n\n        const clearIfNotDisplayed = (rowNode: RowNode) => {\n            if (rowNode && rowNode.id != null && !displayedRowsMapped.has(rowNode.id)) {\n                rowNode.clearRowTopAndRowIndex();\n            }\n        };\n\n        const recurse = (rowNode: RowNode) => {\n\n            clearIfNotDisplayed(rowNode);\n            clearIfNotDisplayed(rowNode.detailNode);\n            clearIfNotDisplayed(rowNode.sibling);\n\n            if (rowNode.hasChildren()) {\n                if (rowNode.childrenAfterGroup) {\n\n                    // if a changedPath is active, it means we are here because of a transaction update or\n                    // a change detection. neither of these impacts the open/closed state of groups. so if\n                    // a group is not open this time, it was not open last time. so we know all closed groups\n                    // already have their top positions cleared. so there is no need to traverse all the way\n                    // when changedPath is active and the rowNode is not expanded.\n                    const isRootNode = rowNode.level == -1; // we need to give special consideration for root node,\n                    // as expanded=undefined for root node\n                    const skipChildren = changedPathActive && !isRootNode && !rowNode.expanded;\n                    if (!skipChildren) {\n                        rowNode.childrenAfterGroup.forEach(recurse);\n                    }\n                }\n            }\n        };\n\n        recurse(this.rootNode);\n    }\n\n    // returns false if row was moved, otherwise true\n    public ensureRowsAtPixel(rowNodes: RowNode[], pixel: number, increment: number = 0): boolean {\n        const indexAtPixelNow = this.getRowIndexAtPixel(pixel);\n        const rowNodeAtPixelNow = this.getRow(indexAtPixelNow);\n        const animate = !this.gridOptionsService.get('suppressAnimationFrame');\n\n        if (rowNodeAtPixelNow === rowNodes[0]) {\n            return false;\n        }\n\n        rowNodes.forEach(rowNode => {\n            _.removeFromArray(this.rootNode.allLeafChildren, rowNode);\n        });\n\n        rowNodes.forEach((rowNode, idx) => {\n            _.insertIntoArray(this.rootNode.allLeafChildren, rowNode, Math.max(indexAtPixelNow + increment, 0) + idx);\n        });\n\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            keepRenderedRows: true,\n            keepEditingRows: true,\n            animate\n        });\n\n        return true;\n    }\n\n    public highlightRowAtPixel(rowNode: RowNode | null, pixel?: number): void {\n        const indexAtPixelNow = pixel != null ? this.getRowIndexAtPixel(pixel) : null;\n        const rowNodeAtPixelNow = indexAtPixelNow != null ? this.getRow(indexAtPixelNow) : null;\n\n        if (!rowNodeAtPixelNow || !rowNode || rowNodeAtPixelNow === rowNode || pixel == null) {\n            if (this.lastHighlightedRow) {\n                this.lastHighlightedRow.setHighlighted(null);\n                this.lastHighlightedRow = null;\n            }\n            return;\n        }\n\n        const highlight = this.getHighlightPosition(pixel, rowNodeAtPixelNow);\n\n        if (this.lastHighlightedRow && this.lastHighlightedRow !== rowNodeAtPixelNow) {\n            this.lastHighlightedRow.setHighlighted(null);\n            this.lastHighlightedRow = null;\n        }\n\n        rowNodeAtPixelNow.setHighlighted(highlight);\n        this.lastHighlightedRow = rowNodeAtPixelNow;\n    }\n\n    public getHighlightPosition(pixel: number, rowNode?: RowNode): RowHighlightPosition {\n        if (!rowNode) {\n            const index = this.getRowIndexAtPixel(pixel);\n            rowNode = this.getRow(index || 0);\n\n            if (!rowNode) { return RowHighlightPosition.Below; }\n        }\n\n        const { rowTop, rowHeight } = rowNode;\n\n        return pixel - rowTop! < rowHeight! / 2 ? RowHighlightPosition.Above : RowHighlightPosition.Below;\n    }\n\n    public getLastHighlightedRowNode(): RowNode | null {\n        return this.lastHighlightedRow;\n    }\n\n    public isLastRowIndexKnown(): boolean {\n        return true;\n    }\n\n    public getRowCount(): number {\n        if (this.rowsToDisplay) {\n            return this.rowsToDisplay.length;\n        }\n\n        return 0;\n    }\n\n    public getTopLevelRowCount(): number {\n        const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n\n        if (showingRootNode) {\n            return 1;\n        }\n\n        const filteredChildren = this.rootNode.childrenAfterAggFilter;\n        return filteredChildren ? filteredChildren.length : 0;\n    }\n\n    public getTopLevelRowDisplayedIndex(topLevelIndex: number): number {\n        const showingRootNode = this.rowsToDisplay && this.rowsToDisplay[0] === this.rootNode;\n\n        if (showingRootNode) {\n            return topLevelIndex;\n        }\n\n        let rowNode = this.rootNode.childrenAfterSort![topLevelIndex];\n\n        if (this.gridOptionsService.get('groupHideOpenParents')) {\n            // if hideOpenParents, and this row open, then this row is now displayed at this index, first child is\n            while (rowNode.expanded && rowNode.childrenAfterSort && rowNode.childrenAfterSort.length > 0) {\n                rowNode = rowNode.childrenAfterSort[0];\n            }\n        }\n\n        return rowNode.rowIndex!;\n    }\n\n    public getRowBounds(index: number): RowBounds | null {\n        if (_.missing(this.rowsToDisplay)) {\n            return null;\n        }\n\n        const rowNode = this.rowsToDisplay[index];\n\n        if (rowNode) {\n            return {\n                rowTop: rowNode.rowTop!,\n                rowHeight: rowNode.rowHeight!\n            };\n        }\n\n        return null;\n    }\n\n    public onRowGroupOpened(): void {\n        const animate = this.gridOptionsService.isAnimateRows();\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP, keepRenderedRows: true, animate: animate });\n    }\n\n    private onFilterChanged(event: FilterChangedEvent): void {\n        if (event.afterDataChange) { return; }\n        const animate = this.gridOptionsService.isAnimateRows();\n\n        const primaryOrQuickFilterChanged = event.columns.length === 0 || event.columns.some(col => col.isPrimary());\n        const step: ClientSideRowModelSteps = primaryOrQuickFilterChanged ? ClientSideRowModelSteps.FILTER : ClientSideRowModelSteps.FILTER_AGGREGATES;\n        this.refreshModel({ step: step, keepRenderedRows: true, animate: animate });\n    }\n\n    private onSortChanged(): void {\n        const animate = this.gridOptionsService.isAnimateRows();\n        this.refreshModel({ step: ClientSideRowModelSteps.SORT, keepRenderedRows: true, animate: animate, keepEditingRows: true });\n    }\n\n    public getType(): RowModelType {\n        return 'clientSide';\n    }\n\n    private onValueChanged(): void {\n        if (this.columnModel.isPivotActive()) {\n            this.refreshModel({ step: ClientSideRowModelSteps.PIVOT });\n        } else {\n            this.refreshModel({ step: ClientSideRowModelSteps.AGGREGATE });\n        }\n    }\n\n    private createChangePath(rowNodeTransactions: (RowNodeTransaction | null)[] | undefined): ChangedPath {\n\n        // for updates, if the row is updated at all, then we re-calc all the values\n        // in that row. we could compare each value to each old value, however if we\n        // did this, we would be calling the valueService twice, once on the old value\n        // and once on the new value. so it's less valueGetter calls if we just assume\n        // each column is different. that way the changedPath is used so that only\n        // the impacted parent rows are recalculated, parents who's children have\n        // not changed are not impacted.\n\n        const noTransactions = _.missingOrEmpty(rowNodeTransactions);\n\n        const changedPath = new ChangedPath(false, this.rootNode);\n\n        if (noTransactions || this.gridOptionsService.get('treeData')) {\n            changedPath.setInactive();\n        }\n\n        return changedPath;\n    }\n\n    private isSuppressModelUpdateAfterUpdateTransaction(params: RefreshModelParams): boolean {\n        if (!this.gridOptionsService.get('suppressModelUpdateAfterUpdateTransaction')) { return false; }\n\n        // return true if we are only doing update transactions\n        if (params.rowNodeTransactions == null) { return false; }\n\n        const transWithAddsOrDeletes = params.rowNodeTransactions.filter(tx =>\n            (tx.add != null && tx.add.length > 0) || (tx.remove != null && tx.remove.length > 0)\n        );\n\n        const transactionsContainUpdatesOnly = transWithAddsOrDeletes == null || transWithAddsOrDeletes.length == 0;\n\n        return transactionsContainUpdatesOnly;\n    }\n\n    private buildRefreshModelParams(step: ClientSideRowModelStep | undefined): RefreshModelParams | undefined {\n        let paramsStep = ClientSideRowModelSteps.EVERYTHING;\n        const stepsMapped: any = {\n            everything: ClientSideRowModelSteps.EVERYTHING,\n            group: ClientSideRowModelSteps.EVERYTHING,\n            filter: ClientSideRowModelSteps.FILTER,\n            map: ClientSideRowModelSteps.MAP,\n            aggregate: ClientSideRowModelSteps.AGGREGATE,\n            sort: ClientSideRowModelSteps.SORT,\n            pivot: ClientSideRowModelSteps.PIVOT\n        };\n        if (_.exists(step)) {\n            paramsStep = stepsMapped[step];\n        }\n\n        if (_.missing(paramsStep)) {\n            console.error(`AG Grid: invalid step ${step}, available steps are ${Object.keys(stepsMapped).join(', ')}`);\n            return undefined;\n        }\n        const animate = !this.gridOptionsService.get('suppressAnimationFrame');\n        const modelParams: RefreshModelParams = {\n            step: paramsStep,\n            keepRenderedRows: true,\n            keepEditingRows: true,\n            animate\n        };\n        return modelParams;\n    }\n\n    refreshModel(paramsOrStep: RefreshModelParams | ClientSideRowModelStep | undefined): void {\n        if (!this.hasStarted || this.isRefreshingModel || this.columnModel.shouldRowModelIgnoreRefresh()) { return; }\n\n        let params = typeof paramsOrStep === 'object' && \"step\" in paramsOrStep ? paramsOrStep : this.buildRefreshModelParams(paramsOrStep);\n\n        if (!params) {\n            return;\n        }\n\n        if (this.isSuppressModelUpdateAfterUpdateTransaction(params)) { return; }\n\n        // this goes through the pipeline of stages. what's in my head is similar\n        // to the diagram on this page:\n        // http://commons.apache.org/sandbox/commons-pipeline/pipeline_basics.html\n        // however we want to keep the results of each stage, hence we manually call\n        // each step rather than have them chain each other.\n\n        // fallthrough in below switch is on purpose,\n        // eg if STEP_FILTER, then all steps below this\n        // step get done\n        // let start: number;\n        // console.log('======= start =======');\n\n        const changedPath: ChangedPath = this.createChangePath(params.rowNodeTransactions);\n\n        this.isRefreshingModel = true;\n\n        switch (params.step) {\n            case ClientSideRowModelSteps.EVERYTHING:\n                this.doRowGrouping(params.rowNodeTransactions, params.rowNodeOrder,\n                    changedPath, !!params.afterColumnsChanged);\n            case ClientSideRowModelSteps.FILTER:\n                this.doFilter(changedPath);\n            case ClientSideRowModelSteps.PIVOT:\n                this.doPivot(changedPath);\n            case ClientSideRowModelSteps.AGGREGATE: // depends on agg fields\n                this.doAggregate(changedPath);\n            case ClientSideRowModelSteps.FILTER_AGGREGATES:\n                this.doFilterAggregates(changedPath);\n            case ClientSideRowModelSteps.SORT:\n                this.doSort(params.rowNodeTransactions, changedPath);\n            case ClientSideRowModelSteps.MAP:\n                this.doRowsToDisplay();\n        }\n\n        // set all row tops to null, then set row tops on all visible rows. if we don't\n        // do this, then the algorithm below only sets row tops, old row tops from old rows\n        // will still lie around\n        const displayedNodesMapped = this.setRowTopAndRowIndex();\n        this.clearRowTopAndRowIndex(changedPath, displayedNodesMapped);\n\n        this.isRefreshingModel = false;\n\n        const event: WithoutGridCommon<ModelUpdatedEvent> = {\n            type: Events.EVENT_MODEL_UPDATED,\n            animate: params.animate,\n            keepRenderedRows: params.keepRenderedRows,\n            newData: params.newData,\n            newPage: false,\n            keepUndoRedoStack: params.keepUndoRedoStack\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    public isEmpty(): boolean {\n        const rowsMissing = _.missing(this.rootNode.allLeafChildren) || this.rootNode.allLeafChildren.length === 0;\n        return _.missing(this.rootNode) || rowsMissing || !this.columnModel.isReady();\n    }\n\n    public isRowsToRender(): boolean {\n        return _.exists(this.rowsToDisplay) && this.rowsToDisplay.length > 0;\n    }\n\n    public getNodesInRangeForSelection(firstInRange: RowNode, lastInRange: RowNode): RowNode[] {\n        // if lastSelectedNode is missing, we start at the first row\n        let started = !lastInRange;\n        let finished = false;\n\n        const result: RowNode[] = [];\n\n        const groupsSelectChildren = this.gridOptionsService.get('groupSelectsChildren');\n\n        this.forEachNodeAfterFilterAndSort(rowNode => {\n            // range has been closed, skip till end\n            if (finished) {\n                return;\n            }\n\n            if (started) {\n                if (rowNode === lastInRange || rowNode === firstInRange) {\n                    // check if this is the last node we're going to be adding\n                    finished = true;\n\n                    // if the final node was a group node, and we're doing groupSelectsChildren\n                    // make the exception to select all of it's descendants too\n                    if (rowNode.group && groupsSelectChildren) {\n                        result.push(...rowNode.allLeafChildren);\n                        return;\n                    }\n                }\n            }\n\n            if (!started) {\n                if (rowNode !== lastInRange && rowNode !== firstInRange) {\n                    // still haven't hit a boundary node, keep searching\n                    return;\n                }\n                started = true;\n            }\n\n            // only select leaf nodes if groupsSelectChildren\n            const includeThisNode = !rowNode.group || !groupsSelectChildren;\n            if (includeThisNode) {\n                result.push(rowNode);\n                return;\n            }\n        });\n\n        return result;\n    }\n\n    public setDatasource(datasource: any): void {\n        console.error('AG Grid: should never call setDatasource on clientSideRowController');\n    }\n\n    public getTopLevelNodes(): RowNode[] | null {\n        return this.rootNode ? this.rootNode.childrenAfterGroup : null;\n    }\n\n    public getRootNode(): RowNode {\n        return this.rootNode;\n    }\n\n    public getRow(index: number): RowNode {\n        return this.rowsToDisplay[index];\n    }\n\n    public isRowPresent(rowNode: RowNode): boolean {\n        return this.rowsToDisplay.indexOf(rowNode) >= 0;\n    }\n\n    public getRowIndexAtPixel(pixelToMatch: number): number {\n        if (this.isEmpty() || this.rowsToDisplay.length === 0) {\n            return -1;\n        }\n\n        // do binary search of tree\n        // http://oli.me.uk/2013/06/08/searching-javascript-arrays-with-a-binary-search/\n        let bottomPointer = 0;\n        let topPointer = this.rowsToDisplay.length - 1;\n\n        // quick check, if the pixel is out of bounds, then return last row\n        if (pixelToMatch <= 0) {\n            // if pixel is less than or equal zero, it's always the first row\n            return 0;\n        }\n        const lastNode = _.last(this.rowsToDisplay);\n        if (lastNode.rowTop! <= pixelToMatch) {\n            return this.rowsToDisplay.length - 1;\n        }\n\n        let oldBottomPointer = -1;\n        let oldTopPointer = -1;\n\n        while (true) {\n            const midPointer = Math.floor((bottomPointer + topPointer) / 2);\n            const currentRowNode = this.rowsToDisplay[midPointer];\n\n            if (this.isRowInPixel(currentRowNode, pixelToMatch)) {\n                return midPointer;\n            }\n\n            if (currentRowNode.rowTop! < pixelToMatch) {\n                bottomPointer = midPointer + 1;\n            } else if (currentRowNode.rowTop! > pixelToMatch) {\n                topPointer = midPointer - 1;\n            }\n\n            // infinite loops happen when there is space between rows. this can happen\n            // when Auto Height is active, cos we re-calculate row tops asyncronously\n            // when row heights change, which can temporarly result in gaps between rows.\n            const caughtInInfiniteLoop = oldBottomPointer === bottomPointer\n                && oldTopPointer === topPointer;\n            if (caughtInInfiniteLoop) { return midPointer; }\n\n            oldBottomPointer = bottomPointer;\n            oldTopPointer = topPointer;\n        }\n    }\n\n    private isRowInPixel(rowNode: RowNode, pixelToMatch: number): boolean {\n        const topPixel = rowNode.rowTop;\n        const bottomPixel = rowNode.rowTop! + rowNode.rowHeight!;\n        const pixelInRow = topPixel! <= pixelToMatch && bottomPixel > pixelToMatch;\n        return pixelInRow;\n    }\n\n    public forEachLeafNode(callback: (node: RowNode, index: number) => void): void {\n        if (this.rootNode.allLeafChildren) {\n            this.rootNode.allLeafChildren.forEach((rowNode, index) => callback(rowNode, index));\n        }\n    }\n\n    public forEachNode(callback: (node: RowNode, index: number) => void, includeFooterNodes: boolean = false): void {\n        this.recursivelyWalkNodesAndCallback({\n            nodes: [...(this.rootNode.childrenAfterGroup || [])],\n            callback,\n            recursionType: RecursionType.Normal,\n            index: 0,\n            includeFooterNodes\n        });\n    }\n\n    public forEachNodeAfterFilter(callback: (node: RowNode, index: number) => void, includeFooterNodes: boolean = false): void {\n        this.recursivelyWalkNodesAndCallback({\n            nodes: [...(this.rootNode.childrenAfterAggFilter || [])],\n            callback,\n            recursionType: RecursionType.AfterFilter,\n            index: 0,\n            includeFooterNodes\n        });\n    }\n\n    public forEachNodeAfterFilterAndSort(callback: (node: RowNode, index: number) => void, includeFooterNodes: boolean = false): void {\n        this.recursivelyWalkNodesAndCallback({\n            nodes: [...(this.rootNode.childrenAfterSort || [])],\n            callback,\n            recursionType: RecursionType.AfterFilterAndSort,\n            index: 0,\n            includeFooterNodes\n        });\n    }\n\n    public forEachPivotNode(callback: (node: RowNode, index: number) => void, includeFooterNodes: boolean = false): void {\n        this.recursivelyWalkNodesAndCallback({\n            nodes: [this.rootNode],\n            callback,\n            recursionType: RecursionType.PivotNodes,\n            index: 0,\n            includeFooterNodes\n        });\n    }\n\n    // iterates through each item in memory, and calls the callback function\n    // nodes - the rowNodes to traverse\n    // callback - the user provided callback\n    // recursion type - need this to know what child nodes to recurse, eg if looking at all nodes, or filtered notes etc\n    // index - works similar to the index in forEach in javascript's array function\n    private recursivelyWalkNodesAndCallback(params: {\n        nodes: RowNode[];\n        callback: (node: RowNode, index: number) => void;\n        recursionType: RecursionType;\n        index: number;\n        includeFooterNodes: boolean\n    }): number {\n        const { nodes, callback, recursionType, includeFooterNodes } = params;\n        let { index } = params;\n\n        for (let i = 0; i < nodes.length; i++) {\n            const node = nodes[i];\n            callback(node, index++);\n            // go to the next level if it is a group\n            if (node.hasChildren() && !node.footer) {\n                // depending on the recursion type, we pick a difference set of children\n                let nodeChildren: RowNode[] | null = null;\n                switch (recursionType) {\n                    case RecursionType.Normal:\n                        nodeChildren = node.childrenAfterGroup;\n                        break;\n                    case RecursionType.AfterFilter:\n                        nodeChildren = node.childrenAfterAggFilter;\n                        break;\n                    case RecursionType.AfterFilterAndSort:\n                        nodeChildren = node.childrenAfterSort;\n                        break;\n                    case RecursionType.PivotNodes:\n                        // for pivot, we don't go below leafGroup levels\n                        nodeChildren = !node.leafGroup ? node.childrenAfterSort : null;\n                        break;\n                }\n                if (nodeChildren) {\n                    index = this.recursivelyWalkNodesAndCallback({\n                        nodes: [...nodeChildren],\n                        callback,\n                        recursionType,\n                        index,\n                        includeFooterNodes\n                    });\n                }\n            }\n        }\n\n        const parentNode = nodes[0]?.parent;\n        if (!includeFooterNodes || !parentNode) return index;\n\n        const isRootNode = parentNode === this.rootNode;\n        if (isRootNode) {\n            const totalFooters = this.gridOptionsService.get('groupIncludeTotalFooter');\n            if (!totalFooters) return index;\n        } else {\n            const isGroupIncludeFooter = this.gridOptionsService.getGroupIncludeFooter();\n            if (!isGroupIncludeFooter({ node: parentNode })) return index;\n        }\n\n        parentNode.createFooter();\n        callback(parentNode.sibling, index++);\n        return index;\n    }\n\n    // it's possible to recompute the aggregate without doing the other parts\n    // + api.refreshClientSideRowModel('aggregate')\n    public doAggregate(changedPath?: ChangedPath): void {\n        if (this.aggregationStage) {\n            this.aggregationStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        }\n    }\n\n    private doFilterAggregates(changedPath: ChangedPath): void {\n        if (this.filterAggregatesStage) {\n            this.filterAggregatesStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        } else {\n            // If filterAggregatesStage is undefined, then so is the grouping stage, so all children should be on the rootNode.\n            this.rootNode.childrenAfterAggFilter = this.rootNode.childrenAfterFilter;\n        }\n    }\n\n    // + gridApi.expandAll()\n    // + gridApi.collapseAll()\n    public expandOrCollapseAll(expand: boolean): void {\n        const usingTreeData = this.gridOptionsService.get('treeData');\n        const usingPivotMode = this.columnModel.isPivotActive();\n\n        const recursiveExpandOrCollapse = (rowNodes: RowNode[] | null): void => {\n            if (!rowNodes) { return; }\n            rowNodes.forEach(rowNode => {\n                const actionRow = () => {\n                    rowNode.expanded = expand;\n                    recursiveExpandOrCollapse(rowNode.childrenAfterGroup);\n                };\n\n                if (usingTreeData) {\n                    const hasChildren = _.exists(rowNode.childrenAfterGroup);\n                    if (hasChildren) {\n                        actionRow();\n                    }\n                    return;\n                }\n\n                if (usingPivotMode) {\n                    const notLeafGroup = !rowNode.leafGroup;\n                    if (notLeafGroup) {\n                        actionRow();\n                    }\n                    return;\n                }\n\n                const isRowGroup = rowNode.group;\n                if (isRowGroup) {\n                    actionRow();\n                }\n            });\n        }\n\n        if (this.rootNode) {\n            recursiveExpandOrCollapse(this.rootNode.childrenAfterGroup);\n        }\n\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP });\n\n        const eventSource = expand ? 'expandAll' : 'collapseAll';\n        const event: WithoutGridCommon<ExpandCollapseAllEvent> = {\n            type: Events.EVENT_EXPAND_COLLAPSE_ALL,\n            source: eventSource\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    private doSort(rowNodeTransactions: RowNodeTransaction[] | undefined, changedPath: ChangedPath) {\n        this.sortStage.execute({\n            rowNode: this.rootNode,\n            rowNodeTransactions: rowNodeTransactions,\n            changedPath: changedPath\n        });\n    }\n\n    private doRowGrouping(\n        rowNodeTransactions: RowNodeTransaction[] | undefined,\n        rowNodeOrder: { [id: string]: number; } | undefined,\n        changedPath: ChangedPath,\n        afterColumnsChanged: boolean\n    ) {\n        if (this.groupStage) {\n\n            if (rowNodeTransactions) {\n                this.groupStage.execute({\n                    rowNode: this.rootNode,\n                    rowNodeTransactions: rowNodeTransactions,\n                    rowNodeOrder: rowNodeOrder,\n                    changedPath: changedPath\n                });\n            } else {\n                this.groupStage.execute({\n                    rowNode: this.rootNode,\n                    changedPath: changedPath,\n                    afterColumnsChanged: afterColumnsChanged\n                });\n            }\n\n            if (this.gridOptionsService.get('groupSelectsChildren')) {\n                const selectionChanged = this.selectionService.updateGroupsFromChildrenSelections('rowGroupChanged', changedPath);\n\n                if (selectionChanged) {\n                    const event: WithoutGridCommon<SelectionChangedEvent> = {\n                        type: Events.EVENT_SELECTION_CHANGED,\n                        source: 'rowGroupChanged'\n                    };\n                    this.eventService.dispatchEvent(event);\n                }\n            }\n\n        } else {\n            this.rootNode.childrenAfterGroup = this.rootNode.allLeafChildren;\n            if (this.rootNode.sibling) {\n                this.rootNode.sibling.childrenAfterGroup = this.rootNode.childrenAfterGroup;\n            }\n            this.rootNode.updateHasChildren();\n        }\n\n        if (this.nodeManager.isRowCountReady()) {\n            // only if row data has been set\n            this.rowCountReady = true;\n            this.eventService.dispatchEventOnce({\n                type: Events.EVENT_ROW_COUNT_READY\n            });\n        }\n    }\n\n    private doFilter(changedPath: ChangedPath) {\n        this.filterStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n    }\n\n    private doPivot(changedPath: ChangedPath) {\n        if (this.pivotStage) {\n            this.pivotStage.execute({ rowNode: this.rootNode, changedPath: changedPath });\n        }\n    }\n\n    public getCopyOfNodesMap(): { [id: string]: RowNode; } {\n        return this.nodeManager.getCopyOfNodesMap();\n    }\n\n    public getRowNode(id: string): RowNode | undefined {\n        // although id is typed a string, this could be called by the user, and they could have passed a number\n        const idIsGroup = typeof id == 'string' && id.indexOf(RowNode.ID_PREFIX_ROW_GROUP) == 0;\n\n        if (idIsGroup) {\n            // only one users complained about getRowNode not working for groups, after years of\n            // this working for normal rows. so have done quick implementation. if users complain\n            // about performance, then GroupStage should store / manage created groups in a map,\n            // which is a chunk of work.\n            let res: RowNode | undefined = undefined;\n            this.forEachNode(node => {\n                if (node.id === id) {\n                    res = node;\n                }\n            });\n            return res;\n        }\n\n        return this.nodeManager.getRowNode(id);\n    }\n\n    // rows: the rows to put into the model\n    public setRowData(rowData: any[]): void {\n        // no need to invalidate cache, as the cache is stored on the rowNode,\n        // so new rowNodes means the cache is wiped anyway.\n        \n        // - clears selection, done before we set row data to ensure it isn't readded via `selectionService.syncInOldRowNode`\n        this.selectionService.reset('rowDataChanged');\n\n        this.nodeManager.setRowData(rowData);\n        \n        if (this.hasStarted) {\n            this.dispatchUpdateEventsAndRefresh();\n        }\n    }\n\n    private dispatchUpdateEventsAndRefresh(): void {\n\n        // this event kicks off:\n        // - shows 'no rows' overlay if needed\n        const rowDataUpdatedEvent: WithoutGridCommon<RowDataUpdatedEvent> = {\n            type: Events.EVENT_ROW_DATA_UPDATED\n        };\n        this.eventService.dispatchEvent(rowDataUpdatedEvent);\n\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            newData: true,\n        });\n    }\n\n    public batchUpdateRowData(rowDataTransaction: RowDataTransaction, callback?: (res: RowNodeTransaction) => void): void {\n        if (this.applyAsyncTransactionsTimeout == null) {\n            this.rowDataTransactionBatch = [];\n            const waitMillis = this.gridOptionsService.getAsyncTransactionWaitMillis();\n            this.applyAsyncTransactionsTimeout = window.setTimeout(() => {\n                this.executeBatchUpdateRowData();\n            }, waitMillis);\n        }\n        this.rowDataTransactionBatch!.push({ rowDataTransaction: rowDataTransaction, callback: callback });\n    }\n\n    public flushAsyncTransactions(): void {\n        if (this.applyAsyncTransactionsTimeout != null) {\n            clearTimeout(this.applyAsyncTransactionsTimeout);\n            this.executeBatchUpdateRowData();\n        }\n    }\n\n    private executeBatchUpdateRowData(): void {\n        this.valueCache.onDataChanged();\n\n        const callbackFuncsBound: Function[] = [];\n        const rowNodeTrans: RowNodeTransaction[] = [];\n\n        // The rowGroup stage uses rowNodeOrder if order was provided. if we didn't pass 'true' to\n        // commonUpdateRowData, using addIndex would have no effect when grouping.\n        let forceRowNodeOrder = false;\n\n        if (this.rowDataTransactionBatch) {\n            this.rowDataTransactionBatch.forEach(tranItem => {\n                const rowNodeTran = this.nodeManager.updateRowData(tranItem.rowDataTransaction, undefined);\n                rowNodeTrans.push(rowNodeTran);\n                if (tranItem.callback) {\n                    callbackFuncsBound.push(tranItem.callback.bind(null, rowNodeTran));\n                }\n                if (typeof tranItem.rowDataTransaction.addIndex === 'number') {\n                    forceRowNodeOrder = true;\n                }\n            });\n        }\n\n        this.commonUpdateRowData(rowNodeTrans, undefined, forceRowNodeOrder);\n\n        // do callbacks in next VM turn so it's async\n        if (callbackFuncsBound.length > 0) {\n            window.setTimeout(() => {\n                callbackFuncsBound.forEach(func => func());\n            }, 0);\n        }\n\n        if (rowNodeTrans.length > 0) {\n            const event: WithoutGridCommon<AsyncTransactionsFlushed> = {\n                type: Events.EVENT_ASYNC_TRANSACTIONS_FLUSHED,\n                results: rowNodeTrans\n            };\n            this.eventService.dispatchEvent(event);\n        }\n\n        this.rowDataTransactionBatch = null;\n        this.applyAsyncTransactionsTimeout = undefined;\n    }\n\n    public updateRowData(rowDataTran: RowDataTransaction, rowNodeOrder?: { [id: string]: number; }): RowNodeTransaction | null {\n\n        this.valueCache.onDataChanged();\n\n        const rowNodeTran = this.nodeManager.updateRowData(rowDataTran, rowNodeOrder);\n\n        // if doing immutableData, addIndex is never present. however if doing standard transaction, and user\n        // provided addIndex, then this is used in updateRowData. However if doing Enterprise, then the rowGroup\n        // stage also uses the\n        const forceRowNodeOrder = typeof rowDataTran.addIndex === 'number';\n\n        this.commonUpdateRowData([rowNodeTran], rowNodeOrder, forceRowNodeOrder);\n\n        return rowNodeTran;\n    }\n\n    private createRowNodeOrder(): { [id: string]: number; } | undefined {\n        const suppressSortOrder = this.gridOptionsService.get('suppressMaintainUnsortedOrder');\n        if (suppressSortOrder) { return; }\n\n        const orderMap: { [id: string]: number } = {};\n\n        if (this.rootNode && this.rootNode.allLeafChildren) {\n            for (let index = 0; index < this.rootNode.allLeafChildren.length; index++) {\n                const node = this.rootNode.allLeafChildren[index];\n                orderMap[node.id!] = index;\n            }\n        }\n\n        return orderMap;\n    }\n\n    // common to updateRowData and batchUpdateRowData\n    private commonUpdateRowData(\n        rowNodeTrans: RowNodeTransaction[],\n        rowNodeOrder: { [id: string]: number; } | undefined,\n        forceRowNodeOrder: boolean\n    ): void {\n        if (!this.hasStarted) { return; }\n\n        const animate = !this.gridOptionsService.get('suppressAnimationFrame');\n\n        if (forceRowNodeOrder) {\n            rowNodeOrder = this.createRowNodeOrder();\n        }\n\n        const event: WithoutGridCommon<RowDataUpdatedEvent> = {\n            type: Events.EVENT_ROW_DATA_UPDATED\n        };\n        this.eventService.dispatchEvent(event);\n\n        this.refreshModel({\n            step: ClientSideRowModelSteps.EVERYTHING,\n            rowNodeTransactions: rowNodeTrans,\n            rowNodeOrder: rowNodeOrder,\n            keepRenderedRows: true,\n            keepEditingRows: true,\n            animate\n        });\n    }\n\n    private doRowsToDisplay() {\n        this.rowsToDisplay = this.flattenStage.execute({ rowNode: this.rootNode }) as RowNode[];\n    }\n\n    public onRowHeightChanged(): void {\n        this.refreshModel({ step: ClientSideRowModelSteps.MAP, keepRenderedRows: true, keepEditingRows: true, keepUndoRedoStack: true });\n    }\n\n    /** This method is debounced. It is used for row auto-height. If we don't debounce,\n     * then the Row Models will end up recalculating each row position\n     * for each row height change and result in the Row Renderer laying out rows.\n     * This is particularly bad if using print layout, and showing eg 1,000 rows,\n     * each row will change it's height, causing Row Model to update 1,000 times.\n     */\n    public onRowHeightChangedDebounced(): void {\n        this.onRowHeightChanged_debounced();\n    }\n\n    public resetRowHeights(): void {\n        const atLeastOne = this.resetRowHeightsForAllRowNodes();\n\n        this.rootNode.setRowHeight(this.rootNode.rowHeight, true);\n        if (this.rootNode.sibling) {\n            this.rootNode.sibling.setRowHeight(this.rootNode.sibling.rowHeight, true);\n        }\n\n        // when pivotMode but pivot not active, root node is displayed on its own\n        // because it's only ever displayed alone, refreshing the model (onRowHeightChanged) is not required\n        if (atLeastOne) {\n            this.onRowHeightChanged();\n        }\n    }\n\n    private resetRowHeightsForAllRowNodes(): boolean {\n        let atLeastOne = false;\n        this.forEachNode(rowNode => {\n            rowNode.setRowHeight(rowNode.rowHeight, true);\n            // we keep the height each row is at, however we set estimated=true rather than clear the height.\n            // this means the grid will not reset the row heights back to defaults, rather it will re-calc\n            // the height for each row as the row is displayed. otherwise the scroll will jump when heights are reset.\n            const detailNode = rowNode.detailNode;\n            if (detailNode) {\n                detailNode.setRowHeight(detailNode.rowHeight, true);\n            }\n\n            if (rowNode.sibling) {\n                rowNode.sibling.setRowHeight(rowNode.sibling.rowHeight, true);\n            }\n            atLeastOne = true;\n        });\n\n        return atLeastOne;\n    }\n\n    private onGridStylesChanges() {\n        if (this.columnModel.isAutoRowHeightActive()) { return; }\n\n        this.resetRowHeights();\n    }\n\n    private onGridReady(): void {\n        if (this.hasStarted) { return; }\n        // App can start using API to add transactions, so need to add data into the node manager if not started\n        this.setInitialData();\n    }\n\n    public isRowDataLoaded(): boolean {\n        return this.rowCountReady;\n    }\n}\n", "import {\n    Beans, ColumnModel, Events,\n    EventService,\n    RowDataTransaction,\n    RowNode,\n    RowNodeTransaction,\n    SelectionChangedEvent,\n    _,\n    WithoutGridCommon,\n    GridOptionsService,\n    SelectionEventSourceType,\n    ISelectionService,\n    RowDataUpdateStartedEvent\n} from \"@ag-grid-community/core\";\n\nexport class ClientSideNodeManager {\n\n    private static TOP_LEVEL = 0;\n\n    private readonly rootNode: RowNode;\n\n    private gridOptionsService: GridOptionsService;\n    private eventService: EventService;\n    private columnModel: ColumnModel;\n    private selectionService: ISelectionService;\n    private beans: Beans;\n\n    private nextId = 0;\n\n    private static ROOT_NODE_ID = 'ROOT_NODE_ID';\n\n    // has row data actually been set\n    private rowCountReady = false;\n\n    // when user is provide the id's, we also keep a map of ids to row nodes for convenience\n    private allNodesMap: { [id: string]: RowNode } = {};\n\n    constructor(rootNode: RowNode, gridOptionsService: GridOptionsService, eventService: EventService,\n        columnModel: ColumnModel, selectionService: ISelectionService, beans: Beans) {\n        this.rootNode = rootNode;\n        this.gridOptionsService = gridOptionsService;\n        this.eventService = eventService;\n        this.columnModel = columnModel;\n        this.beans = beans;\n        this.selectionService = selectionService;\n\n        this.rootNode.group = true;\n        this.rootNode.level = -1;\n        this.rootNode.id = ClientSideNodeManager.ROOT_NODE_ID;\n        this.rootNode.allLeafChildren = [];\n        this.rootNode.childrenAfterGroup = [];\n        this.rootNode.childrenAfterSort = [];\n        this.rootNode.childrenAfterAggFilter = [];\n        this.rootNode.childrenAfterFilter = [];\n    }\n\n    public getCopyOfNodesMap(): { [id: string]: RowNode } {\n        return _.cloneObject(this.allNodesMap);\n    }\n\n    public getRowNode(id: string): RowNode | undefined {\n        return this.allNodesMap[id];\n    }\n\n    public setRowData(rowData: any[]): RowNode[] | undefined {\n        if (typeof rowData === 'string') {\n            console.warn('AG Grid: rowData must be an array, however you passed in a string. If you are loading JSON, make sure you convert the JSON string to JavaScript objects first');\n            return;\n        }\n        this.rowCountReady = true;\n\n        this.dispatchRowDataUpdateStartedEvent(rowData);\n\n        const rootNode = this.rootNode;\n        const sibling = this.rootNode.sibling;\n\n        rootNode.childrenAfterFilter = null;\n        rootNode.childrenAfterGroup = null;\n        rootNode.childrenAfterAggFilter = null;\n        rootNode.childrenAfterSort = null;\n        rootNode.childrenMapped = null;\n        rootNode.updateHasChildren();\n\n        this.nextId = 0;\n        this.allNodesMap = {};\n\n        if (rowData) {\n            // we use rootNode as the parent, however if using ag-grid-enterprise, the grouping stage\n            // sets the parent node on each row (even if we are not grouping). so setting parent node\n            // here is for benefit of ag-grid-community users\n            rootNode.allLeafChildren = rowData.map(dataItem => this.createNode(dataItem, this.rootNode, ClientSideNodeManager.TOP_LEVEL));\n        } else {\n            rootNode.allLeafChildren = [];\n            rootNode.childrenAfterGroup = [];\n        }\n\n        if (sibling) {\n            sibling.childrenAfterFilter = rootNode.childrenAfterFilter;\n            sibling.childrenAfterGroup = rootNode.childrenAfterGroup;\n            sibling.childrenAfterAggFilter = rootNode.childrenAfterAggFilter;\n            sibling.childrenAfterSort = rootNode.childrenAfterSort;\n            sibling.childrenMapped = rootNode.childrenMapped;\n            sibling.allLeafChildren = rootNode.allLeafChildren;\n        }\n    }\n\n    public updateRowData(rowDataTran: RowDataTransaction, rowNodeOrder: { [id: string]: number } | null | undefined): RowNodeTransaction {\n        this.rowCountReady = true;\n        this.dispatchRowDataUpdateStartedEvent(rowDataTran.add);\n\n        const rowNodeTransaction: RowNodeTransaction = {\n            remove: [],\n            update: [],\n            add: []\n        };\n\n        const nodesToUnselect: RowNode[] = [];\n\n        this.executeRemove(rowDataTran, rowNodeTransaction, nodesToUnselect);\n        this.executeUpdate(rowDataTran, rowNodeTransaction, nodesToUnselect);\n        this.executeAdd(rowDataTran, rowNodeTransaction);\n\n        this.updateSelection(nodesToUnselect, 'rowDataChanged');\n\n        if (rowNodeOrder) {\n            _.sortRowNodesByOrder(this.rootNode.allLeafChildren, rowNodeOrder);\n        }\n\n        return rowNodeTransaction;\n    }\n\n    public isRowCountReady(): boolean {\n        return this.rowCountReady;\n    }\n\n    private dispatchRowDataUpdateStartedEvent(rowData?: any[] | null): void {\n        const event: WithoutGridCommon<RowDataUpdateStartedEvent> = {\n            type: Events.EVENT_ROW_DATA_UPDATE_STARTED,\n            firstRowData: rowData?.length ? rowData[0] : null\n        };\n        this.eventService.dispatchEvent(event);\n    }\n\n    private updateSelection(nodesToUnselect: RowNode[], source: SelectionEventSourceType): void {\n        const selectionChanged = nodesToUnselect.length > 0;\n        if (selectionChanged) {\n            this.selectionService.setNodesSelected({\n                newValue: false,\n                nodes: nodesToUnselect,\n                suppressFinishActions: true,\n                source,\n            });\n        }\n\n        // we do this regardless of nodes to unselect or not, as it's possible\n        // a new node was inserted, so a parent that was previously selected (as all\n        // children were selected) should not be tri-state (as new one unselected against\n        // all other selected children).\n        this.selectionService.updateGroupsFromChildrenSelections(source);\n\n        if (selectionChanged) {\n            const event: WithoutGridCommon<SelectionChangedEvent> = {\n                type: Events.EVENT_SELECTION_CHANGED,\n                source: source\n            };\n            this.eventService.dispatchEvent(event);\n        }\n    }\n\n    private executeAdd(rowDataTran: RowDataTransaction, rowNodeTransaction: RowNodeTransaction): void {\n        const { add, addIndex } = rowDataTran;\n        if (_.missingOrEmpty(add)) { return; }\n\n        // create new row nodes for each data item\n        const newNodes: RowNode[] = add!.map(item => this.createNode(item, this.rootNode, ClientSideNodeManager.TOP_LEVEL));\n\n        if (typeof addIndex === 'number' && addIndex >= 0) {\n            // new rows are inserted in one go by concatenating them in between the existing rows at the desired index.\n            // this is much faster than splicing them individually into 'allLeafChildren' when there are large inserts.\n            const { allLeafChildren } = this.rootNode;\n            const len = allLeafChildren.length;\n            let normalisedAddIndex = addIndex;\n\n            const isTreeData = this.gridOptionsService.get('treeData');\n            if (isTreeData && addIndex > 0 && len > 0) {\n                for (let i = 0; i < len; i++) {\n                    if (allLeafChildren[i]?.rowIndex == addIndex - 1) { normalisedAddIndex = i + 1; break; }\n                }\n            }\n\n            const nodesBeforeIndex = allLeafChildren.slice(0, normalisedAddIndex);\n            const nodesAfterIndex = allLeafChildren.slice(normalisedAddIndex, allLeafChildren.length);\n            this.rootNode.allLeafChildren = [...nodesBeforeIndex, ...newNodes, ...nodesAfterIndex];\n        } else {\n            this.rootNode.allLeafChildren = [...this.rootNode.allLeafChildren, ...newNodes];\n        }\n        if (this.rootNode.sibling) {\n            this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren;\n        }\n        // add new row nodes to the transaction add items\n        rowNodeTransaction.add = newNodes;\n    }\n\n    private executeRemove(rowDataTran: RowDataTransaction, rowNodeTransaction: RowNodeTransaction, nodesToUnselect: RowNode[]): void {\n        const { remove } = rowDataTran;\n\n        if (_.missingOrEmpty(remove)) { return; }\n\n        const rowIdsRemoved: { [key: string]: boolean } = {};\n\n        remove!.forEach(item => {\n            const rowNode = this.lookupRowNode(item);\n\n            if (!rowNode) { return; }\n\n            // do delete - setting 'suppressFinishActions = true' to ensure EVENT_SELECTION_CHANGED is not raised for\n            // each row node updated, instead it is raised once by the calling code if any selected nodes exist.\n            if (rowNode.isSelected()) {\n                nodesToUnselect.push(rowNode);\n            }\n\n            // so row renderer knows to fade row out (and not reposition it)\n            rowNode.clearRowTopAndRowIndex();\n\n            // NOTE: were we could remove from allLeaveChildren, however _.removeFromArray() is expensive, especially\n            // if called multiple times (eg deleting lots of rows) and if allLeafChildren is a large list\n            rowIdsRemoved[rowNode.id!] = true;\n            // _.removeFromArray(this.rootNode.allLeafChildren, rowNode);\n            delete this.allNodesMap[rowNode.id!];\n\n            rowNodeTransaction.remove.push(rowNode);\n        });\n\n        this.rootNode.allLeafChildren = this.rootNode.allLeafChildren.filter(rowNode => !rowIdsRemoved[rowNode.id!]);\n        if (this.rootNode.sibling) {\n            this.rootNode.sibling.allLeafChildren = this.rootNode.allLeafChildren;\n        }\n    }\n\n    private executeUpdate(rowDataTran: RowDataTransaction, rowNodeTransaction: RowNodeTransaction, nodesToUnselect: RowNode[]): void {\n        const { update } = rowDataTran;\n        if (_.missingOrEmpty(update)) { return; }\n\n        update!.forEach(item => {\n            const rowNode = this.lookupRowNode(item);\n\n            if (!rowNode) { return; }\n\n            rowNode.updateData(item);\n            if (!rowNode.selectable && rowNode.isSelected()) {\n                nodesToUnselect.push(rowNode);\n            }\n\n            this.setMasterForRow(rowNode, item, ClientSideNodeManager.TOP_LEVEL, false);\n\n            rowNodeTransaction.update.push(rowNode);\n        });\n    }\n\n    private lookupRowNode(data: any): RowNode | null {\n        const getRowIdFunc = this.gridOptionsService.getCallback('getRowId');\n\n        let rowNode: RowNode | undefined;\n        if (getRowIdFunc) {\n            // find rowNode using id\n            const id: string = getRowIdFunc({ data, level: 0 });\n            rowNode = this.allNodesMap[id];\n            if (!rowNode) {\n                console.error(`AG Grid: could not find row id=${id}, data item was not found for this id`);\n                return null;\n            }\n        } else {\n            // find rowNode using object references\n            rowNode = this.rootNode.allLeafChildren.find(node => node.data === data);\n            if (!rowNode) {\n                console.error(`AG Grid: could not find data item as object was not found`, data);\n                console.error(`Consider using getRowId to help the Grid find matching row data`);\n                return null;\n            }\n        }\n\n        return rowNode || null;\n    }\n\n    private createNode(dataItem: any, parent: RowNode, level: number): RowNode {\n        const node = new RowNode(this.beans);\n\n        node.group = false;\n        this.setMasterForRow(node, dataItem, level, true);\n\n        const suppressParentsInRowNodes = this.gridOptionsService.get('suppressParentsInRowNodes');\n        if (parent && !suppressParentsInRowNodes) {\n            node.parent = parent;\n        }\n        node.level = level;\n        node.setDataAndId(dataItem, this.nextId.toString());\n\n        if (this.allNodesMap[node.id!]) {\n            console.warn(`AG Grid: duplicate node id '${node.id}' detected from getRowId callback, this could cause issues in your grid.`);\n        }\n        this.allNodesMap[node.id!] = node;\n\n        this.nextId++;\n\n        return node;\n    }\n\n    private setMasterForRow(rowNode: RowNode, data: any, level: number, setExpanded: boolean): void {\n        const isTreeData = this.gridOptionsService.get('treeData');\n        if (isTreeData) {\n            rowNode.setMaster(false);\n            if (setExpanded) {\n                rowNode.expanded = false;\n            }\n        } else {\n            const masterDetail = this.gridOptionsService.get('masterDetail');\n            // this is the default, for when doing grid data\n            if (masterDetail) {\n                // if we are doing master detail, then the\n                // default is that everything can be a Master Row.\n                const isRowMasterFunc = this.gridOptionsService.get('isRowMaster');\n                if (isRowMasterFunc) {\n                    rowNode.setMaster(isRowMasterFunc(data));\n                } else {\n                    rowNode.setMaster(true);\n                }\n            } else {\n                rowNode.setMaster(false);\n            }\n\n            if (setExpanded) {\n                const rowGroupColumns = this.columnModel.getRowGroupColumns();\n                const numRowGroupColumns = rowGroupColumns ? rowGroupColumns.length : 0;\n\n                // need to take row group into account when determining level\n                const masterRowLevel = level + numRowGroupColumns;\n\n                rowNode.expanded = rowNode.master ? this.isExpanded(masterRowLevel) : false;\n            }\n        }\n    }\n\n    private isExpanded(level: any) {\n        const expandByDefault = this.gridOptionsService.get('groupDefaultExpanded');\n        if (expandByDefault === -1) {\n            return true;\n        }\n        return level < expandByDefault;\n    }\n}\n", "import {\n    Autowired,\n    Bean,\n    IRowNodeStage,\n    StageExecuteParams,\n    BeanStub,\n    GridOptions\n} from \"@ag-grid-community/core\";\n\nimport { FilterService } from \"./filterService\";\n\n@Bean('filterStage')\nexport class FilterStage extends BeanStub implements IRowNodeStage {\n    @Autowired('filterService') private filterService: FilterService;\n\n    public execute(params: StageExecuteParams): void {\n        const { changedPath } = params;\n        this.filterService.filter(changedPath!);\n    }\n}\n", "import {\n    _,\n    Autowired,\n    Bean,\n    SortController,\n    StageExecuteParams,\n    BeanStub,\n    SortOption,\n    IRowNodeStage,\n    GridOptions\n} from \"@ag-grid-community/core\";\n\nimport { SortService } from \"./sortService\";\n\n@Bean('sortStage')\nexport class SortStage extends BeanStub implements IRowNodeStage {\n\n    @Autowired('sortService') private sortService: SortService;\n    @Autowired('sortController') private sortController: SortController;\n\n    public execute(params: StageExecuteParams): void {\n        const sortOptions: SortOption[] = this.sortController.getSortOptions();\n\n        const sortActive = _.exists(sortOptions) && sortOptions.length > 0;\n        const deltaSort = sortActive\n            && _.exists(params.rowNodeTransactions)\n            // in time we can remove this check, so that delta sort is always\n            // on if transactions are present. it's off for now so that we can\n            // selectively turn it on and test it with some select users before\n            // rolling out to everyone.\n            && this.gridOptionsService.get('deltaSort');\n\n\n        const sortContainsGroupColumns = sortOptions.some(opt => {\n            const isSortingCoupled = this.gridOptionsService.isColumnsSortingCoupledToGroup();\n            if (isSortingCoupled) {\n                return opt.column.isPrimary() && opt.column.isRowGroupActive();\n            }\n            return !!opt.column.getColDef().showRowGroup;\n        });\n        this.sortService.sort(sortOptions, sortActive, deltaSort, params.rowNodeTransactions, params.changedPath, sortContainsGroupColumns);\n    }\n}\n", "import {\n    _,\n    Autowired,\n    Bean,\n    BeanStub,\n    ColumnModel,\n    IRowNodeStage,\n    RowNode,\n    StageExecuteParams,\n    Beans,\n    WithoutGridCommon,\n    GetGroupIncludeFooterParams,\n    GridOptions\n} from \"@ag-grid-community/core\";\n\ninterface FlattenDetails {\n    hideOpenParents: boolean;\n    groupRemoveSingleChildren: boolean;\n    groupRemoveLowestSingleChildren: boolean;\n    groupIncludeTotalFooter: boolean;\n    isGroupMultiAutoColumn: boolean;\n    getGroupIncludeFooter: (params: WithoutGridCommon<GetGroupIncludeFooterParams<any, any>>) => boolean;\n}\n\n@Bean('flattenStage')\nexport class FlattenStage extends BeanStub implements IRowNodeStage {\n\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('beans') private beans: Beans;\n\n    public execute(params: StageExecuteParams): RowNode[] {\n        const rootNode = params.rowNode;\n\n        // even if not doing grouping, we do the mapping, as the client might\n        // of passed in data that already has a grouping in it somewhere\n        const result: RowNode[] = [];\n        const skipLeafNodes = this.columnModel.isPivotMode();\n        // if we are reducing, and not grouping, then we want to show the root node, as that\n        // is where the pivot values are\n        const showRootNode = skipLeafNodes && rootNode.leafGroup;\n        const topList = showRootNode ? [rootNode] : rootNode.childrenAfterSort;\n\n        const details = this.getFlattenDetails();\n\n        this.recursivelyAddToRowsToDisplay(details, topList, result, skipLeafNodes, 0);\n\n        // we do not want the footer total if the gris is empty\n        const atLeastOneRowPresent = result.length > 0;\n\n        const includeGroupTotalFooter = !showRootNode\n            // don't show total footer when showRootNode is true (i.e. in pivot mode and no groups)\n            && atLeastOneRowPresent\n            && details.groupIncludeTotalFooter;\n\n        if (includeGroupTotalFooter) {\n            rootNode.createFooter();\n            this.addRowNodeToRowsToDisplay(details, rootNode.sibling, result, 0);\n        }\n\n        return result;\n    }\n\n    private getFlattenDetails(): FlattenDetails {\n        // these two are mutually exclusive, so if first set, we don't set the second\n        const groupRemoveSingleChildren = this.gridOptionsService.get('groupRemoveSingleChildren');\n        const groupRemoveLowestSingleChildren = !groupRemoveSingleChildren && this.gridOptionsService.get('groupRemoveLowestSingleChildren');\n\n        return {\n            groupRemoveLowestSingleChildren,\n            groupRemoveSingleChildren,\n            isGroupMultiAutoColumn: this.gridOptionsService.isGroupMultiAutoColumn(),\n            hideOpenParents : this.gridOptionsService.get('groupHideOpenParents'),\n            groupIncludeTotalFooter : this.gridOptionsService.get('groupIncludeTotalFooter'),\n            getGroupIncludeFooter : this.gridOptionsService.getGroupIncludeFooter(),\n        };\n    }\n\n    private recursivelyAddToRowsToDisplay(\n        details: FlattenDetails,\n        rowsToFlatten: RowNode[] | null,\n        result: RowNode[],\n        skipLeafNodes: boolean,\n        uiLevel: number\n    ) {\n        if (_.missingOrEmpty(rowsToFlatten)) {\n            return;\n        }\n\n        for (let i = 0; i < rowsToFlatten!.length; i++) {\n            const rowNode = rowsToFlatten![i];\n            // check all these cases, for working out if this row should be included in the final mapped list\n            const isParent = rowNode.hasChildren();\n\n            const isSkippedLeafNode = skipLeafNodes && !isParent;\n\n            const isRemovedSingleChildrenGroup =\n                details.groupRemoveSingleChildren && isParent && rowNode.childrenAfterGroup!.length === 1;\n\n            const isRemovedLowestSingleChildrenGroup =\n                details.groupRemoveLowestSingleChildren &&\n                isParent &&\n                rowNode.leafGroup &&\n                rowNode.childrenAfterGroup!.length === 1;\n\n            // hide open parents means when group is open, we don't show it. we also need to make sure the\n            // group is expandable in the first place (as leaf groups are not expandable if pivot mode is on).\n            // the UI will never allow expanding leaf  groups, however the user might via the API (or menu option 'expand all row groups')\n            const neverAllowToExpand = skipLeafNodes && rowNode.leafGroup;\n\n            const isHiddenOpenParent = details.hideOpenParents && rowNode.expanded && !rowNode.master && !neverAllowToExpand;\n\n            const thisRowShouldBeRendered = !isSkippedLeafNode && !isHiddenOpenParent &&\n                !isRemovedSingleChildrenGroup && !isRemovedLowestSingleChildrenGroup;\n\n            if (thisRowShouldBeRendered) {\n                this.addRowNodeToRowsToDisplay(details, rowNode, result, uiLevel);\n            }\n\n            // if we are pivoting, we never map below the leaf group\n            if (skipLeafNodes && rowNode.leafGroup) { continue; }\n\n            if (isParent) {\n                const excludedParent = isRemovedSingleChildrenGroup || isRemovedLowestSingleChildrenGroup;\n\n                // we traverse the group if it is expended, however we always traverse if the parent node\n                // was removed (as the group will never be opened if it is not displayed, we show the children instead)\n                if (rowNode.expanded || excludedParent) {\n                    // if the parent was excluded, then ui level is that of the parent\n                    const uiLevelForChildren = excludedParent ? uiLevel : uiLevel + 1;\n                    this.recursivelyAddToRowsToDisplay(\n                        details,\n                        rowNode.childrenAfterSort,\n                        result,\n                        skipLeafNodes,\n                        uiLevelForChildren\n                    );\n\n                    // put a footer in if user is looking for it\n                    const doesRowShowFooter = details.getGroupIncludeFooter({ node: rowNode });\n                    if (doesRowShowFooter) {\n                        // ensure node is available.\n                        rowNode.createFooter();\n                        this.addRowNodeToRowsToDisplay(details, rowNode.sibling, result, uiLevelForChildren);\n                    } else {\n                        // remove node if it's unnecessary.\n                        rowNode.destroyFooter();\n                    }\n                }\n            } else if (rowNode.master && rowNode.expanded) {\n                const detailNode = this.createDetailNode(rowNode);\n                this.addRowNodeToRowsToDisplay(details, detailNode, result, uiLevel);\n            }\n        }\n    }\n\n    // duplicated method, it's also in floatingRowModel\n    private addRowNodeToRowsToDisplay(\n        details: FlattenDetails,\n        rowNode: RowNode,\n        result: RowNode[],\n        uiLevel: number\n    ): void {\n        result.push(rowNode);\n        rowNode.setUiLevel(details.isGroupMultiAutoColumn ? 0 : uiLevel);\n    }\n\n    private createDetailNode(masterNode: RowNode): RowNode {\n        if (_.exists(masterNode.detailNode)) { return masterNode.detailNode; }\n\n        const detailNode = new RowNode(this.beans);\n\n        detailNode.detail = true;\n        detailNode.selectable = false;\n        detailNode.parent = masterNode;\n\n        if (_.exists(masterNode.id)) {\n            detailNode.id = 'detail_' + masterNode.id;\n        }\n\n        detailNode.data = masterNode.data;\n        detailNode.level = masterNode.level + 1;\n        masterNode.detailNode = detailNode;\n\n        return detailNode;\n    }\n}", "import {\n    _,\n    RowNodeSorter,\n    SortedRowNode,\n    SortOption,\n    Autowired,\n    Bean,\n    ChangedPath,\n    ColumnModel,\n    PostConstruct,\n    RowNode,\n    BeanStub,\n    WithoutGridCommon,\n    PostSortRowsParams,\n    RowNodeTransaction,\n    IRowNode\n} from \"@ag-grid-community/core\";\n\n\n@Bean('sortService')\nexport class SortService extends BeanStub {\n\n    @Autowired('columnModel') private columnModel: ColumnModel;\n    @Autowired('rowNodeSorter') private rowNodeSorter: RowNodeSorter;\n\n    public sort(\n        sortOptions: SortOption[],\n        sortActive: boolean,\n        useDeltaSort: boolean,\n        rowNodeTransactions: RowNodeTransaction[] | null | undefined,\n        changedPath: ChangedPath | undefined,\n        sortContainsGroupColumns: boolean,\n    ): void {\n        const groupMaintainOrder = this.gridOptionsService.get('groupMaintainOrder');\n        const groupColumnsPresent = this.columnModel.getAllGridColumns().some(c => c.isRowGroupActive());\n\n        let allDirtyNodes: { [key: string]: true } = {};\n        if (useDeltaSort && rowNodeTransactions) {\n            allDirtyNodes = this.calculateDirtyNodes(rowNodeTransactions);\n        }\n\n        const isPivotMode = this.columnModel.isPivotMode();\n        const postSortFunc = this.gridOptionsService.getCallback('postSortRows');\n\n        const callback = (rowNode: RowNode) => {\n            // we clear out the 'pull down open parents' first, as the values mix up the sorting\n            this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterAggFilter, true);\n\n            // It's pointless to sort rows which aren't being displayed. in pivot mode we don't need to sort the leaf group children.\n            const skipSortingPivotLeafs = isPivotMode && rowNode.leafGroup;\n\n            // Javascript sort is non deterministic when all the array items are equals, ie Comparator always returns 0,\n            // so to ensure the array keeps its order, add an additional sorting condition manually, in this case we\n            // are going to inspect the original array position. This is what sortedRowNodes is for.\n            let skipSortingGroups = groupMaintainOrder && groupColumnsPresent && !rowNode.leafGroup && !sortContainsGroupColumns;\n            if (skipSortingGroups) {\n                const nextGroup = this.columnModel.getRowGroupColumns()?.[rowNode.level + 1];\n                // if the sort is null, then sort was explicitly removed, so remove sort from this group.\n                const wasSortExplicitlyRemoved =  nextGroup?.getSort() === null;\n\n                const childrenToBeSorted = rowNode.childrenAfterAggFilter!.slice(0);\n                if (rowNode.childrenAfterSort && !wasSortExplicitlyRemoved) {\n                    const indexedOrders: { [key:string]: number } = {};\n                    rowNode.childrenAfterSort.forEach((node, idx) => {\n                        indexedOrders[node.id!] = idx;\n                    });\n                    childrenToBeSorted.sort((row1, row2) => (indexedOrders[row1.id!] ?? 0) - (indexedOrders[row2.id!] ?? 0));\n                }\n                rowNode.childrenAfterSort = childrenToBeSorted;\n            } else if (!sortActive || skipSortingPivotLeafs) {\n                // if there's no sort to make, skip this step\n                rowNode.childrenAfterSort = rowNode.childrenAfterAggFilter!.slice(0);\n            } else if (useDeltaSort) {\n                rowNode.childrenAfterSort = this.doDeltaSort(rowNode, allDirtyNodes, changedPath!, sortOptions);\n            } else {\n                rowNode.childrenAfterSort = this.rowNodeSorter.doFullSort(rowNode.childrenAfterAggFilter!, sortOptions);\n            }\n\n            if (rowNode.sibling) {\n                rowNode.sibling.childrenAfterSort = rowNode.childrenAfterSort;\n            }\n\n            this.updateChildIndexes(rowNode);\n\n            if (postSortFunc) {\n                const params: WithoutGridCommon<PostSortRowsParams> = { nodes: rowNode.childrenAfterSort };\n                postSortFunc(params);\n            }\n        };\n\n        if (changedPath) {\n            changedPath.forEachChangedNodeDepthFirst(callback);\n        }\n\n        this.updateGroupDataForHideOpenParents(changedPath);\n    }\n\n    private calculateDirtyNodes(rowNodeTransactions?: RowNodeTransaction[] | null): { [nodeId: string]: true } {\n        const dirtyNodes: { [nodeId: string]: true } = {};\n\n        const addNodesFunc = (rowNodes: IRowNode[]) => {\n            if (rowNodes) {\n                rowNodes.forEach(rowNode => dirtyNodes[rowNode.id!] = true);\n            }\n        };\n\n        // all leaf level nodes in the transaction were impacted\n        if (rowNodeTransactions) {\n            rowNodeTransactions.forEach(tran => {\n                addNodesFunc(tran.add);\n                addNodesFunc(tran.update);\n                addNodesFunc(tran.remove);\n            });\n        }\n\n        return dirtyNodes;\n    }\n\n    private doDeltaSort(\n        rowNode: RowNode,\n        allTouchedNodes: { [rowId: string]: true },\n        changedPath: ChangedPath,\n        sortOptions: SortOption[],\n    ) {\n        const unsortedRows = rowNode.childrenAfterAggFilter!;\n        const oldSortedRows = rowNode.childrenAfterSort;\n        if (!oldSortedRows) {\n            return this.rowNodeSorter.doFullSort(unsortedRows, sortOptions);\n        }\n\n        const untouchedRowsMap: { [rowId: string]: true } = {};\n        const touchedRows: RowNode[] = [];\n\n        unsortedRows.forEach(row => {\n            if (allTouchedNodes[row.id!] || !changedPath.canSkip(row)) {\n                touchedRows.push(row);\n            } else {\n                untouchedRowsMap[row.id!] = true;\n            }\n        });\n\n        const sortedUntouchedRows = oldSortedRows.filter(child => untouchedRowsMap[child.id!]);\n        \n        const mapNodeToSortedNode = (rowNode: RowNode, pos: number): SortedRowNode => (\n            { currentPos: pos, rowNode: rowNode }\n        );\n\n        const sortedChangedRows = touchedRows\n            .map(mapNodeToSortedNode)\n            .sort((a, b) => this.rowNodeSorter.compareRowNodes(sortOptions, a, b));\n\n        return this.mergeSortedArrays(\n            sortOptions,\n            sortedChangedRows,\n            sortedUntouchedRows.map(mapNodeToSortedNode)\n        ).map(({ rowNode }) => rowNode);\n    }\n\n    // Merge two sorted arrays into each other\n    private mergeSortedArrays(sortOptions: SortOption[], arr1: SortedRowNode[], arr2: SortedRowNode[]) {\n        const res = [];\n        let i = 0;\n        let j = 0;\n\n        // Traverse both array, adding them in order\n        while (i < arr1.length && j < arr2.length) {\n\n            // Check if current element of first\n            // array is smaller than current element\n            // of second array. If yes, store first\n            // array element and increment first array\n            // index. Otherwise do same with second array\n            const compareResult = this.rowNodeSorter.compareRowNodes(sortOptions, arr1[i], arr2[j]);\n            if (compareResult < 0) {\n                res.push(arr1[i++]);\n            } else {\n                res.push(arr2[j++]);\n            }\n        }\n\n        // add remaining from arr1\n        while (i < arr1.length) {\n            res.push(arr1[i++]);\n        }\n\n        // add remaining from arr2\n        while (j < arr2.length) {\n            res.push(arr2[j++]);\n        }\n\n        return res;\n    }\n\n    private updateChildIndexes(rowNode: RowNode) {\n        if (_.missing(rowNode.childrenAfterSort)) {\n            return;\n        }\n\n        const listToSort = rowNode.childrenAfterSort;\n        for (let i = 0; i < listToSort.length; i++) {\n            const child = listToSort[i];\n            const firstChild = i === 0;\n            const lastChild = i === rowNode.childrenAfterSort.length - 1;\n            child.setFirstChild(firstChild);\n            child.setLastChild(lastChild);\n            child.setChildIndex(i);\n        }\n    }\n\n    private updateGroupDataForHideOpenParents(changedPath?: ChangedPath) {\n        if (!this.gridOptionsService.get('groupHideOpenParents')) {\n            return;\n        }\n\n        if (this.gridOptionsService.get('treeData')) {\n            _.warnOnce(`The property hideOpenParents dose not work with Tree Data. This is because Tree Data has values at the group level, it doesn't make sense to hide them.`);\n            return false;\n        }\n\n        // recurse breadth first over group nodes after sort to 'pull down' group data to child groups\n        const callback = (rowNode: RowNode) => {\n            this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterSort, false);\n            rowNode.childrenAfterSort!.forEach(child => {\n                if (child.hasChildren()) {\n                    callback(child);\n                }\n            });\n        };\n\n        if (changedPath) {\n            changedPath.executeFromRootNode(rowNode => callback(rowNode));\n        }\n    }\n\n    private pullDownGroupDataForHideOpenParents(rowNodes: RowNode[] | null, clearOperation: boolean) {\n        if (!this.gridOptionsService.get('groupHideOpenParents') || _.missing(rowNodes)) { return; }\n\n        rowNodes.forEach(childRowNode => {\n            const groupDisplayCols = this.columnModel.getGroupDisplayColumns();\n            groupDisplayCols.forEach(groupDisplayCol => {\n\n                const showRowGroup = groupDisplayCol.getColDef().showRowGroup;\n                if (typeof showRowGroup !== 'string') {\n                    console.error('AG Grid: groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup');\n                    return;\n                }\n\n                const displayingGroupKey = showRowGroup;\n                const rowGroupColumn = this.columnModel.getPrimaryColumn(displayingGroupKey);\n                const thisRowNodeMatches = rowGroupColumn === childRowNode.rowGroupColumn;\n\n                if (thisRowNodeMatches) { return; }\n\n                if (clearOperation) {\n                    // if doing a clear operation, we clear down the value for every possible group column\n                    childRowNode.setGroupValue(groupDisplayCol.getId(), undefined);\n                } else {\n                    // if doing a set operation, we set only where the pull down is to occur\n                    const parentToStealFrom = childRowNode.getFirstChildOfFirstChild(rowGroupColumn);\n                    if (parentToStealFrom) {\n                        childRowNode.setGroupValue(groupDisplayCol.getId(), parentToStealFrom.key);\n                    }\n                }\n            });\n        });\n    }\n}\n", "import {\n    Autowired,\n    Bean,\n    ChangedPath,\n    FilterManager,\n    RowNode,\n    BeanStub\n} from \"@ag-grid-community/core\";\n\n@Bean(\"filterService\")\nexport class FilterService extends BeanStub {\n\n    @Autowired('filterManager') private filterManager: FilterManager;\n\n    public filter(changedPath: ChangedPath): void {\n        const filterActive: boolean = this.filterManager.isChildFilterPresent();\n        this.filterNodes(filterActive, changedPath);\n    }\n\n    private filterNodes(filterActive: boolean, changedPath: ChangedPath): void {\n\n        const filterCallback = (rowNode: RowNode, includeChildNodes: boolean) => {\n            // recursively get all children that are groups to also filter\n            if (rowNode.hasChildren()) {\n\n                // result of filter for this node. when filtering tree data, includeChildNodes = true when parent passes\n                if (filterActive && !includeChildNodes) {\n                    rowNode.childrenAfterFilter = rowNode.childrenAfterGroup!.filter(childNode => {\n                        // a group is included in the result if it has any children of it's own.\n                        // by this stage, the child groups are already filtered\n                        const passBecauseChildren = childNode.childrenAfterFilter && childNode.childrenAfterFilter.length > 0;\n\n                        // both leaf level nodes and tree data nodes have data. these get added if\n                        // the data passes the filter\n                        const passBecauseDataPasses = childNode.data\n                            && this.filterManager.doesRowPassFilter({rowNode: childNode});\n\n                        // note - tree data nodes pass either if a) they pass themselves or b) any children of that node pass\n\n                        return passBecauseChildren || passBecauseDataPasses;\n                    });\n                } else {\n                    // if not filtering, the result is the original list\n                    rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;\n                }\n\n            } else {\n                rowNode.childrenAfterFilter = rowNode.childrenAfterGroup;\n            }\n\n            if (rowNode.sibling) {\n                rowNode.sibling.childrenAfterFilter = rowNode.childrenAfterFilter;\n            }\n        };\n\n        if (this.doingTreeDataFiltering()) {\n\n            const treeDataDepthFirstFilter = (rowNode: RowNode, alreadyFoundInParent: boolean) => {\n                // tree data filter traverses the hierarchy depth first and includes child nodes if parent passes\n                // filter, and parent nodes will be include if any children exist.\n\n                if (rowNode.childrenAfterGroup) {\n                    for (let i = 0; i < rowNode.childrenAfterGroup.length; i++) {\n                        const childNode = rowNode.childrenAfterGroup[i];\n\n                        // first check if current node passes filter before invoking child nodes\n                        const foundInParent = alreadyFoundInParent\n                            || this.filterManager.doesRowPassFilter({rowNode: childNode});\n                        if (childNode.childrenAfterGroup) {\n                            treeDataDepthFirstFilter(rowNode.childrenAfterGroup[i], foundInParent);\n                        } else {\n                            filterCallback(childNode, foundInParent);\n                        }\n                    }\n                }\n                filterCallback(rowNode, alreadyFoundInParent);\n            };\n\n            const treeDataFilterCallback = (rowNode: RowNode) => treeDataDepthFirstFilter(rowNode, false);\n            changedPath.executeFromRootNode(treeDataFilterCallback);\n        } else {\n\n            const defaultFilterCallback = (rowNode: RowNode) => filterCallback(rowNode, false);\n            changedPath.forEachChangedNodeDepthFirst(defaultFilterCallback, true);\n        }\n    }\n\n    private doingTreeDataFiltering() {\n        return this.gridOptionsService.get('treeData') && !this.gridOptionsService.get('excludeChildrenWhenTreeDataFiltering');\n    }\n}\n", "import {\n    Autowired,\n    Bean,\n    BeanStub,\n    IImmutableService,\n    IRowModel,\n    ISelectionService,\n    PostConstruct,\n    RowDataTransaction,\n    RowNode, RowRenderer, _\n} from \"@ag-grid-community/core\";\nimport { ClientSideRowModel } from \"./clientSideRowModel\";\n\n\n@Bean('immutableService')\nexport class ImmutableService extends BeanStub implements IImmutableService {\n\n    @Autowired('rowModel') private rowModel: IRowModel;\n    @Autowired('rowRenderer') private rowRenderer: RowRenderer;\n    @Autowired('selectionService') private selectionService: ISelectionService;\n\n    private clientSideRowModel: ClientSideRowModel;\n\n    @PostConstruct\n    private postConstruct(): void {\n        if (this.rowModel.getType() === 'clientSide') {\n            this.clientSideRowModel = this.rowModel as ClientSideRowModel;\n\n            this.addManagedPropertyListener('rowData', () => this.onRowDataUpdated());\n        }\n    }\n\n    public isActive(): boolean {\n        const getRowIdProvided = this.gridOptionsService.exists('getRowId');        \n        // this property is a backwards compatibility property, for those who want\n        // the old behaviour of Row ID's but NOT Immutable Data.\n        const resetRowDataOnUpdate = this.gridOptionsService.get('resetRowDataOnUpdate');\n\n        if (resetRowDataOnUpdate) { return false; }\n        return getRowIdProvided;\n    }\n\n    public setRowData(rowData: any[]): void {\n        const transactionAndMap = this.createTransactionForRowData(rowData);\n        if (!transactionAndMap) { return; }\n\n        const [transaction, orderIdMap] = transactionAndMap;\n        this.clientSideRowModel.updateRowData(transaction, orderIdMap);\n    }\n\n    // converts the setRowData() command to a transaction\n    private createTransactionForRowData(rowData: any[]): ([RowDataTransaction, { [id: string]: number } | undefined]) | undefined {\n        if (_.missing(this.clientSideRowModel)) {\n            console.error('AG Grid: ImmutableService only works with ClientSideRowModel');\n            return;\n        }\n\n        const getRowIdFunc = this.gridOptionsService.getCallback('getRowId');\n        if (getRowIdFunc == null) {\n            console.error('AG Grid: ImmutableService requires getRowId() callback to be implemented, your row data needs IDs!');\n            return;\n        }\n\n        // convert the data into a transaction object by working out adds, removes and updates\n        const transaction: RowDataTransaction = {\n            remove: [],\n            update: [],\n            add: []\n        };\n\n        const existingNodesMap: { [id: string]: RowNode | undefined } = this.clientSideRowModel.getCopyOfNodesMap();\n\n        const suppressSortOrder = this.gridOptionsService.get('suppressMaintainUnsortedOrder');\n        const orderMap: { [id: string]: number } | undefined = suppressSortOrder ? undefined : {};\n\n        if (_.exists(rowData)) {\n            // split all the new data in the following:\n            // if new, push to 'add'\n            // if update, push to 'update'\n            // if not changed, do not include in the transaction\n            rowData.forEach((data: any, index: number) => {\n                const id: string = getRowIdFunc({ data, level: 0 });\n                const existingNode: RowNode | undefined = existingNodesMap[id];\n\n                if (orderMap) {\n                    orderMap[id] = index;\n                }\n\n                if (existingNode) {\n                    const dataHasChanged = existingNode.data !== data;\n                    if (dataHasChanged) {\n                        transaction.update!.push(data);\n                    }\n                    // otherwise, if data not changed, we just don't include it anywhere, as it's not a delta\n\n                    // remove from list, so we know the item is not to be removed\n                    existingNodesMap[id] = undefined;\n                } else {\n                    transaction.add!.push(data);\n                }\n            });\n        }\n\n        // at this point, all rows that are left, should be removed\n        _.iterateObject(existingNodesMap, (id: string, rowNode: RowNode) => {\n            if (rowNode) {\n                transaction.remove!.push(rowNode.data);\n            }\n        });\n\n        return [transaction, orderMap];\n    }\n\n    private onRowDataUpdated(): void {\n        const rowData = this.gridOptionsService.get('rowData');\n        if (!rowData) { return; }\n\n        if (this.isActive()) {\n            this.setRowData(rowData);\n        } else {\n            this.selectionService.reset('rowDataChanged');\n            this.clientSideRowModel.setRowData(rowData);\n        }\n    }\n}\n", "// DO NOT UPDATE MANUALLY: Generated from script during build time\nexport const VERSION = '31.2.0';"],
  "mappings": "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",
  "names": ["import_core", "import_core", "import_core", "import_core", "import_core", "import_core", "_a", "rowNode", "import_core", "import_core"]
}
