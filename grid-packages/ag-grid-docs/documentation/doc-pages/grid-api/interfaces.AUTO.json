{
  "ApplyColumnStateParams": {
    "meta": {},
    "type": {
      "state?": "ColumnState[]",
      "applyOrder?": "boolean",
      "defaultState?": "ColumnState"
    },
    "docs": {
      "state?": "/** The state from `getColumnState` */",
      "applyOrder?": "/** Whether column order should be applied */",
      "defaultState?": "/** State to apply to columns where state is missing for those columns */"
    }
  },
  "ColumnResizeSet": {
    "meta": {},
    "type": { "columns": "Column[]", "ratios": "number[]", "width": "number" }
  },
  "ColumnState": {
    "meta": {},
    "type": {
      "colId?": "string",
      "hide?": "boolean | null",
      "width?": "number",
      "flex?": "number | null",
      "sort?": "string | null",
      "sortIndex?": "number | null",
      "aggFunc?": "string | IAggFunc | null",
      "pivot?": "boolean | null",
      "pivotIndex?": "number | null",
      "pinned?": "boolean | string | 'left' | 'right' | null",
      "rowGroup?": "boolean | null",
      "rowGroupIndex?": "number | null"
    },
    "docs": {
      "colId?": "/** ID of the column */",
      "hide?": "/** True if the column is hidden */",
      "width?": "/** Width of the column in pixels */",
      "flex?": "/** Column's flex if flex is set */",
      "sort?": "/** Sort applied to the column */",
      "sortIndex?": "/** The order of the sort, if sorting by many columns */",
      "aggFunc?": "/** The aggregation function applied */",
      "pivot?": "/** True if pivot active */",
      "pivotIndex?": "/** The order of the pivot, if pivoting by many columns */",
      "pinned?": "/** Set if column is pinned */",
      "rowGroup?": "/** True if row group active */",
      "rowGroupIndex?": "/** The order of the row group, if grouping by many columns */"
    }
  },
  "ComponentMetadata": {
    "meta": {},
    "type": {
      "mandatoryMethodList": "string[]",
      "optionalMethodList": "string[]",
      "functionAdapter?": "(callback: any) => { new (): IComponent<any>; }"
    }
  },
  "ComponentType": {
    "meta": {},
    "type": { "propertyName": "string", "isCellRenderer()": "boolean" }
  },
  "FrameworkComponentWrapper": {
    "meta": {
      "doc": "/** B the business interface (ie IHeader)\n * A the agGridComponent interface (ie IHeaderComp). The final object acceptable by ag-grid */"
    },
    "type": {
      "wrap(frameworkComponent: { new (): any; } | null, methodList: string[], optionalMethodList: string[], componentType: ComponentType, componentName?: string | null)": "A"
    }
  },
  "WrappableInterface": {
    "meta": {},
    "type": {
      "hasMethod(name: string)": "boolean",
      "callMethod(name: string, args: IArguments)": "void",
      "addMethod(name: string, callback: Function)": "void"
    }
  },
  "DefinitionObject": {
    "meta": { "isTypeAlias": true },
    "type": "GridOptions | ColDef | ColGroupDef | IFilterDef | ISetFilterParams | IRichCellEditorParams | ToolPanelDef | StatusPanelDef"
  },
  "UserCompDetails": {
    "meta": {},
    "type": {
      "componentClass": "any",
      "componentFromFramework": "boolean",
      "params": "any",
      "type": "ComponentType"
    }
  },
  "RegisteredComponent": {
    "meta": {
      "doc": "/** B the business interface (ie IHeader)\n * A the agGridComponent interface (ie IHeaderComp). The final object acceptable by ag-grid */"
    },
    "type": { "component": "any", "componentFromFramework": "boolean" }
  },
  "DeprecatedComponentName": {
    "meta": {},
    "type": { "propertyHolder": "string", "newComponentName": "string" }
  },
  "ContextParams": {
    "meta": {},
    "type": {
      "providedBeanInstances": "any",
      "beanClasses": "any[]",
      "debug": "boolean"
    }
  },
  "ComponentMeta": {
    "meta": {},
    "type": { "componentClass": "new () => Object", "componentName": "string" }
  },
  "ControllerMeta": {
    "meta": {},
    "type": {
      "controllerClass": "new () => Object",
      "controllerName": "string"
    }
  },
  "BeanWrapper": {
    "meta": {},
    "type": { "bean": "any", "beanInstance": "any", "beanName": "any" }
  },
  "ReadyParams": {
    "meta": {},
    "type": {
      "gridCtrl": "GridCtrl",
      "gridBodyCtrl": "GridBodyCtrl",
      "centerRowContainerCtrl": "RowContainerCtrl",
      "leftRowContainerCtrl": "RowContainerCtrl",
      "rightRowContainerCtrl": "RowContainerCtrl",
      "bottomCenterRowContainerCtrl": "RowContainerCtrl",
      "bottomLeftRowContainerCtrl": "RowContainerCtrl",
      "bottomRightRowContainerCtrl": "RowContainerCtrl",
      "topCenterRowContainerCtrl": "RowContainerCtrl",
      "topLeftRowContainerCtrl": "RowContainerCtrl",
      "topRightRowContainerCtrl": "RowContainerCtrl",
      "fakeHScrollCtrl": "FakeHScrollCtrl",
      "gridHeaderCtrl": "GridHeaderCtrl",
      "centerHeaderRowContainerCtrl": "HeaderRowContainerCtrl",
      "leftHeaderRowContainerCtrl": "HeaderRowContainerCtrl",
      "rightHeaderRowContainerCtrl": "HeaderRowContainerCtrl"
    }
  },
  "DragItem": {
    "meta": {},
    "type": {
      "rowNode?": "RowNode",
      "rowNodes?": "RowNode[]",
      "columns?": "Column[]",
      "visibleState?": "{ [key: string]: boolean; }"
    },
    "docs": {
      "rowNode?": "/** When dragging a row, this contains the row node being dragged\n * When dragging multiple rows, this contains the row that started the drag. */",
      "rowNodes?": "/** When dragging multiple rows, this contains all rows being dragged */",
      "columns?": "/** When dragging columns, this contains the columns being dragged */",
      "visibleState?": "/** When dragging columns, this contains the visible state of the columns */"
    }
  },
  "DragSourceType": {
    "meta": { "isEnum": true },
    "type": ["ToolPanel", "HeaderCell", "RowDrag", "ChartPanel"],
    "docs": [null, null, null, null]
  },
  "DragSource": {
    "meta": {},
    "type": {
      "type": "DragSourceType",
      "eElement": "HTMLElement",
      "getDragItem": "() => DragItem",
      "dragItemName": "string | (() => string) | null",
      "defaultIconName?": "string",
      "dragSourceDropTarget?": "DropTarget",
      "dragSourceDomDataKey?": "string",
      "dragStartPixels?": "number",
      "onDragStarted?": "() => void",
      "onDragStopped?": "() => void"
    },
    "docs": {
      "type": "/** The type of the drag source, used by the drop target to know where the\n * drag originated from. */",
      "eElement": "/** Element which, when dragged, will kick off the DnD process */",
      "getDragItem": "/** If eElement is dragged, then the dragItem is the object that gets passed around. */",
      "dragItemName": "/** This name appears in the ghost icon when dragging. */",
      "defaultIconName?": "/** Icon to show when not over a drop zone */",
      "dragSourceDropTarget?": "/** The drop target associated with this dragSource. When dragging starts, this\n * target does not get an onDragEnter event. */",
      "dragSourceDomDataKey?": "/** The drag source DOM Data Key, this is useful to detect if the origin grid is the same\n * as the target grid. */",
      "dragStartPixels?": "/** After how many pixels of dragging should the drag operation start. Default is 4. */",
      "onDragStarted?": "/** Callback for drag started */",
      "onDragStopped?": "/** Callback for drag stopped */"
    }
  },
  "DropTarget": {
    "meta": {},
    "type": {
      "getContainer()": "HTMLElement",
      "getSecondaryContainers?()": "HTMLElement[][]",
      "getIconName?()": "string | null",
      "isInterestedIn(type: DragSourceType)": "boolean",
      "onDragEnter?(params: DraggingEvent)": "void",
      "onDragLeave?(params: DraggingEvent)": "void",
      "onDragging?(params: DraggingEvent)": "void",
      "onDragStop?(params: DraggingEvent)": "void",
      "external?": "boolean"
    },
    "docs": {
      "getContainer()": "/** The main container that will get the drop. */",
      "getSecondaryContainers?()": "/** If any secondary containers. For example when moving columns in AG Grid, we listen for drops\n * in the header as well as the body (main rows and pinned rows) of the grid. */",
      "getIconName?()": "/** Icon to show when drag is over */",
      "onDragEnter?(params: DraggingEvent)": "/** Callback for when drag enters */",
      "onDragLeave?(params: DraggingEvent)": "/** Callback for when drag leaves */",
      "onDragging?(params: DraggingEvent)": "/** Callback for when dragging */",
      "onDragStop?(params: DraggingEvent)": "/** Callback for when drag stops */"
    }
  },
  "VerticalDirection": {
    "meta": { "isEnum": true },
    "type": ["Up", "Down"],
    "docs": [null, null]
  },
  "HorizontalDirection": {
    "meta": { "isEnum": true },
    "type": ["Left", "Right"],
    "docs": [null, null]
  },
  "DraggingEvent": {
    "meta": {},
    "type": {
      "event": "MouseEvent",
      "x": "number",
      "y": "number",
      "vDirection": "VerticalDirection | null",
      "hDirection": "HorizontalDirection | null",
      "dragSource": "DragSource",
      "dragItem": "DragItem",
      "fromNudge": "boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "dropZoneTarget": "HTMLElement"
    }
  },
  "DragSourceAndListener": {
    "meta": {},
    "type": {
      "dragSource": "DragListenerParams",
      "mouseDownListener": "(mouseEvent: MouseEvent) => void",
      "touchEnabled": "boolean",
      "touchStartListener": "((touchEvent: TouchEvent) => void) | null"
    }
  },
  "DragListenerParams": {
    "meta": {},
    "type": {
      "dragStartPixels?": "number",
      "eElement": "HTMLElement",
      "skipMouseEvent?": "(mouseEvent: MouseEvent) => boolean",
      "onDragStart": "(mouseEvent: MouseEvent | Touch) => void",
      "onDragStop": "(mouseEvent: MouseEvent | Touch) => void",
      "onDragging": "(mouseEvent: MouseEvent | Touch) => void"
    },
    "docs": {
      "dragStartPixels?": "/** After how many pixels of dragging should the drag operation start. Default is 4px. */",
      "eElement": "/** Dom element to add the drag handling to */",
      "skipMouseEvent?": "/** Some places may wish to ignore certain events, eg range selection ignores shift clicks */",
      "onDragStart": "/** Callback for drag starting */",
      "onDragStop": "/** Callback for drag stopping */",
      "onDragging": "/** Callback for mouse move while dragging */"
    }
  },
  "CellPosition": {
    "meta": {},
    "type": {
      "column": "Column",
      "rowIndex": "number",
      "rowPinned": "string | null"
    },
    "docs": {
      "column": "/** The grid column */",
      "rowIndex": "/** A positive number from 0 to n, where n is the last row the grid is rendering\n * or -1 if you want to navigate to the grid header */",
      "rowPinned": "/** Either 'top', 'bottom' or null (for not pinned) */"
    }
  },
  "AbstractColDef": {
    "meta": {
      "doc": "/** *********************************************************************\n * Don't forget to update ColDefUtil if changing this class. PLEASE! *\n * ********************************************************************* */\n/** AbstractColDef can be a group or a column definition */"
    },
    "type": {
      "headerName?": "string",
      "columnGroupShow?": "string",
      "headerClass?": "HeaderClass",
      "toolPanelClass?": "ToolPanelClass",
      "headerValueGetter?": "string | HeaderValueGetterFunc",
      "pivotKeys?": "string[]",
      "suppressColumnsToolPanel?": "boolean",
      "suppressFiltersToolPanel?": "boolean",
      "headerTooltip?": "string",
      "tooltipComponent?": "{ new (): ITooltipComp; } | string",
      "tooltipComponentFramework?": "any",
      "tooltipComponentParams?": "any",
      "suppressHeaderKeyboardEvent?": "(params: SuppressHeaderKeyboardEventParams) => boolean"
    },
    "docs": {
      "headerName?": "/** The name to render in the column header */",
      "columnGroupShow?": "/** Whether to show the column when the group is open / closed. */",
      "headerClass?": "/** CSS class for the header */",
      "toolPanelClass?": "/** CSS class for the toolPanel */",
      "headerValueGetter?": "/** Expression or function to get the value for display in the header. */",
      "pivotKeys?": "/** Never set this, it is used internally by grid when doing in-grid pivoting */",
      "suppressColumnsToolPanel?": "/** Set to true to not include this column in the Columns Tool Panel */",
      "suppressFiltersToolPanel?": "/** Set to true to not include this column / filter in the Filters Tool Panel */",
      "headerTooltip?": "/** Tooltip for the column header */",
      "suppressHeaderKeyboardEvent?": "/** Allows the user to suppress certain keyboard events in the grid header */"
    }
  },
  "ColGroupDef": {
    "meta": {},
    "type": {
      "children": "(ColDef | ColGroupDef)[]",
      "groupId?": "string",
      "openByDefault?": "boolean",
      "marryChildren?": "boolean",
      "headerGroupComponent?": "string | { new (): IHeaderGroupComp; }",
      "headerGroupComponentFramework?": "any",
      "headerGroupComponentParams?": "any",
      "headerName?": "string",
      "columnGroupShow?": "string",
      "headerClass?": "HeaderClass",
      "toolPanelClass?": "ToolPanelClass",
      "headerValueGetter?": "string | HeaderValueGetterFunc",
      "pivotKeys?": "string[]",
      "suppressColumnsToolPanel?": "boolean",
      "suppressFiltersToolPanel?": "boolean",
      "headerTooltip?": "string",
      "tooltipComponent?": "{ new (): ITooltipComp; } | string",
      "tooltipComponentFramework?": "any",
      "tooltipComponentParams?": "any",
      "suppressHeaderKeyboardEvent?": "(params: SuppressHeaderKeyboardEventParams) => boolean"
    },
    "docs": {
      "children": "/** Columns in this group */",
      "groupId?": "/** Group ID */",
      "openByDefault?": "/** Open by Default */",
      "marryChildren?": "/** If true, group cannot be broken up by column moving, child columns will always appear side by side, however you can rearrange child columns within the group */",
      "headerGroupComponent?": "/** The custom header group component to be used for rendering the component header. If none specified the default AG Grid is used* */",
      "headerGroupComponentFramework?": "/** The custom header group component to be used for rendering the component header in the hosting framework (ie: React/Angular). If none specified the default AG Grid is used* */",
      "headerGroupComponentParams?": "/** The custom header group component to be used for rendering the component header. If none specified the default AG Grid is used* */",
      "headerName?": "/** The name to render in the column header */",
      "columnGroupShow?": "/** Whether to show the column when the group is open / closed. */",
      "headerClass?": "/** CSS class for the header */",
      "toolPanelClass?": "/** CSS class for the toolPanel */",
      "headerValueGetter?": "/** Expression or function to get the value for display in the header. */",
      "pivotKeys?": "/** Never set this, it is used internally by grid when doing in-grid pivoting */",
      "suppressColumnsToolPanel?": "/** Set to true to not include this column in the Columns Tool Panel */",
      "suppressFiltersToolPanel?": "/** Set to true to not include this column / filter in the Filters Tool Panel */",
      "headerTooltip?": "/** Tooltip for the column header */",
      "suppressHeaderKeyboardEvent?": "/** Allows the user to suppress certain keyboard events in the grid header */"
    }
  },
  "IAggFunc": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "params": "IAggFuncParams" }, "returnType": "any" }
  },
  "IAggFuncParams": {
    "meta": {},
    "type": {
      "values": "any[]",
      "column": "Column",
      "colDef": "ColDef",
      "rowNode": "RowNode",
      "data": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "values": "/** Values to aggregate */",
      "column": "/** Column the aggregation function is working on */",
      "colDef": "/** ColDef of the aggregation column */",
      "rowNode": "/** The parent RowNode, where the aggregation result will be shown */",
      "data": "/** data (if any) of the parent RowNode */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "HeaderClassParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "colDef": "AbstractColDef",
      "column?": "Column | null",
      "columnGroup?": "ColumnGroup | ProvidedColumnGroup | null",
      "context?": "any"
    }
  },
  "HeaderClass": {
    "meta": { "isTypeAlias": true },
    "type": "string | string[] | ((params: HeaderClassParams) => string | string[])"
  },
  "ToolPanelClassParams": {
    "meta": {},
    "type": {
      "api": "GridApi",
      "colDef": "AbstractColDef",
      "column?": "Column | null",
      "columnGroup?": "ColumnGroup | ProvidedColumnGroup | null",
      "context?": "any"
    }
  },
  "ToolPanelClass": {
    "meta": { "isTypeAlias": true },
    "type": "string | string[] | ((params: ToolPanelClassParams) => string | string[])"
  },
  "ColDef": {
    "meta": {
      "doc": "/** *********************************************************************\n * Don't forget to update ColDefUtil if changing this class. PLEASE! *\n * ********************************************************************* */"
    },
    "type": {
      "colId?": "string",
      "sort?": "string | null",
      "initialSort?": "string",
      "sortIndex?": "number | null",
      "initialSortIndex?": "number",
      "sortedAt?": "number",
      "sortingOrder?": "(string | null)[]",
      "field?": "string",
      "type?": "string | string[]",
      "hide?": "boolean",
      "initialHide?": "boolean",
      "pinned?": "boolean | string | null",
      "initialPinned?": "boolean | string",
      "tooltipField?": "string",
      "tooltipValueGetter?": "(params: ITooltipParams) => string",
      "valueGetter?": "string | ValueGetterFunc",
      "filterValueGetter?": "string | ValueGetterFunc",
      "valueSetter?": "string | ValueSetterFunc",
      "keyCreator?": "(params: KeyCreatorParams) => string",
      "width?": "number",
      "initialWidth?": "number",
      "minWidth?": "number",
      "maxWidth?": "number",
      "flex?": "number",
      "initialFlex?": "number",
      "autoHeight?": "boolean",
      "wrapText?": "boolean",
      "cellClass?": "string | string[] | CellClassFunc",
      "cellStyle?": "{ [cssProperty: string]: string; } | CellStyleFunc",
      "cellRenderer?": "{ new (): ICellRendererComp; } | ICellRendererFunc | string",
      "cellRendererFramework?": "any",
      "cellRendererParams?": "any",
      "cellRendererSelector?": "CellRendererSelectorFunc",
      "cellEditor?": "string | { new (): ICellEditorComp; }",
      "cellEditorFramework?": "any",
      "cellEditorParams?": "any",
      "cellEditorSelector?": "CellEditorSelectorFunc",
      "cellEditorPopup?": "boolean",
      "cellEditorPopupPosition?": "string",
      "pinnedRowCellRenderer?": "{ new (): ICellRendererComp; } | ICellRendererFunc | string",
      "pinnedRowCellRendererFramework?": "any",
      "pinnedRowCellRendererParams?": "any",
      "valueFormatter?": "string | ValueFormatterFunc",
      "pinnedRowValueFormatter?": "string | ValueFormatterFunc",
      "valueParser?": "string | ValueParserFunc",
      "aggFunc?": "string | IAggFunc | null",
      "initialAggFunc?": "string | IAggFunc",
      "allowedAggFuncs?": "string[]",
      "rowGroupIndex?": "number | null",
      "rowGroup?": "boolean",
      "initialRowGroupIndex?": "number",
      "initialRowGroup?": "boolean",
      "showRowGroup?": "string | boolean",
      "pivotIndex?": "number | null",
      "pivot?": "boolean",
      "initialPivotIndex?": "number",
      "initialPivot?": "boolean",
      "comparator?": "(valueA: any, valueB: any, nodeA: RowNode, nodeB: RowNode, isInverted: boolean) => number",
      "equals?": "(valueA: any, valueB: any) => boolean",
      "pivotComparator?": "(valueA: string, valueB: string) => number",
      "checkboxSelection?": "boolean | CheckboxSelectionCallback",
      "headerCheckboxSelection?": "boolean | HeaderCheckboxSelectionCallback",
      "headerCheckboxSelectionFilteredOnly?": "boolean",
      "rowDrag?": "boolean | RowDragCallback",
      "rowDragText?": "(params: IRowDragItem, dragItemCount: number) => string",
      "dndSource?": "boolean | DndSourceCallback",
      "dndSourceOnRowDrag?": "(params: { rowNode: RowNode; dragEvent: DragEvent; }) => void",
      "suppressMenu?": "boolean",
      "menuTabs?": "string[]",
      "sortable?": "boolean",
      "suppressMovable?": "boolean",
      "suppressCellFlash?": "boolean",
      "lockPosition?": "boolean",
      "lockVisible?": "boolean",
      "lockPinned?": "boolean",
      "unSortIcon?": "boolean",
      "suppressSizeToFit?": "boolean",
      "resizable?": "boolean",
      "suppressAutoSize?": "boolean",
      "suppressKeyboardEvent?": "(params: SuppressKeyboardEventParams) => boolean",
      "enableRowGroup?": "boolean",
      "enablePivot?": "boolean",
      "enableValue?": "boolean",
      "editable?": "boolean | EditableCallback",
      "colSpan?": "(params: ColSpanParams) => number",
      "rowSpan?": "(params: RowSpanParams) => number",
      "suppressPaste?": "boolean | SuppressPasteCallback",
      "suppressNavigable?": "boolean | SuppressNavigableCallback",
      "getQuickFilterText?": "(params: GetQuickFilterTextParams) => string",
      "newValueHandler?": "(params: NewValueParams) => boolean",
      "singleClickEdit?": "boolean",
      "template?": "string",
      "templateUrl?": "string",
      "cellClassRules?": "CellClassRules",
      "onCellValueChanged?": "(event: NewValueParams) => void",
      "onCellClicked?": "(event: CellClickedEvent) => void",
      "onCellDoubleClicked?": "(event: CellDoubleClickedEvent) => void",
      "onCellContextMenu?": "(event: CellContextMenuEvent) => void",
      "icons?": "{ [key: string]: Function | string; }",
      "enableCellChangeFlash?": "boolean",
      "pivotValueColumn?": "Column | null",
      "pivotTotalColumnIds?": "string[]",
      "headerComponent?": "string | { new (): any; }",
      "headerComponentFramework?": "any",
      "headerComponentParams?": "any",
      "suppressFillHandle?": "boolean",
      "floatingFilter?": "boolean",
      "refData?": "{ [key: string]: string; }",
      "chartDataType?": "'category' | 'series' | 'time' | 'excluded'",
      "columnsMenuParams?": "ColumnsMenuParams",
      "headerName?": "string",
      "columnGroupShow?": "string",
      "headerClass?": "HeaderClass",
      "toolPanelClass?": "ToolPanelClass",
      "headerValueGetter?": "string | HeaderValueGetterFunc",
      "pivotKeys?": "string[]",
      "suppressColumnsToolPanel?": "boolean",
      "suppressFiltersToolPanel?": "boolean",
      "headerTooltip?": "string",
      "tooltipComponent?": "{ new (): ITooltipComp; } | string",
      "tooltipComponentFramework?": "any",
      "tooltipComponentParams?": "any",
      "suppressHeaderKeyboardEvent?": "(params: SuppressHeaderKeyboardEventParams) => boolean",
      "filter?": "IFilterType",
      "filterFramework?": "any",
      "filterParams?": "any",
      "floatingFilterComponent?": "IFloatingFilterType",
      "floatingFilterComponentParams?": "any",
      "floatingFilterComponentFramework?": "any"
    },
    "docs": {
      "colId?": "/** The unique ID to give the column. This is optional. If missing, the ID will default to the field.\n * If both field and colId are missing, a unique ID will be generated.\n * This ID is used to identify the column in the API for sorting, filtering etc. */",
      "sort?": "/** If sorting by default, set it here. Set to 'asc' or 'desc' */",
      "sortIndex?": "/** If sorting more than one column by default, specifies order in which the sorting should be applied. */",
      "sortedAt?": "/** @deprecated since v24 - use sortIndex instead\n */",
      "sortingOrder?": "/** The sort order, provide an array with any of the following in any order ['asc','desc',null] */",
      "field?": "/** The field of the row to get the cells data from */",
      "type?": "/** A comma separated string or array of strings containing ColumnType keys which can be used as a template for a column.\n * This helps to reduce duplication of properties when you have a lot of common column properties. */",
      "hide?": "/** Set to true for this column to be hidden. Naturally you might think, it would make more sense to call this field 'visible' and mark it false to hide,\n * however we want all default values to be false and we want columns to be visible by default. */",
      "pinned?": "/** Whether this column is pinned or not. */",
      "tooltipField?": "/** The field where we get the tooltip on the object */",
      "tooltipValueGetter?": "/** The function used to calculate the tooltip of the object, tooltipField takes precedence */",
      "valueGetter?": "/** Expression or function to get the cells value. */",
      "filterValueGetter?": "/** Expression or function to get the cells value for filtering. */",
      "valueSetter?": "/** If not using a field, then this puts the value into the cell */",
      "keyCreator?": "/** Function to return the key for a value - use this if the value is an object (not a primitive type) and you\n * want to a) group by this field or b) use set filter on this field. */",
      "width?": "/** Actual width, in pixels, of the cell */",
      "initialWidth?": "/** Default width, in pixels, of the cell */",
      "minWidth?": "/** Min width, in pixels, of the cell */",
      "maxWidth?": "/** Max width, in pixels, of the cell */",
      "flex?": "/** Sets the grow factor of a column. It specifies how much of the remaining\n * space should be assigned to the column. */",
      "autoHeight?": "/** True if this column should stretch rows height to fit contents */",
      "wrapText?": "/** True if this column should wrap cell contents - typically used with autoHeight */",
      "cellClass?": "/** Class to use for the cell. Can be string, array of strings, or function. */",
      "cellStyle?": "/** An object of css values. Or a function returning an object of css values. */",
      "cellRenderer?": "/** A function for rendering a cell. */",
      "cellEditor?": "/** Cell editor */",
      "pinnedRowCellRenderer?": "/** @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.\n */",
      "pinnedRowCellRendererFramework?": "/** @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.\n */",
      "pinnedRowCellRendererParams?": "/** @deprecated Use cellRendererSelector if you want a different Cell Renderer for pinned rows. Check params.node.rowPinned.\n */",
      "valueFormatter?": "/** A function to format a value, should return a string. Not used for CSV export or copy to clipboard, only for UI cell rendering. */",
      "pinnedRowValueFormatter?": "/** @deprecated Use valueFormatter for pinned rows, and check params.node.rowPinned.\n */",
      "valueParser?": "/** Gets called after editing, converts the value in the cell. */",
      "aggFunc?": "/** Name of function to use for aggregation. One of [sum,min,max,first,last] or a function. */",
      "allowedAggFuncs?": "/** Agg funcs allowed on this column. If missing, all installed agg funcs are allowed.\n * Can be eg ['sum','avg']. This will restrict what the GUI allows to select only. */",
      "rowGroupIndex?": "/** To group by this column by default, either provide an index (eg rowGroupIndex=1), or set rowGroup=true. */",
      "showRowGroup?": "/** Set to true to have the grid place the values for the group into the cell, or put the name of a grouped column to just show that group. */",
      "pivotIndex?": "/** To pivot by this column by default, either provide an index (eg pivotIndex=1), or set pivot=true. */",
      "comparator?": "/** Comparator function for custom sorting. */",
      "equals?": "/** Comparator for values, used by renderer to know if values have changed. Cells who's values have not changed don't get refreshed. */",
      "pivotComparator?": "/** Comparator for ordering the pivot columns */",
      "checkboxSelection?": "/** Set to true to render a selection checkbox in the column. */",
      "headerCheckboxSelection?": "/** If true, a 'select all' checkbox will be put into the header */",
      "headerCheckboxSelectionFilteredOnly?": "/** If true, the header checkbox selection will work on filtered items */",
      "rowDrag?": "/** For grid row dragging, set to true to enable row dragging within the grid */",
      "rowDragText?": "/** To configure the text to be displayed in the floating div while dragging a row when rowDrag is true */",
      "dndSource?": "/** For native drag and drop, set to true to enable drag source */",
      "dndSourceOnRowDrag?": "/** For native drag and drop, set to true to allow custom onRowDrag processing */",
      "suppressMenu?": "/** Set to true if no menu should be shown for this column header. */",
      "menuTabs?": "/** The menu tabs to show, and in which order, the valid values for this property are:\n * filterMenuTab, generalMenuTab, columnsMenuTab * */",
      "sortable?": "/** Set to true if sorting allowed for this column. */",
      "suppressMovable?": "/** Set to true to not allow moving this column via dragging it's header */",
      "suppressCellFlash?": "/** Set to true to not flash this column for value changes */",
      "lockPosition?": "/** Set to true to make sure this column is always first. Other columns, if movable, cannot move before this column. */",
      "lockVisible?": "/** Set to true to block the user showing / hiding the column, the column can only be shown / hidden via definitions or API */",
      "lockPinned?": "/** Set to true to block the user pinning the column, the column can only be pinned via definitions or API */",
      "unSortIcon?": "/** Set to true if you want the unsorted icon to be shown when no sort is applied to this column. */",
      "suppressSizeToFit?": "/** Set to true if you want this columns width to be fixed during 'size to fit' operation. */",
      "resizable?": "/** Set to true if this column should be resizable */",
      "suppressAutoSize?": "/** Set to true if you do not want this column to be auto-resizable by double clicking it's edge. */",
      "suppressKeyboardEvent?": "/** Allows the user to suppress certain keyboard events in the grid cell */",
      "enableRowGroup?": "/** If true, GUI will allow adding this columns as a row group */",
      "enablePivot?": "/** If true, GUI will allow adding this columns as a pivot */",
      "enableValue?": "/** If true, GUI will allow adding this columns as a value */",
      "editable?": "/** Set to true if this col is editable, otherwise false. Can also be a function to have different rows editable. */",
      "suppressPaste?": "/** Set to true if this col should not be allowed take new values from the clipboard . */",
      "suppressNavigable?": "/** Set to true if this col should not be navigable with the tab key. Can also be a function to have different rows editable. */",
      "getQuickFilterText?": "/** To create the quick filter text for this column, if toString is not good enough on the value. */",
      "newValueHandler?": "/** Callbacks for editing. See editing section for further details.\n * Return true if the update was successful, or false if not.\n * If false, then skips the UI refresh and no events are emitted.\n * Return false if the values are the same (ie no update). */",
      "singleClickEdit?": "/** If true, this cell will be in editing mode after first click. */",
      "template?": "/** Cell template to use for cell. Useful for AngularJS cells. */",
      "templateUrl?": "/** Cell template URL to load template from to use for cell. Useful for AngularJS cells. */",
      "cellClassRules?": "/** Rules for applying css classes */",
      "onCellValueChanged?": "/** Callbacks for editing.See editing section for further details. */",
      "onCellClicked?": "/** Function callback, gets called when a cell is clicked. */",
      "onCellDoubleClicked?": "/** Function callback, gets called when a cell is double clicked. */",
      "onCellContextMenu?": "/** Function callback, gets called when a cell is right clicked. */",
      "icons?": "/** Icons for this column. Leave blank to use default. */",
      "enableCellChangeFlash?": "/** If true, grid will flash cell after cell is refreshed */",
      "pivotValueColumn?": "/** Never set this, it is used internally by grid when doing in-grid pivoting */",
      "pivotTotalColumnIds?": "/** Never set this, it is used internally by grid when doing in-grid pivoting */",
      "headerComponent?": "/** The custom header component to be used for rendering the component header. If none specified the default AG Grid is used* */",
      "headerComponentFramework?": "/** The custom header component to be used for rendering the component header in the hosting framework (ie: React/Angular). If none specified the default AG Grid is used* */",
      "headerComponentParams?": "/** The custom header component parameters* */",
      "suppressFillHandle?": "/** Set to true to prevent the fillHandle from being rendered in any cell that belongs to this column */",
      "floatingFilter?": "/** Whether to display a floating filter for this column. */",
      "chartDataType?": "/** Defines the column data type used when charting */",
      "columnsMenuParams?": "/** Params to customise the columns menu behaviour and appearance */",
      "headerName?": "/** The name to render in the column header */",
      "columnGroupShow?": "/** Whether to show the column when the group is open / closed. */",
      "headerClass?": "/** CSS class for the header */",
      "toolPanelClass?": "/** CSS class for the toolPanel */",
      "headerValueGetter?": "/** Expression or function to get the value for display in the header. */",
      "pivotKeys?": "/** Never set this, it is used internally by grid when doing in-grid pivoting */",
      "suppressColumnsToolPanel?": "/** Set to true to not include this column in the Columns Tool Panel */",
      "suppressFiltersToolPanel?": "/** Set to true to not include this column / filter in the Filters Tool Panel */",
      "headerTooltip?": "/** Tooltip for the column header */",
      "suppressHeaderKeyboardEvent?": "/** Allows the user to suppress certain keyboard events in the grid header */",
      "filter?": "/** One of the built in filter names: [set, number, text, date], or a filter function */",
      "filterParams?": "/** The filter params are specific to each filter! */",
      "floatingFilterComponent?": "/** The custom component to be used for rendering the floating filter.\n * If none is specified the default AG Grid is used. */"
    }
  },
  "ColumnFunctionCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "CheckboxSelectionCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "CheckboxSelectionCallback": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "CheckboxSelectionCallbackParams" },
      "returnType": "boolean"
    }
  },
  "RowDragCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "RowDragCallback": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "RowDragCallbackParams" },
      "returnType": "boolean"
    }
  },
  "DndSourceCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "DndSourceCallback": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "DndSourceCallbackParams" },
      "returnType": "boolean"
    }
  },
  "EditableCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "EditableCallback": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "EditableCallbackParams" },
      "returnType": "boolean"
    }
  },
  "SuppressPasteCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "SuppressPasteCallback": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "SuppressPasteCallbackParams" },
      "returnType": "boolean"
    }
  },
  "SuppressNavigableCallbackParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "SuppressNavigableCallback": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "SuppressNavigableCallbackParams" },
      "returnType": "boolean"
    }
  },
  "HeaderCheckboxSelectionCallbackParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "HeaderCheckboxSelectionCallback": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "HeaderCheckboxSelectionCallbackParams" },
      "returnType": "boolean"
    }
  },
  "IsColumnFunc": {
    "meta": {
      "isCallSignature": true,
      "doc": "/** @deprecated No longer in use. Replaced with (params: ColumnFunctionCallbackParams) => boolean.\n */"
    },
    "type": {
      "arguments": { "params": "IsColumnFuncParams" },
      "returnType": "boolean"
    }
  },
  "IsColumnFuncParams": {
    "meta": {
      "doc": "/** @deprecated Replaced with ColumnFunctionCallbackParams\n */"
    },
    "type": {
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "GetQuickFilterTextParams": {
    "meta": {},
    "type": {
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "context": "any"
    },
    "docs": {
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ColumnsMenuParams": {
    "meta": {},
    "type": {
      "suppressSyncLayoutWithGrid?": "boolean",
      "suppressColumnFilter?": "boolean",
      "suppressColumnSelectAll?": "boolean",
      "suppressColumnExpandAll?": "boolean",
      "contractColumnSelection?": "boolean"
    },
    "docs": {
      "suppressSyncLayoutWithGrid?": "/** To suppress updating the layout of columns as they are rearranged in the grid */",
      "suppressColumnFilter?": "/** To suppress Column Filter section */",
      "suppressColumnSelectAll?": "/** To suppress Select / Un-select all widget */",
      "suppressColumnExpandAll?": "/** To suppress Expand / Collapse all widget */",
      "contractColumnSelection?": "/** By default, column groups start expanded.\n * Pass true to default to contracted groups */"
    }
  },
  "BaseColDefParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "BaseWithValueColDefParams": {
    "meta": {},
    "type": {
      "value": "any",
      "node": "RowNode | null",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "value": "/** Value for the cell. */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ValueGetterParams": {
    "meta": {},
    "type": {
      "getValue": "(field: string) => any",
      "node": "RowNode | null",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "getValue": "/** A utility method for getting other column values */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ValueGetterFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ValueGetterParams" },
      "returnType": "any"
    }
  },
  "HeaderValueGetterParams": {
    "meta": {},
    "type": {
      "colDef": "AbstractColDef",
      "column?": "Column | null",
      "columnGroup?": "ColumnGroup | ProvidedColumnGroup | null",
      "originalColumnGroup": "ProvidedColumnGroup | null",
      "location": "string | null",
      "api": "GridApi",
      "context?": "any"
    },
    "docs": {
      "column?": "/** Column for this callback if applicable */",
      "columnGroup?": "/** ColumnGroup for this callback if applicable */",
      "originalColumnGroup": "/** Original column group if applicable */",
      "location": "/** Where the column is going to appear */",
      "context?": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "HeaderValueGetterFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "HeaderValueGetterParams" },
      "returnType": "any"
    }
  },
  "NewValueParams": {
    "meta": {},
    "type": {
      "oldValue": "any",
      "newValue": "any",
      "node": "RowNode | null",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "oldValue": "/** The value before the change */",
      "newValue": "/** The value after the change */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ValueSetterParams": {
    "meta": {},
    "type": {
      "oldValue": "any",
      "newValue": "any",
      "node": "RowNode | null",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "oldValue": "/** The value before the change */",
      "newValue": "/** The value after the change */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ValueSetterFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ValueSetterParams" },
      "returnType": "boolean"
    }
  },
  "ValueParserParams": {
    "meta": {},
    "type": {
      "oldValue": "any",
      "newValue": "any",
      "node": "RowNode | null",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "oldValue": "/** The value before the change */",
      "newValue": "/** The value after the change */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ValueParserFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ValueParserParams" },
      "returnType": "any"
    }
  },
  "ValueFormatterParams": {
    "meta": {},
    "type": {
      "value": "any",
      "node": "RowNode | null",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "value": "/** Value for the cell. */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ValueFormatterFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ValueFormatterParams" },
      "returnType": "string"
    }
  },
  "KeyCreatorParams": {
    "meta": {},
    "type": {
      "value": "any",
      "node": "RowNode | null",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "value": "/** Value for the cell. */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ColSpanParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "RowSpanParams": {
    "meta": {},
    "type": {
      "node": "RowNode | null",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "SuppressKeyboardEventParams": {
    "meta": {},
    "type": {
      "event": "KeyboardEvent",
      "editing": "boolean",
      "node": "RowNode",
      "data": "any",
      "column": "Column",
      "colDef": "ColDef",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "event": "/** The keyboard event the grid received */",
      "editing": "/** Whether the cell is editing or not */",
      "node": "/** Row node for the given row */",
      "data": "/** Data associated with the node */",
      "column": "/** Column for this callback */",
      "colDef": "/** ColDef provided for this column */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "SuppressHeaderKeyboardEventParams": {
    "meta": {},
    "type": {
      "column": "Column | ColumnGroup",
      "colDef": "ColDef | ColGroupDef | null",
      "headerRowIndex": "number",
      "event": "KeyboardEvent",
      "context": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "headerRowIndex": "/** The index of the header row of the current focused header */",
      "event": "/** The keyboard event the grid received */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "CellClassParams": {
    "meta": {},
    "type": {
      "colDef": "ColDef",
      "value": "any",
      "data": "any",
      "node": "RowNode",
      "rowIndex": "number",
      "$scope": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "colDef": "/** The colDef associated with the column for this cell */",
      "value": "/** The value to be rendered */",
      "data": "/** The data associated with this row from rowData */",
      "node": "/** The RowNode associated with this row */",
      "rowIndex": "/** The index of the row */",
      "$scope": "/** If using AngularJs, is the row's child scope, otherwise null */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "CellClassFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "cellClassParams": "CellClassParams" },
      "returnType": "string | string[]"
    }
  },
  "CellStyleFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "cellClassParams": "CellClassParams" },
      "returnType": "{}"
    }
  },
  "CellClassRules": {
    "meta": {},
    "type": {
      "[cssClassName: string]": "(((params: CellClassParams) => boolean) | string)"
    }
  },
  "CellRendererSelectorFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ICellRendererParams" },
      "returnType": "CellRendererSelectorResult | undefined"
    }
  },
  "CellEditorSelectorFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ICellEditorParams" },
      "returnType": "CellEditorSelectorResult | undefined"
    }
  },
  "CellRendererSelectorResult": {
    "meta": {},
    "type": {
      "component?": "{ new (): ICellRendererComp; } | ICellRendererFunc | string",
      "frameworkComponent?": "any",
      "params?": "any"
    },
    "docs": {
      "component?": "/** Equivalent of setting `colDef.cellRenderer` */",
      "frameworkComponent?": "/** Equivalent of setting `colDef.cellRendererFramework` */",
      "params?": "/** Equivalent of setting `colDef.cellRendererParams` */"
    }
  },
  "CellEditorSelectorResult": {
    "meta": {},
    "type": {
      "component?": "{ new (): ICellEditorComp; } | string",
      "frameworkComponent?": "any",
      "params?": "any"
    },
    "docs": {
      "component?": "/** Equivalent of setting `colDef.cellEditor` */",
      "frameworkComponent?": "/** Equivalent of setting `colDef.cellEditorFramework` */",
      "params?": "/** Equivalent of setting `colDef.cellEditorParams` */"
    }
  },
  "GridOptions": {
    "meta": {},
    "type": {
      "statusBar?": "{ statusPanels: StatusPanelDef[]; }",
      "sideBar?": "SideBarDef | string | boolean | null",
      "suppressContextMenu?": "boolean",
      "preventDefaultOnContextMenu?": "boolean",
      "allowContextMenuWithControlKey?": "boolean",
      "suppressMenuHide?": "boolean",
      "enableBrowserTooltips?": "boolean",
      "tooltipShowDelay?": "number",
      "tooltipMouseTrack?": "boolean",
      "popupParent?": "HTMLElement",
      "copyHeadersToClipboard?": "boolean",
      "clipboardDeliminator?": "string",
      "suppressCopyRowsToClipboard?": "boolean",
      "suppressLastEmptyLineOnPaste?": "boolean",
      "suppressClipboardPaste?": "boolean",
      "suppressClipboardApi?": "boolean",
      "columnDefs?": "(ColDef | ColGroupDef)[] | null",
      "defaultColGroupDef?": "Partial<ColGroupDef>",
      "defaultColDef?": "ColDef",
      "columnTypes?": "{ [key: string]: ColDef; }",
      "maintainColumnOrder?": "boolean",
      "suppressFieldDotNotation?": "boolean",
      "deltaColumnMode?": "boolean",
      "applyColumnDefOrder?": "boolean",
      "immutableColumns?": "boolean",
      "suppressSetColumnStateEvents?": "boolean",
      "suppressColumnStateEvents?": "boolean",
      "colWidth?": "number",
      "minColWidth?": "number",
      "maxColWidth?": "number",
      "headerHeight?": "number",
      "groupHeaderHeight?": "number",
      "floatingFiltersHeight?": "number",
      "pivotHeaderHeight?": "number",
      "pivotGroupHeaderHeight?": "number",
      "allowDragFromColumnsToolPanel?": "boolean",
      "suppressMovableColumns?": "boolean",
      "suppressColumnMoveAnimation?": "boolean",
      "suppressDragLeaveHidesColumns?": "boolean",
      "colResizeDefault?": "string",
      "suppressAutoSize?": "boolean",
      "autoSizePadding?": "number",
      "skipHeaderOnAutoSize?": "boolean",
      "components?": "{ [p: string]: any; }",
      "frameworkComponents?": "{ [p: string]: { new (): any; }; } | any",
      "editType?": "string",
      "singleClickEdit?": "boolean",
      "suppressClickEdit?": "boolean",
      "enterMovesDownAfterEdit?": "boolean",
      "enterMovesDown?": "boolean",
      "stopEditingWhenCellsLoseFocus?": "boolean",
      "undoRedoCellEditing?": "boolean",
      "undoRedoCellEditingLimit?": "number",
      "stopEditingWhenGridLosesFocus?": "boolean",
      "defaultCsvExportParams?": "CsvExportParams",
      "suppressCsvExport?": "boolean",
      "defaultExcelExportParams?": "ExcelExportParams",
      "suppressExcelExport?": "boolean",
      "excelStyles?": "ExcelStyle[]",
      "defaultExportParams?": "CsvExportParams | ExcelExportParams",
      "quickFilterText?": "string",
      "cacheQuickFilter?": "boolean",
      "excludeChildrenWhenTreeDataFiltering?": "boolean",
      "floatingFilter?": "boolean",
      "enableOldSetFilterModel?": "boolean",
      "enableCharts?": "boolean",
      "chartThemes?": "string[]",
      "customChartThemes?": "{ [name: string]: AgChartTheme; }",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "processChartOptions?(params: ProcessChartOptionsParams)": "ChartOptions<any>",
      "allowProcessChartOptions?": "boolean",
      "loadingCellRenderer?": "{ new (): ICellRenderer; } | string",
      "loadingCellRendererFramework?": "any",
      "loadingCellRendererParams?": "any",
      "loadingCellRendererSelector?": "LoadingCellRendererSelectorFunc",
      "localeText?": "{ [key: string]: string; }",
      "masterDetail?": "boolean",
      "detailRowHeight?": "number",
      "keepDetailRows?": "boolean",
      "keepDetailRowsCount?": "number",
      "detailCellRendererParams?": "any",
      "detailCellRenderer?": "{ new (): ICellRendererComp; } | ICellRendererFunc | string",
      "detailCellRendererFramework?": "any",
      "detailRowAutoHeight?": "boolean",
      "context?": "any",
      "alignedGrids?": "GridOptions[]",
      "tabIndex?": "number",
      "rowBuffer?": "number",
      "valueCache?": "boolean",
      "valueCacheNeverExpires?": "boolean",
      "enableCellExpressions?": "boolean",
      "suppressParentsInRowNodes?": "boolean",
      "suppressTouch?": "boolean",
      "suppressFocusAfterRefresh?": "boolean",
      "suppressAsyncEvents?": "boolean",
      "suppressBrowserResizeObserver?": "boolean",
      "suppressPropertyNamesCheck?": "boolean",
      "suppressChangeDetection?": "boolean",
      "debug?": "boolean",
      "overlayLoadingTemplate?": "string",
      "loadingOverlayComponent?": "{ new (): ILoadingOverlayComp; } | string",
      "loadingOverlayComponentFramework?": "any",
      "loadingOverlayComponentParams?": "any",
      "suppressLoadingOverlay?": "boolean",
      "overlayNoRowsTemplate?": "string",
      "noRowsOverlayComponent?": "{ new (): INoRowsOverlayComp; } | string",
      "noRowsOverlayComponentFramework?": "any",
      "noRowsOverlayComponentParams?": "any",
      "suppressNoRowsOverlay?": "boolean",
      "pagination?": "boolean",
      "paginationPageSize?": "number",
      "paginationAutoPageSize?": "boolean",
      "paginateChildRows?": "boolean",
      "suppressPaginationPanel?": "boolean",
      "pivotMode?": "boolean",
      "pivotPanelShow?": "string",
      "pivotColumnGroupTotals?": "string",
      "pivotRowTotals?": "string",
      "pivotSuppressAutoColumn?": "boolean",
      "suppressExpandablePivotGroups?": "boolean",
      "functionsReadOnly?": "boolean",
      "aggFuncs?": "{ [key: string]: IAggFunc; }",
      "suppressAggFuncInHeader?": "boolean",
      "suppressAggAtRootLevel?": "boolean",
      "aggregateOnlyChangedColumns?": "boolean",
      "suppressAggFilteredOnly?": "boolean",
      "animateRows?": "boolean",
      "enableCellChangeFlash?": "boolean",
      "cellFlashDelay?": "number",
      "cellFadeDelay?": "number",
      "allowShowChangeAfterFilter?": "boolean",
      "domLayout?": "string",
      "ensureDomOrder?": "boolean",
      "enableRtl?": "boolean",
      "suppressColumnVirtualisation?": "boolean",
      "suppressMaxRenderedRowRestriction?": "boolean",
      "rowDragManaged?": "boolean",
      "suppressRowDrag?": "boolean",
      "suppressMoveWhenRowDragging?": "boolean",
      "rowDragEntireRow?": "boolean",
      "rowDragMultiRow?": "boolean",
      "fullWidthCellRenderer?": "{ new (): ICellRendererComp; } | ICellRendererFunc | string",
      "fullWidthCellRendererFramework?": "any",
      "fullWidthCellRendererParams?": "any",
      "embedFullWidthRows?": "boolean",
      "deprecatedEmbedFullWidthRows?": "boolean",
      "groupDisplayType?": "RowGroupingDisplayType",
      "groupDefaultExpanded?": "number",
      "autoGroupColumnDef?": "ColDef",
      "groupMaintainOrder?": "boolean",
      "groupSelectsChildren?": "boolean",
      "groupIncludeFooter?": "boolean",
      "groupIncludeTotalFooter?": "boolean",
      "groupSuppressBlankHeader?": "boolean",
      "groupSelectsFiltered?": "boolean",
      "showOpenedGroup?": "boolean",
      "groupRemoveSingleChildren?": "boolean",
      "groupRemoveLowestSingleChildren?": "boolean",
      "groupHideOpenParents?": "boolean",
      "rowGroupPanelShow?": "string",
      "groupRowRenderer?": "{ new (): ICellRendererComp; } | ICellRendererFunc | string",
      "groupRowRendererFramework?": "any",
      "groupRowRendererParams?": "any",
      "suppressMakeColumnVisibleAfterUnGroup?": "boolean",
      "treeData?": "boolean",
      "groupRowInnerRenderer?": "{ new (): ICellRendererComp; } | ICellRendererFunc | string",
      "groupRowInnerRendererFramework?": "any",
      "groupMultiAutoColumn?": "boolean",
      "groupUseEntireRow?": "boolean",
      "groupSuppressAutoColumn?": "boolean",
      "rememberGroupStateWhenNewData?": "boolean",
      "pinnedTopRowData?": "any[]",
      "pinnedBottomRowData?": "any[]",
      "rowModelType?": "string",
      "rowData?": "any[] | null",
      "immutableData?": "boolean",
      "asyncTransactionWaitMillis?": "number",
      "suppressModelUpdateAfterUpdateTransaction?": "boolean",
      "deltaRowDataMode?": "boolean",
      "batchUpdateWaitMillis?": "number",
      "datasource?": "IDatasource",
      "cacheOverflowSize?": "number",
      "infiniteInitialRowCount?": "number",
      "serverSideStoreType?": "ServerSideStoreType",
      "cacheBlockSize?": "number",
      "maxBlocksInCache?": "number",
      "maxConcurrentDatasourceRequests?": "number",
      "blockLoadDebounceMillis?": "number",
      "purgeClosedRowNodes?": "boolean",
      "serverSideDatasource?": "IServerSideDatasource",
      "serverSideSortingAlwaysResets?": "boolean",
      "serverSideFilteringAlwaysResets?": "boolean",
      "suppressEnterpriseResetOnNewColumns?": "boolean",
      "viewportDatasource?": "IViewportDatasource",
      "viewportRowModelPageSize?": "number",
      "viewportRowModelBufferSize?": "number",
      "alwaysShowHorizontalScroll?": "boolean",
      "alwaysShowVerticalScroll?": "boolean",
      "debounceVerticalScrollbar?": "boolean",
      "suppressHorizontalScroll?": "boolean",
      "suppressScrollOnNewData?": "boolean",
      "suppressAnimationFrame?": "boolean",
      "suppressMiddleClickScrolls?": "boolean",
      "suppressPreventDefaultOnMouseWheel?": "boolean",
      "scrollbarWidth?": "number",
      "rowSelection?": "string",
      "rowMultiSelectWithClick?": "boolean",
      "suppressRowDeselection?": "boolean",
      "suppressRowClickSelection?": "boolean",
      "suppressCellSelection?": "boolean",
      "suppressMultiRangeSelection?": "boolean",
      "enableCellTextSelection?": "boolean",
      "enableRangeSelection?": "boolean",
      "enableRangeHandle?": "boolean",
      "enableFillHandle?": "boolean",
      "fillHandleDirection?": "string",
      "suppressClearOnFillReduction?": "boolean",
      "rowDeselection?": "boolean",
      "sortingOrder?": "(string | null)[]",
      "accentedSort?": "boolean",
      "unSortIcon?": "boolean",
      "suppressMultiSort?": "boolean",
      "multiSortKey?": "string",
      "suppressMaintainUnsortedOrder?": "boolean",
      "icons?": "{ [key: string]: Function | string; }",
      "rowHeight?": "number",
      "rowStyle?": "{ [cssProperty: string]: string; }",
      "rowClass?": "string | string[]",
      "rowClassRules?": "RowClassRules",
      "suppressRowHoverHighlight?": "boolean",
      "suppressRowTransform?": "boolean",
      "columnHoverHighlight?": "boolean",
      "deltaSort?": "boolean",
      "treeDataDisplayType?": "TreeDataDisplayType",
      "angularCompileRows?": "boolean",
      "angularCompileFilters?": "boolean",
      "functionsPassive?": "boolean",
      "enableGroupEdit?": "boolean",
      "getContextMenuItems?": "GetContextMenuItems",
      "getMainMenuItems?": "GetMainMenuItems",
      "postProcessPopup?": "(params: PostProcessPopupParams) => void",
      "processCellForClipboard?(params: ProcessCellForExportParams)": "any",
      "processHeaderForClipboard?(params: ProcessHeaderForExportParams)": "any",
      "processCellFromClipboard?(params: ProcessCellForExportParams)": "any",
      "sendToClipboard?": "(params: SendToClipboardParams) => void",
      "processDataFromClipboard?": "(params: ProcessDataFromClipboardParams) => string[][] | null",
      "isExternalFilterPresent?()": "boolean",
      "doesExternalFilterPass?(node: RowNode)": "boolean",
      "getChartToolbarItems?": "GetChartToolbarItems",
      "createChartContainer?": "(params: ChartRef) => void",
      "navigateToNextHeader?": "(params: NavigateToNextHeaderParams) => HeaderPosition",
      "tabToNextHeader?": "(params: TabToNextHeaderParams) => HeaderPosition",
      "navigateToNextCell?": "(params: NavigateToNextCellParams) => CellPosition",
      "tabToNextCell?": "(params: TabToNextCellParams) => CellPosition",
      "suppressKeyboardEvent?": "(params: SuppressKeyboardEventParams) => boolean",
      "localeTextFunc?": "(key: string, defaultValue: string) => string",
      "getDocument?": "() => Document",
      "paginationNumberFormatter?": "(params: PaginationNumberFormatterParams) => string",
      "groupRowAggNodes?(nodes: RowNode[])": "any",
      "isGroupOpenByDefault?": "(params: IsGroupOpenByDefaultParams) => boolean",
      "defaultGroupOrderComparator?": "(nodeA: RowNode, nodeB: RowNode) => number",
      "processSecondaryColDef?(colDef: ColDef)": "void",
      "processSecondaryColGroupDef?(colGroupDef: ColGroupDef)": "void",
      "getDataPath?": "GetDataPath",
      "defaultGroupSortComparator?": "(nodeA: RowNode, nodeB: RowNode) => number",
      "getChildCount?(dataItem: any)": "number",
      "getServerSideStoreParams?": "(params: GetServerSideStoreParamsParams) => ServerSideStoreParams",
      "isServerSideGroupOpenByDefault?": "(params: IsServerSideGroupOpenByDefaultParams) => boolean",
      "isApplyServerSideTransaction?": "IsApplyServerSideTransaction",
      "isServerSideGroup?": "IsServerSideGroup",
      "getServerSideGroupKey?": "GetServerSideGroupKey",
      "getBusinessKeyForNode?(node: RowNode)": "string",
      "getRowNodeId?": "GetRowNodeIdFunc",
      "processRowPostCreate?(params: ProcessRowParams)": "void",
      "isRowSelectable?": "IsRowSelectable",
      "isRowMaster?": "IsRowMaster",
      "fillOperation?": "(params: FillOperationParams) => any",
      "postSort?(nodes: RowNode[])": "void",
      "getRowStyle?": "(params: RowClassParams) => { [cssProperty: string]: string; }",
      "getRowClass?": "(params: RowClassParams) => string | string[] | undefined",
      "getRowHeight?": "(params: RowHeightParams) => number | undefined | null",
      "isFullWidthCell?(rowNode: RowNode)": "boolean",
      "onToolPanelVisibleChanged?(event: ToolPanelVisibleChangedEvent)": "void",
      "onPasteStart?(event: PasteStartEvent)": "void",
      "onPasteEnd?(event: PasteEndEvent)": "void",
      "onColumnVisible?(event: ColumnVisibleEvent)": "void",
      "onColumnPinned?(event: ColumnPinnedEvent)": "void",
      "onColumnResized?(event: ColumnResizedEvent)": "void",
      "onColumnMoved?(event: ColumnMovedEvent)": "void",
      "onColumnValueChanged?(event: ColumnValueChangedEvent)": "void",
      "onColumnPivotModeChanged?(event: ColumnPivotModeChangedEvent)": "void",
      "onColumnPivotChanged?(event: ColumnPivotChangedEvent)": "void",
      "onColumnGroupOpened?(event: ColumnGroupOpenedEvent)": "void",
      "onNewColumnsLoaded?(event: NewColumnsLoadedEvent)": "void",
      "onGridColumnsChanged?(event: GridColumnsChangedEvent)": "void",
      "onDisplayedColumnsChanged?(event: DisplayedColumnsChangedEvent)": "void",
      "onVirtualColumnsChanged?(event: VirtualColumnsChangedEvent)": "void",
      "onColumnEverythingChanged?(event: ColumnEverythingChangedEvent)": "void",
      "onComponentStateChanged?(event: ComponentStateChangedEvent)": "void",
      "onCellValueChanged?(event: CellValueChangedEvent)": "void",
      "onRowValueChanged?(event: RowValueChangedEvent)": "void",
      "onCellEditingStarted?(event: CellEditingStartedEvent)": "void",
      "onCellEditingStopped?(event: CellEditingStoppedEvent)": "void",
      "onRowEditingStarted?(event: RowEditingStartedEvent)": "void",
      "onRowEditingStopped?(event: RowEditingStoppedEvent)": "void",
      "onFilterOpened?(event: FilterOpenedEvent)": "void",
      "onFilterChanged?(event: FilterChangedEvent)": "void",
      "onFilterModified?(event: FilterModifiedEvent)": "void",
      "onChartCreated?(event: ChartCreated)": "void",
      "onChartRangeSelectionChanged?(event: ChartRangeSelectionChanged)": "void",
      "onChartOptionsChanged?(event: ChartOptionsChanged)": "void",
      "onChartDestroyed?(event: ChartDestroyed)": "void",
      "onCellKeyDown?(event: CellKeyDownEvent | FullWidthCellKeyDownEvent)": "void",
      "onCellKeyPress?(event: CellKeyPressEvent | FullWidthCellKeyPressEvent)": "void",
      "onGridReady?(event: GridReadyEvent)": "void",
      "onFirstDataRendered?(event: FirstDataRenderedEvent)": "void",
      "onGridSizeChanged?(event: GridSizeChangedEvent)": "void",
      "onModelUpdated?(event: ModelUpdatedEvent)": "void",
      "onVirtualRowRemoved?(event: VirtualRowRemovedEvent)": "void",
      "onViewportChanged?(event: ViewportChangedEvent)": "void",
      "onBodyScroll?(event: BodyScrollEvent)": "void",
      "onDragStarted?(event: DragStartedEvent)": "void",
      "onDragStopped?(event: DragStoppedEvent)": "void",
      "onPaginationChanged?(event: PaginationChangedEvent)": "void",
      "onRowDragEnter?(event: RowDragEvent)": "void",
      "onRowDragMove?(event: RowDragEvent)": "void",
      "onRowDragLeave?(event: RowDragEvent)": "void",
      "onRowDragEnd?(event: RowDragEvent)": "void",
      "onColumnRowGroupChanged?(event: ColumnRowGroupChangedEvent)": "void",
      "onRowGroupOpened?(event: RowGroupOpenedEvent)": "void",
      "onExpandOrCollapseAll?(event: ExpandCollapseAllEvent)": "void",
      "onPinnedRowDataChanged?(event: PinnedRowDataChangedEvent)": "void",
      "onRowDataChanged?(event: RowDataChangedEvent)": "void",
      "onRowDataUpdated?(event: RowDataUpdatedEvent)": "void",
      "onAsyncTransactionsFlushed?(event: AsyncTransactionsFlushed)": "void",
      "onCellClicked?(event: CellClickedEvent)": "void",
      "onCellDoubleClicked?(event: CellDoubleClickedEvent)": "void",
      "onCellFocused?(event: CellFocusedEvent)": "void",
      "onCellMouseOver?(event: CellMouseOverEvent)": "void",
      "onCellMouseOut?(event: CellMouseOutEvent)": "void",
      "onCellMouseDown?(event: CellMouseDownEvent)": "void",
      "onRowClicked?(event: RowClickedEvent)": "void",
      "onRowDoubleClicked?(event: RowDoubleClickedEvent)": "void",
      "onRowSelected?(event: RowSelectedEvent)": "void",
      "onSelectionChanged?(event: SelectionChangedEvent)": "void",
      "onCellContextMenu?(event: CellContextMenuEvent)": "void",
      "onRangeSelectionChanged?(event: RangeSelectionChangedEvent)": "void",
      "onSortChanged?(event: SortChangedEvent)": "void",
      "onColumnRowGroupChangeRequest?(event: ColumnRowGroupChangeRequestEvent)": "void",
      "onColumnPivotChangeRequest?(event: ColumnPivotChangeRequestEvent)": "void",
      "onColumnValueChangeRequest?(event: ColumnValueChangeRequestEvent)": "void",
      "onColumnAggFuncChangeRequest?(event: ColumnAggFuncChangeRequestEvent)": "void",
      "api?": "GridApi | null",
      "columnApi?": "ColumnApi | null"
    },
    "docs": {
      "statusBar?": "/** Specifies the status bar components to use in the status bar. */",
      "deltaColumnMode?": "/** @deprecated\n */",
      "applyColumnDefOrder?": "/** @deprecated\n */",
      "immutableColumns?": "/** @deprecated\n */",
      "suppressSetColumnStateEvents?": "/** @deprecated\n */",
      "suppressColumnStateEvents?": "/** @deprecated\n */",
      "colWidth?": "/** @deprecated Set via `defaultColDef.width`\n */",
      "minColWidth?": "/** @deprecated Set via `defaultColDef.minWidth`\n */",
      "maxColWidth?": "/** @deprecated Set via `defaultColDef.maxWidth`\n */",
      "stopEditingWhenGridLosesFocus?": "/** @deprecated Use stopEditingWhenCellsLoseFocus instead\n */",
      "defaultExportParams?": "/** @deprecated Use defaultCsvExportParams or defaultExcelExportParams\n */",
      "floatingFilter?": "/** @deprecated Use floatingFilter on the colDef instead\n */",
      "enableOldSetFilterModel?": "/** @deprecated\n */",
      "processChartOptions?(params: ProcessChartOptionsParams)": "/** @deprecated\n */",
      "allowProcessChartOptions?": "/** @deprecated\n */",
      "suppressBrowserResizeObserver?": "/** Set once in init, can never change */",
      "deprecatedEmbedFullWidthRows?": "/** @deprecated\n */",
      "groupRowInnerRenderer?": "/** @deprecated - this is now groupRowRendererParams.innerRenderer\n */",
      "groupRowInnerRendererFramework?": "/** @deprecated - this is now groupRowRendererParams.innerRendererFramework\n */",
      "groupMultiAutoColumn?": "/** @deprecated - Use groupDisplayType = 'multipleColumns' instead\n */",
      "groupUseEntireRow?": "/** @deprecated - Use groupDisplayType = 'groupRows' instead\n */",
      "groupSuppressAutoColumn?": "/** @deprecated - Use groupDisplayType = 'custom' instead\n */",
      "rememberGroupStateWhenNewData?": "/** @deprecated - no longer needed, transaction updates keep group state\n */",
      "deltaRowDataMode?": "/** @deprecated\n */",
      "batchUpdateWaitMillis?": "/** @deprecated use asyncTransactionWaitMillis instead\n */",
      "suppressEnterpriseResetOnNewColumns?": "/** @deprecated\n */",
      "rowDeselection?": "/** @deprecated - rowDeselection is now true by default and should be suppressed by using suppressRowDeselection\n */",
      "suppressKeyboardEvent?": "/** Allows user to suppress certain keyboard events */",
      "defaultGroupSortComparator?": "/** @deprecated - Use defaultGroupOrderComparator instead\n */"
    }
  },
  "RowGroupingDisplayType": {
    "meta": { "isEnum": true },
    "type": [
      "SINGLE_COLUMN = 'singleColumn'",
      "MULTIPLE_COLUMNS = 'multipleColumns'",
      "GROUP_ROWS = 'groupRows'",
      "CUSTOM = 'custom'"
    ],
    "docs": [null, null, null, null]
  },
  "TreeDataDisplayType": {
    "meta": { "isEnum": true },
    "type": ["AUTO = 'auto'", "CUSTOM = 'custom'"],
    "docs": [null, null]
  },
  "FillOperationParams": {
    "meta": {},
    "type": {
      "event": "MouseEvent",
      "values": "any[]",
      "rowNode": "RowNode",
      "column": "Column",
      "initialValues": "any[]",
      "currentIndex": "number",
      "currentCellValue": "any",
      "direction": "'up' | 'down' | 'left' | 'right'",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "event": "/** The mouse event for the fill operation. */",
      "values": "/** The values that have been processed by the fill operation. */",
      "rowNode": "/** The RowNode of the current cell being changed. */",
      "column": "/** The Column of the current cell being changed. */",
      "initialValues": "/** The values that were present before processing started. */",
      "currentIndex": "/** The index of the current processed value. */",
      "currentCellValue": "/** The value of the cell being currently processed by the Fill Operation. */",
      "direction": "/** The direction of the Fill Operation. */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "GetDataPath": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "data": "any" }, "returnType": "string[]" }
  },
  "IsServerSideGroup": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "dataItem": "any" }, "returnType": "boolean" }
  },
  "IsApplyServerSideTransaction": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "IsApplyServerSideTransactionParams" },
      "returnType": "boolean"
    }
  },
  "IsApplyServerSideTransactionParams": {
    "meta": {},
    "type": {
      "transaction": "ServerSideTransaction",
      "parentNode": "RowNode",
      "storeInfo": "any"
    },
    "docs": {
      "transaction": "/** The transaction getting applied. */",
      "parentNode": "/** The parent RowNode, if transaction is applied to a group. */"
    }
  },
  "GetServerSideGroupKey": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "dataItem": "any" }, "returnType": "string" }
  },
  "IsRowMaster": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "dataItem": "any" }, "returnType": "boolean" }
  },
  "IsRowSelectable": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "node": "RowNode" }, "returnType": "boolean" }
  },
  "RowClassRules": {
    "meta": {},
    "type": {
      "[cssClassName: string]": "(((params: RowClassParams) => boolean) | string)"
    }
  },
  "RowClassParams": {
    "meta": {},
    "type": {
      "data": "any",
      "node": "RowNode",
      "rowIndex": "number",
      "$scope": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "data": "/** The data associated with this row from rowData */",
      "node": "/** The RowNode associated with this row */",
      "rowIndex": "/** The index of the row */",
      "$scope": "/** If using AngularJs, is the row's child scope, otherwise null */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "RowHeightParams": {
    "meta": {},
    "type": {
      "data": "any",
      "node": "RowNode",
      "api": "GridApi",
      "context": "any"
    },
    "docs": {
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "SendToClipboardParams": { "meta": {}, "type": { "data": "string" } },
  "ProcessChartOptionsParams": {
    "meta": {},
    "type": { "type": "ChartType", "options": "ChartOptions<any>" }
  },
  "ProcessChartParams": {
    "meta": {},
    "type": { "type": "ChartType", "options": "AgChartOptions", "chart": "any" }
  },
  "GetContextMenuItemsParams": {
    "meta": {},
    "type": {
      "defaultItems": "string[] | undefined",
      "column": "Column | null",
      "node": "RowNode | null",
      "value": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "defaultItems": "/** Names of the items that would be provided by default. */",
      "column": "/** The column, if a cell was clicked, otherwise null. */",
      "node": "/** The row node, if a cell was clicked, otherwise null. */",
      "value": "/** The value, if a cell was clicked, otherwise null. */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "GetContextMenuItems": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "GetContextMenuItemsParams" },
      "returnType": "(string | MenuItemDef)[]"
    }
  },
  "GetChartToolbarItemsParams": {
    "meta": {},
    "type": {
      "defaultItems?": "ChartMenuOptions[]",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    }
  },
  "GetChartToolbarItems": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "GetChartToolbarItemsParams" },
      "returnType": "ChartMenuOptions[]"
    }
  },
  "MenuItemDef": {
    "meta": {},
    "type": {
      "name": "string",
      "disabled?": "boolean",
      "shortcut?": "string",
      "action?": "() => void",
      "checked?": "boolean",
      "icon?": "HTMLElement | string",
      "subMenu?": "(MenuItemDef | string)[] | IComponent<any>",
      "cssClasses?": "string[]",
      "tooltip?": "string"
    },
    "docs": {
      "name": "/** Name of the menu item */",
      "disabled?": "/** It the item should be enabled / disabled */",
      "shortcut?": "/** Shortcut (just display text, saying the shortcut here does nothing) */",
      "action?": "/** Function that gets executed when item is chosen */",
      "checked?": "/** Set to true to provide a check beside the option */",
      "icon?": "/** The icon to display, either a DOM element or HTML string */",
      "subMenu?": "/** If this item is a sub menu, contains a list of menu item definitions */",
      "cssClasses?": "/** CSS classes to apply to the menu item */",
      "tooltip?": "/** Tooltip for the menu item */"
    }
  },
  "GetMainMenuItemsParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "defaultItems": "string[]",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "column": "/** The column that was clicked */",
      "defaultItems": "/** List of the items that would be displayed by default */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "GetMainMenuItems": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "GetMainMenuItemsParams" },
      "returnType": "(string | MenuItemDef)[]"
    }
  },
  "GetRowNodeIdFunc": {
    "meta": { "isCallSignature": true },
    "type": { "arguments": { "data": "any" }, "returnType": "string" }
  },
  "ProcessRowParams": {
    "meta": {},
    "type": {
      "eRow": "HTMLElement",
      "ePinnedLeftRow": "HTMLElement",
      "ePinnedRightRow": "HTMLElement",
      "rowIndex": "number",
      "node": "RowNode",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "addRenderedRowListener": "(eventType: string, listener: Function) => void",
      "context": "any"
    },
    "docs": {
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "NavigateToNextHeaderParams": {
    "meta": {},
    "type": {
      "key": "string",
      "previousHeaderPosition": "HeaderPosition | null",
      "nextHeaderPosition": "HeaderPosition | null",
      "headerRowCount": "number",
      "event": "KeyboardEvent",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "key": "/** The key for the arrow key pressed,\n * left = 'ArrowLeft', up = 'ArrowUp', right = 'ArrowRight', down = 'ArrowDown' */",
      "previousHeaderPosition": "/** The header that currently has focus */",
      "nextHeaderPosition": "/** The header the grid would normally pick as the next header for this navigation */",
      "headerRowCount": "/** The number of header rows present in the grid */"
    }
  },
  "TabToNextHeaderParams": {
    "meta": {},
    "type": {
      "backwards": "boolean",
      "previousHeaderPosition": "HeaderPosition | null",
      "nextHeaderPosition": "HeaderPosition | null",
      "headerRowCount": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "backwards": "/** True if the Shift key is also down */",
      "previousHeaderPosition": "/** The header that currently has focus */",
      "nextHeaderPosition": "/** The header the grid would normally pick as the next header for this navigation */",
      "headerRowCount": "/** The number of header rows present in the grid */"
    }
  },
  "NavigateToNextCellParams": {
    "meta": {},
    "type": {
      "key": "number",
      "previousCellPosition": "CellPosition",
      "nextCellPosition": "CellPosition | null",
      "event": "KeyboardEvent | null",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "key": "/** The keycode for the arrow key pressed:\n * left = 37, up = 38, right = 39, down = 40 */",
      "previousCellPosition": "/** The cell that currently has focus */",
      "nextCellPosition": "/** The cell the grid would normally pick as the next cell for navigation */"
    }
  },
  "TabToNextCellParams": {
    "meta": {},
    "type": {
      "backwards": "boolean",
      "editing": "boolean",
      "previousCellPosition": "CellPosition",
      "nextCellPosition": "CellPosition | null",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "backwards": "/** True if the Shift key is also down */",
      "editing": "/** True if the current cell is editing\n * (you may want to skip cells that are not editable, as the grid will enter the next cell in editing mode also if tabbing) */",
      "previousCellPosition": "/** The cell that currently has focus */",
      "nextCellPosition": "/** The cell the grid would normally pick as the next cell for navigation. */"
    }
  },
  "PostProcessPopupParams": {
    "meta": {},
    "type": {
      "column?": "Column | null",
      "rowNode?": "RowNode | null",
      "ePopup": "HTMLElement",
      "type": "string",
      "eventSource?": "HTMLElement | null",
      "mouseEvent?": "MouseEvent | Touch | null"
    },
    "docs": {
      "column?": "/** If popup is for a column, this gives the Column */",
      "rowNode?": "/** If popup is for a row, this gives the RowNode */",
      "ePopup": "/** The popup we are showing */",
      "type": "/** The different types are:\n * 'contextMenu', 'columnMenu', 'aggFuncSelect', 'popupCellEditor' */",
      "eventSource?": "/** If the popup is as a result of a button click (eg menu button),\n * this is the component that the user clicked */",
      "mouseEvent?": "/** If the popup is as a result of a click or touch,\n * this is the event - eg user showing context menu */"
    }
  },
  "PaginationNumberFormatterParams": {
    "meta": {},
    "type": { "value": "number" }
  },
  "ProcessDataFromClipboardParams": {
    "meta": {},
    "type": { "data": "string[][]" },
    "docs": { "data": "/** 2D array of all cells from the clipboard */" }
  },
  "ChartRef": {
    "meta": {},
    "type": {
      "chartId": "string",
      "chart": "any",
      "chartElement": "HTMLElement",
      "destroyChart": "() => void"
    },
    "docs": {
      "chartId": "/** The id of the created chart. */",
      "chart": "/** The chart instance that is produced by AG Charts which can be used to interact with the chart directly. */",
      "chartElement": "/** The chart DOM element, which the application is responsible for placing into the DOM. */",
      "destroyChart": "/** The application is responsible for calling this when the chart is no longer needed. */"
    }
  },
  "ServerSideStoreType": {
    "meta": { "isEnum": true },
    "type": ["Full = 'full'", "Partial = 'partial'"],
    "docs": [null, null]
  },
  "ServerSideStoreParams": {
    "meta": {},
    "type": {
      "storeType?": "ServerSideStoreType",
      "maxBlocksInCache?": "number",
      "cacheBlockSize?": "number"
    },
    "docs": {
      "storeType?": "/** What store type to use.\n * If missing, then defaults to grid option `serverSideStoreType`. */",
      "maxBlocksInCache?": "/** For Partial Store only.\n * How many blocks to keep in cache.\n * If missing, defaults to grid options `maxBlocksInCache`. */",
      "cacheBlockSize?": "/** For Partial Store only.\n * Cache block size.\n * If missing, defaults to grid options `cacheBlockSize`. */"
    }
  },
  "GetServerSideStoreParamsParams": {
    "meta": {},
    "type": {
      "level": "number",
      "parentRowNode?": "RowNode",
      "rowGroupColumns": "Column[]",
      "pivotColumns": "Column[]",
      "pivotMode": "boolean"
    },
    "docs": {
      "level": "/** The level of the store. Top level is 0. */",
      "parentRowNode?": "/** The Row Node for the group that got expanded, or undefined if top level (ie no parent) */",
      "rowGroupColumns": "/** Active Row Group Columns, if any. */",
      "pivotColumns": "/** Active Pivot Columns, if any. */",
      "pivotMode": "/** true if pivot mode is active. */"
    }
  },
  "IsServerSideGroupOpenByDefaultParams": {
    "meta": {},
    "type": { "data": "any", "rowNode": "RowNode" }
  },
  "IsGroupOpenByDefaultParams": {
    "meta": {},
    "type": {
      "rowNode": "RowNode",
      "rowGroupColumn": "Column",
      "level": "number",
      "field": "string",
      "key": "string"
    },
    "docs": {
      "rowNode": "/** The row node being considered. */",
      "rowGroupColumn": "/** The Column for which this row is grouping. */",
      "level": "/** Same as `rowNode.level` - what level the group is at, e.g. 0 for top level, 1 for second etc */",
      "field": "/** Same as `rowNode.field` - the field we are grouping on, e.g. 'country' */",
      "key": "/** Same as `rowNode.key`, the value of this group, e.g. 'Ireland' */"
    }
  },
  "LoadingCellRendererSelectorFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ILoadingCellRendererParams" },
      "returnType": "LoadingCellRendererSelectorResult | undefined"
    }
  },
  "LoadingCellRendererSelectorResult": {
    "meta": {},
    "type": {
      "component?": "{ new (): ICellRenderer; } | string",
      "frameworkComponent?": "any",
      "params?": "any"
    },
    "docs": {
      "component?": "/** Equivalent of setting `loadingCellRenderer` */",
      "frameworkComponent?": "/** Equivalent of setting `loadingCellRendererFramework` */",
      "params?": "/** Equivalent of setting `loadingCellRendererParams` */"
    }
  },
  "IHeaderColumn": {
    "meta": {},
    "type": {
      "getUniqueId()": "string",
      "getActualWidth()": "number",
      "getMinWidth()": "number | null | undefined",
      "getLeft()": "number | null",
      "getOldLeft()": "number | null",
      "getDefinition()": "AbstractColDef | null",
      "getColumnGroupShow()": "string | undefined",
      "getParent()": "IHeaderColumn",
      "isResizable()": "boolean",
      "setParent(parent: ColumnGroup | null)": "void",
      "isEmptyGroup()": "boolean",
      "isMoving()": "boolean",
      "getPinned()": "string | null | undefined",
      "addEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void",
      "removeEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void"
    }
  },
  "IProvidedColumn": {
    "meta": {},
    "type": {
      "isVisible()": "boolean",
      "getColumnGroupShow()": "string | undefined",
      "getId()": "string",
      "setOriginalParent(originalParent: ProvidedColumnGroup | null)": "void"
    }
  },
  "SetSelectedParams": {
    "meta": {},
    "type": {
      "newValue": "boolean",
      "clearSelection?": "boolean",
      "suppressFinishActions?": "boolean",
      "rangeSelect?": "boolean",
      "groupSelectsFiltered?": "boolean"
    }
  },
  "RowNodeEvent": {
    "meta": {},
    "type": { "node": "RowNode", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "DataChangedEvent": {
    "meta": {},
    "type": {
      "oldData": "any",
      "newData": "any",
      "update": "boolean",
      "node": "RowNode",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "CellChangedEvent": {
    "meta": {},
    "type": {
      "column": "Column",
      "newValue": "any",
      "oldValue": "any",
      "node": "RowNode",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "RowHighlightPosition": {
    "meta": { "isEnum": true },
    "type": ["Above", "Below"],
    "docs": [null, null]
  },
  "RowPosition": {
    "meta": {},
    "type": { "rowIndex": "number", "rowPinned": "string | null" },
    "docs": {
      "rowIndex": "/** A positive number from 0 to n, where n is the last row the grid is rendering\n * or -1 if you want to navigate to the grid header */",
      "rowPinned": "/** Either 'top', 'bottom' or null (for not pinned) */"
    }
  },
  "ToolPanelDef": {
    "meta": {},
    "type": {
      "id": "string",
      "labelKey": "string",
      "labelDefault": "string",
      "minWidth?": "number",
      "maxWidth?": "number",
      "width?": "number",
      "iconKey": "string",
      "toolPanel?": "{ new (): IToolPanelComp; } | string",
      "toolPanelFramework?": "any",
      "toolPanelParams?": "any"
    },
    "docs": {
      "id": "/** The unique ID for this panel. Used in the API and elsewhere to refer to the panel. */",
      "labelKey": "/** The key used for [localisation](/localisation/) for displaying the label. The label is displayed in the tab button. */",
      "labelDefault": "/** The default label if `labelKey` is missing or does not map to valid text through localisation. */",
      "minWidth?": "/** The min width of the tool panel. Default: `100` */",
      "maxWidth?": "/** The max width of the tool panel. Default: `undefined` */",
      "width?": "/** The initial width of the tool panel. Default: `$side-bar-panel-width (theme variable)` */",
      "iconKey": "/** The [key of the icon](/custom-icons/) to be used as a graphical aid beside the label in the side bar. */",
      "toolPanel?": "/** The tool panel component to use as the panel.\n * The provided panels use components `agColumnsToolPanel` and `agFiltersToolPanel`.\n * To provide your own custom panel component, you reference it by name here. */",
      "toolPanelFramework?": "/** Same as `toolPanel` but for framework specific components. */",
      "toolPanelParams?": "/** Customise the parameters provided to the `toolPanel` component. */"
    }
  },
  "SideBarDef": {
    "meta": {},
    "type": {
      "toolPanels?": "(ToolPanelDef | string)[]",
      "defaultToolPanel?": "string",
      "hiddenByDefault?": "boolean",
      "position?": "'left' | 'right'"
    },
    "docs": {
      "toolPanels?": "/** A list of all the panels to place in the side bar. The panels will be displayed in the provided order from top to bottom. */",
      "defaultToolPanel?": "/** The panel (identified by ID) to open by default. If none specified, the side bar is initially displayed closed. */",
      "hiddenByDefault?": "/** To hide the side bar by default, set this to `true`. If left undefined the side bar will be shown. */",
      "position?": "/** Sets the side bar position relative to the grid. */"
    }
  },
  "SASS_PROPERTIES": {
    "meta": { "isTypeAlias": true },
    "type": "'headerHeight' | 'headerCellMinWidth' | 'listItemHeight' | 'rowHeight' | 'chartMenuPanelWidth'"
  },
  "HardCodedSize": {
    "meta": {},
    "type": { "[key: string]": "{[key in SASS_PROPERTIES]?: number}" }
  },
  "ModelUpdatedEvent": {
    "meta": {},
    "type": {
      "animate": "boolean | undefined",
      "keepRenderedRows": "boolean | undefined",
      "newData": "boolean | undefined",
      "newPage": "boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "animate": "/** If true, the grid will try and animate the rows to the new positions */",
      "keepRenderedRows": "/** If true, the grid has new data loaded, eg user called setRowData(), otherwise\n * it's the same data but sorted or filtered, in which case this is true, and rows\n * can animate around (eg rowNode id 24 is the same row node as last time). */",
      "newData": "/** If true, then this update was a result of setRowData() getting called. This\n * gets the grid to scroll to the top again. */",
      "newPage": "/** True when pagination and a new page is navigated to. */",
      "type": "/** Event identifier */"
    }
  },
  "PaginationChangedEvent": {
    "meta": {},
    "type": {
      "animate?": "boolean",
      "keepRenderedRows?": "boolean",
      "newData?": "boolean",
      "newPage": "boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "animate?": "/** True if rows were animated to new position */",
      "keepRenderedRows?": "/** True if rows were kept (otherwise complete redraw) */",
      "newData?": "/** True if data was new (i.e user set new data) */",
      "newPage": "/** True if user went to a new page */",
      "type": "/** Event identifier */"
    }
  },
  "AgEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "AgGridEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "ToolPanelVisibleChangedEvent": {
    "meta": {},
    "type": {
      "source": "string | undefined",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "ColumnPivotModeChangedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "VirtualColumnsChangedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "ColumnEverythingChangedEvent": {
    "meta": {},
    "type": {
      "source": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "NewColumnsLoadedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "GridColumnsChangedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "DisplayedColumnsChangedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "RowDataChangedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "RowDataUpdatedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "PinnedRowDataChangedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "SelectionChangedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "FilterChangedEvent": {
    "meta": {},
    "type": {
      "afterDataChange?": "boolean",
      "afterFloatingFilter?": "boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "afterDataChange?": "/** True if the filter was changed as a result of data changing */",
      "afterFloatingFilter?": "/** True if filter was changed via floating filter */",
      "type": "/** Event identifier */"
    }
  },
  "FilterModifiedEvent": {
    "meta": {},
    "type": {
      "filterInstance": "IFilterComp",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "FilterOpenedEvent": {
    "meta": {},
    "type": {
      "column": "Column | ProvidedColumnGroup",
      "source": "FilterRequestSource",
      "eGui": "HTMLElement",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "column": "/** Column / OriginalColumnGroup that contains the filter */",
      "source": "/** Source of the open request */",
      "eGui": "/** Parent element of the filter */",
      "type": "/** Event identifier */"
    }
  },
  "SortChangedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "GridReadyEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "DisplayedColumnsWidthChangedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "ColumnHoverChangedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "BodyHeightChangedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "ComponentStateChangedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "ColumnPanelItemDragStartEvent": {
    "meta": {},
    "type": { "column": "Column | ProvidedColumnGroup", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "ColumnPanelItemDragEndEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "DragEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "target": "HTMLElement",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "type": "/** One of {'cell','row','headerCell','toolPanel'} */",
      "target": "/** The DOM element that started the event. */"
    }
  },
  "DragStartedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "target": "HTMLElement",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "type": "/** One of {'cell','row','headerCell','toolPanel'} */",
      "target": "/** The DOM element that started the event. */"
    }
  },
  "DragStoppedEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "target": "HTMLElement",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "type": "/** One of {'cell','row','headerCell','toolPanel'} */",
      "target": "/** The DOM element that started the event. */"
    }
  },
  "CheckboxChangedEvent": {
    "meta": {},
    "type": {
      "id": "string",
      "name": "string",
      "selected?": "boolean",
      "previousValue": "boolean | undefined",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "GridSizeChangedEvent": {
    "meta": {},
    "type": {
      "clientWidth": "number",
      "clientHeight": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "clientWidth": "/** The grid's DIV's clientWidth */",
      "clientHeight": "/** The grid's DIV's clientHeight */",
      "type": "/** Event identifier */"
    }
  },
  "RowDragEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "event": "MouseEvent",
      "vDirection": "string",
      "overIndex": "number",
      "overNode?": "RowNode",
      "y": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "type": "/** Event identifier: One of rowDragEnter, rowDragMove, rowDragEnd, rowDragLeave */",
      "node": "/** The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/** The list of nodes being dragged. */",
      "event": "/** The underlying mouse move event associated with the drag. */",
      "vDirection": "/** Direction of the drag, either `'up'`, `'down'` or `null` (if mouse is moving horizontally and not vertically). */",
      "overIndex": "/** The row index the mouse is dragging over or -1 if over no row. */",
      "overNode?": "/** The row node the mouse is dragging over or undefined if over no row. */",
      "y": "/** The vertical pixel location the mouse is over, with `0` meaning the top of the first row.\n * This can be compared to the `rowNode.rowHeight` and `rowNode.rowTop` to work out the mouse position relative to rows.\n * The provided attributes `overIndex` and `overNode` means the `y` property is mostly redundant.\n * The `y` property can be handy if you want more information such as 'how close is the mouse to the top or bottom of the row?' */"
    }
  },
  "RowDragEnterEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "event": "MouseEvent",
      "vDirection": "string",
      "overIndex": "number",
      "overNode?": "RowNode",
      "y": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "type": "/** Event identifier: One of rowDragEnter, rowDragMove, rowDragEnd, rowDragLeave */",
      "node": "/** The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/** The list of nodes being dragged. */",
      "event": "/** The underlying mouse move event associated with the drag. */",
      "vDirection": "/** Direction of the drag, either `'up'`, `'down'` or `null` (if mouse is moving horizontally and not vertically). */",
      "overIndex": "/** The row index the mouse is dragging over or -1 if over no row. */",
      "overNode?": "/** The row node the mouse is dragging over or undefined if over no row. */",
      "y": "/** The vertical pixel location the mouse is over, with `0` meaning the top of the first row.\n * This can be compared to the `rowNode.rowHeight` and `rowNode.rowTop` to work out the mouse position relative to rows.\n * The provided attributes `overIndex` and `overNode` means the `y` property is mostly redundant.\n * The `y` property can be handy if you want more information such as 'how close is the mouse to the top or bottom of the row?' */"
    }
  },
  "RowDragEndEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "event": "MouseEvent",
      "vDirection": "string",
      "overIndex": "number",
      "overNode?": "RowNode",
      "y": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "type": "/** Event identifier: One of rowDragEnter, rowDragMove, rowDragEnd, rowDragLeave */",
      "node": "/** The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/** The list of nodes being dragged. */",
      "event": "/** The underlying mouse move event associated with the drag. */",
      "vDirection": "/** Direction of the drag, either `'up'`, `'down'` or `null` (if mouse is moving horizontally and not vertically). */",
      "overIndex": "/** The row index the mouse is dragging over or -1 if over no row. */",
      "overNode?": "/** The row node the mouse is dragging over or undefined if over no row. */",
      "y": "/** The vertical pixel location the mouse is over, with `0` meaning the top of the first row.\n * This can be compared to the `rowNode.rowHeight` and `rowNode.rowTop` to work out the mouse position relative to rows.\n * The provided attributes `overIndex` and `overNode` means the `y` property is mostly redundant.\n * The `y` property can be handy if you want more information such as 'how close is the mouse to the top or bottom of the row?' */"
    }
  },
  "RowDragMoveEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "event": "MouseEvent",
      "vDirection": "string",
      "overIndex": "number",
      "overNode?": "RowNode",
      "y": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "type": "/** Event identifier: One of rowDragEnter, rowDragMove, rowDragEnd, rowDragLeave */",
      "node": "/** The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/** The list of nodes being dragged. */",
      "event": "/** The underlying mouse move event associated with the drag. */",
      "vDirection": "/** Direction of the drag, either `'up'`, `'down'` or `null` (if mouse is moving horizontally and not vertically). */",
      "overIndex": "/** The row index the mouse is dragging over or -1 if over no row. */",
      "overNode?": "/** The row node the mouse is dragging over or undefined if over no row. */",
      "y": "/** The vertical pixel location the mouse is over, with `0` meaning the top of the first row.\n * This can be compared to the `rowNode.rowHeight` and `rowNode.rowTop` to work out the mouse position relative to rows.\n * The provided attributes `overIndex` and `overNode` means the `y` property is mostly redundant.\n * The `y` property can be handy if you want more information such as 'how close is the mouse to the top or bottom of the row?' */"
    }
  },
  "RowDragLeaveEvent": {
    "meta": {},
    "type": {
      "type": "string",
      "node": "RowNode",
      "nodes": "RowNode[]",
      "event": "MouseEvent",
      "vDirection": "string",
      "overIndex": "number",
      "overNode?": "RowNode",
      "y": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "type": "/** Event identifier: One of rowDragEnter, rowDragMove, rowDragEnd, rowDragLeave */",
      "node": "/** The row node getting dragged. Also the node that started the drag when multi-row dragging. */",
      "nodes": "/** The list of nodes being dragged. */",
      "event": "/** The underlying mouse move event associated with the drag. */",
      "vDirection": "/** Direction of the drag, either `'up'`, `'down'` or `null` (if mouse is moving horizontally and not vertically). */",
      "overIndex": "/** The row index the mouse is dragging over or -1 if over no row. */",
      "overNode?": "/** The row node the mouse is dragging over or undefined if over no row. */",
      "y": "/** The vertical pixel location the mouse is over, with `0` meaning the top of the first row.\n * This can be compared to the `rowNode.rowHeight` and `rowNode.rowTop` to work out the mouse position relative to rows.\n * The provided attributes `overIndex` and `overNode` means the `y` property is mostly redundant.\n * The `y` property can be handy if you want more information such as 'how close is the mouse to the top or bottom of the row?' */"
    }
  },
  "PasteStartEvent": {
    "meta": {},
    "type": {
      "source": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "PasteEndEvent": {
    "meta": {},
    "type": {
      "source": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "FillStartEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "FillEndEvent": {
    "meta": {},
    "type": {
      "initialRange": "CellRange",
      "finalRange": "CellRange",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "ViewportChangedEvent": {
    "meta": {},
    "type": {
      "firstRow": "number",
      "lastRow": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "firstRow": "/** Index of the first rendered row */",
      "lastRow": "/** Index of the last rendered row */",
      "type": "/** Event identifier */"
    }
  },
  "FirstDataRenderedEvent": {
    "meta": {},
    "type": {
      "firstRow": "number",
      "lastRow": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "firstRow": "/** Index of the first rendered row */",
      "lastRow": "/** Index of the last rendered row */",
      "type": "/** Event identifier */"
    }
  },
  "RangeSelectionChangedEvent": {
    "meta": {},
    "type": {
      "id?": "string",
      "started": "boolean",
      "finished": "boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "started": "/** True for the first change event, otherwise false */",
      "finished": "/** True for the last change event, otherwise false */",
      "type": "/** Event identifier */"
    }
  },
  "ChartCreated": {
    "meta": {},
    "type": {
      "type": "string",
      "chartId": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "type": "/** Will always be `chartCreated`. */",
      "chartId": "/** Id of the created chart. This can later be used to reference the chart via api methods. */"
    }
  },
  "ChartRangeSelectionChanged": {
    "meta": {},
    "type": {
      "type": "string",
      "chartId": "string",
      "id": "string",
      "cellRange": "CellRangeParams",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "type": "/** Will always be `chartRangeSelectionChanged`. */",
      "chartId": "/** Id of the effected chart. */",
      "id": "/** Same as `chartId`. */",
      "cellRange": "/** New cellRange selected. */"
    }
  },
  "ChartOptionsChanged": {
    "meta": {},
    "type": {
      "type": "string",
      "chartId": "string",
      "chartType": "ChartType",
      "chartThemeName": "string",
      "chartOptions": "ChartOptions<any>",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "type": "/** Will always be `chartOptionsChanged`. */",
      "chartId": "/** Id of the effected chart. */",
      "chartType": "/** ChartType */",
      "chartThemeName": "/** Chart theme name of currently selected theme. */",
      "chartOptions": "/** Chart options. */"
    }
  },
  "ChartDestroyed": {
    "meta": {},
    "type": {
      "type": "string",
      "chartId": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "type": "/** Will always be `chartDestroyed`. */",
      "chartId": "/** Id of the effected chart. */"
    }
  },
  "ColumnGroupOpenedEvent": {
    "meta": {},
    "type": {
      "columnGroup": "ProvidedColumnGroup",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "ItemsAddedEvent": {
    "meta": {},
    "type": {
      "items": "RowNode[]",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "ScrollDirection": {
    "meta": { "isTypeAlias": true },
    "type": "'horizontal' | 'vertical'"
  },
  "BodyScrollEvent": {
    "meta": {},
    "type": {
      "direction": "ScrollDirection",
      "left": "number",
      "top": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "FlashCellsEvent": {
    "meta": {},
    "type": {
      "cells": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "PaginationPixelOffsetChangedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "CellFocusedEvent": {
    "meta": {},
    "type": {
      "rowIndex": "number | null",
      "column": "Column | null",
      "rowPinned?": "string | null",
      "isFullWidthCell": "boolean",
      "forceBrowserFocus?": "boolean",
      "floating": "string | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "rowIndex": "/** Row index of the focused cell */",
      "column": "/** Column of the focused cell */",
      "rowPinned?": "/** either 'top', 'bottom' or null / undefined (if not pinned) */",
      "isFullWidthCell": "/** Whether the cell a full width cell or a regular cell */",
      "forceBrowserFocus?": "/** Whether browser focus is also set (false when editing) */",
      "type": "/** Event identifier */"
    }
  },
  "ExpandCollapseAllEvent": {
    "meta": {},
    "type": {
      "source": "string",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "ColumnEventType": {
    "meta": { "isTypeAlias": true },
    "type": "\"sizeColumnsToFit\" | \"autosizeColumns\" | \"alignedGridChanged\" | \"filterChanged\" | \"filterDestroyed\" | \"gridOptionsChanged\" | \"gridInitializing\" | \"toolPanelDragAndDrop\" | \"toolPanelUi\" | \"uiColumnMoved\" | \"uiColumnResized\" | \"uiColumnDragged\" | \"uiColumnExpanded\" | \"uiColumnSorted\" | \"contextMenu\" | \"columnMenu\" | \"rowModelUpdated\" | \"api\" | \"flex\" | \"pivotChart\""
  },
  "ColumnEvent": {
    "meta": {},
    "type": {
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnResizedEvent": {
    "meta": {},
    "type": {
      "finished": "boolean",
      "flexColumns": "Column[] | null",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "finished": "/** Set to true for last event in a sequence of move events */",
      "flexColumns": "/** Any columns resized due to flex */",
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnPivotChangedEvent": {
    "meta": {},
    "type": {
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnRowGroupChangedEvent": {
    "meta": {},
    "type": {
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnValueChangedEvent": {
    "meta": {},
    "type": {
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnMovedEvent": {
    "meta": {},
    "type": {
      "toIndex?": "number",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "toIndex?": "/** The position the column was moved to */",
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnVisibleEvent": {
    "meta": {},
    "type": {
      "visible?": "boolean",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "visible?": "/** True if column was set to visible, false if set to hide */",
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnPinnedEvent": {
    "meta": {},
    "type": {
      "pinned": "string | null",
      "column": "Column | null",
      "columns": "Column[] | null",
      "source": "ColumnEventType",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "pinned": "/** Either 'left', 'right', or null (it not pinned) */",
      "column": "/** The impacted column, only set if action was on one column */",
      "columns": "/** List of all impacted columns */",
      "source": "/** String describing where the event is coming from */",
      "type": "/** Event identifier */"
    }
  },
  "RowEvent": {
    "meta": {
      "doc": "/** ------------ */\n/** ROW EVENTS */\n/** ------------ */"
    },
    "type": {
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "RowGroupOpenedEvent": {
    "meta": {},
    "type": {
      "expanded": "boolean",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "expanded": "/** True if the group is expanded. */",
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "RowValueChangedEvent": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "RowSelectedEvent": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "VirtualRowRemovedEvent": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "RowClickedEvent": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "RowDoubleClickedEvent": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "RowEditingStartedEvent": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "RowEditingStoppedEvent": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "FullWidthCellKeyDownEvent": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "FullWidthCellKeyPressEvent": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "CellEvent": {
    "meta": {
      "doc": "/** ------------ */\n/** CELL EVENTS */\n/** ------------ */"
    },
    "type": {
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "CellKeyDownEvent": {
    "meta": {},
    "type": {
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "CellKeyPressEvent": {
    "meta": {},
    "type": {
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "CellClickedEvent": {
    "meta": { "doc": "/** Cell is clicked */" },
    "type": {
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "CellMouseDownEvent": {
    "meta": {},
    "type": {
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "CellDoubleClickedEvent": {
    "meta": {},
    "type": {
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "CellMouseOverEvent": {
    "meta": {},
    "type": {
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "CellMouseOutEvent": {
    "meta": {},
    "type": {
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "CellContextMenuEvent": {
    "meta": {},
    "type": {
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "CellEditingStartedEvent": {
    "meta": {},
    "type": {
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "CellEditingStoppedEvent": {
    "meta": {},
    "type": {
      "oldValue": "any",
      "newValue": "any",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "oldValue": "/** The old value before editing */",
      "newValue": "/** The new value after editing */",
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "CellValueChangedEvent": {
    "meta": {},
    "type": {
      "oldValue": "any",
      "newValue": "any",
      "source": "string | undefined",
      "column": "Column",
      "colDef": "ColDef",
      "value": "any",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number | null",
      "rowPinned": "string | null",
      "context": "any",
      "event?": "Event | null",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "value": "/** The value for the cell */",
      "data": "/** The user provided data for the row */",
      "rowIndex": "/** The visible row index for the row */",
      "rowPinned": "/** Either 'top', 'bottom' or null / undefined (if not set) */",
      "context": "/** The context as provided on `gridOptions.context` */",
      "event?": "/** If event was due to browser event (eg click), this is the browser event */",
      "type": "/** Event identifier */"
    }
  },
  "AsyncTransactionsFlushed": {
    "meta": {},
    "type": {
      "results": "(RowNodeTransaction | ServerSideTransactionResult)[]",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": {
      "results": "/** Array of result objects. for SSRM it's always list of `ServerSideTransactionResult`.\n * For Client-Side Row Model it's a list of `RowNodeTransaction`. */",
      "type": "/** Event identifier */"
    }
  },
  "ColumnRequestEvent": {
    "meta": {},
    "type": {
      "columns": "Column[]",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "ColumnRowGroupChangeRequestEvent": {
    "meta": {},
    "type": {
      "columns": "Column[]",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "ColumnPivotChangeRequestEvent": {
    "meta": {},
    "type": {
      "columns": "Column[]",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "ColumnValueChangeRequestEvent": {
    "meta": {},
    "type": {
      "columns": "Column[]",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "ColumnAggFuncChangeRequestEvent": {
    "meta": {},
    "type": {
      "aggFunc": "any",
      "columns": "Column[]",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "ScrollVisibilityChangedEvent": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "StoreUpdatedEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "LeftPinnedWidthChangedEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "RightPinnedWidthChangedEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "RowContainerHeightChanged": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "DisplayedRowsChangedEvent": {
    "meta": {},
    "type": { "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "IFilterLocaleText": {
    "meta": {},
    "type": {
      "applyFilter": "string",
      "clearFilter": "string",
      "resetFilter": "string",
      "cancelFilter": "string",
      "filterOoo": "string",
      "empty": "string",
      "equals": "string",
      "notEqual": "string",
      "lessThan": "string",
      "greaterThan": "string",
      "inRange": "string",
      "inRangeStart": "string",
      "inRangeEnd": "string",
      "lessThanOrEqual": "string",
      "greaterThanOrEqual": "string",
      "contains": "string",
      "notContains": "string",
      "startsWith": "string",
      "endsWith": "string",
      "andCondition": "string",
      "orCondition": "string",
      "dateFormatOoo": "string"
    }
  },
  "IFilterTitleLocaleText": {
    "meta": {},
    "type": {
      "textFilter": "string",
      "numberFilter": "string",
      "dateFilter": "string",
      "setFilter": "string"
    }
  },
  "FilterRequestSource": {
    "meta": { "isTypeAlias": true },
    "type": "'COLUMN_MENU' | 'TOOLBAR' | 'NO_UI'"
  },
  "FilterWrapper": {
    "meta": {},
    "type": {
      "compiledElement": "any",
      "column": "Column",
      "filterPromise": "AgPromise<IFilterComp> | null",
      "scope": "any",
      "guiPromise": "AgPromise<HTMLElement | null>"
    }
  },
  "IFloatingFilterParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "filterParams": "IFilterParams",
      "suppressFilterButton": "boolean",
      "api": "GridApi",
      "currentParentModel": "() => any",
      "parentFilterInstance": "(callback: (filterInstance: IFilterComp) => void) => void",
      "showParentFilter": "() => void",
      "onFloatingFilterChanged": "(change: any) => boolean"
    },
    "docs": {
      "column": "/** The column this filter is for. */",
      "filterParams": "/** The params object passed to the filter. \n * This is to allow the floating filter access to the configuration of the parent filter.\n * For example, the provided filters use debounceMs from the parent filter params. */",
      "suppressFilterButton": "/** Boolean flag to indicate if the button in the floating filter that opens the parent filter in a popup should be displayed. */",
      "currentParentModel": "/** This is a shortcut to invoke getModel on the parent filter.\n * If the parent filter doesn't exist (filters are lazily created as needed)\n * then it returns null rather than calling getModel() on the parent filter. */",
      "parentFilterInstance": "/** Gets a reference to the parent filter. The result is returned asynchronously\n * via a callback as the parent filter may not exist yet. If it does\n * not exist, it is created and asynchronously returned (AG Grid itself\n * does not create components asynchronously, however if providing a framework\n * provided filter e.g. React, it might be).\n * \n * The floating filter can then call any method it likes on the parent filter.\n * The parent filter will typically provide its own method for the floating\n * filter to call to set the filter. For example, if creating custom filter A,\n * it should have a method your floating A can call to set the state\n * when the user updates via the floating filter. */",
      "showParentFilter": "/** Shows the parent filter popup. */",
      "onFloatingFilterChanged": "/** @deprecated in v21, use parentFilterInstance() callback instead and tell filter directly\n */"
    }
  },
  "IFloatingFilter": {
    "meta": {},
    "type": {
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "void"
    }
  },
  "IFloatingFilterComp": {
    "meta": {},
    "type": {
      "onParentModelChanged(parentModel: any, filterChangedEvent?: FilterChangedEvent | null)": "void",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: IFloatingFilterParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: IFloatingFilterParams)": "/** The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "BaseFloatingFilterChange": {
    "meta": {},
    "type": { "model": "ProvidedFilterModel", "apply": "boolean" }
  },
  "DateFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "'date'",
      "dateFrom": "string | null",
      "dateTo": "string | null",
      "type?": "string | null"
    },
    "docs": {
      "filterType?": "/** Filter type is always `'date'` */",
      "dateFrom": "/** The date value(s) associated with the filter.\n * The type is `string` and format is always `YYYY-MM-DD` e.g. 2019-05-24.\n * Custom filters can have no values (hence both are optional).\n * Range filter has two values (from and to). */",
      "dateTo": "/** Range filter `to` date value. */",
      "type?": "/** One of the filter options, e.g. `'equals'` */"
    }
  },
  "IDateFilterParams": {
    "meta": {},
    "type": {
      "comparator?": "IDateComparatorFunc",
      "browserDatePicker?": "boolean",
      "minValidYear?": "number",
      "inRangeInclusive?": "boolean",
      "includeBlanksInEquals?": "boolean",
      "includeBlanksInLessThan?": "boolean",
      "includeBlanksInGreaterThan?": "boolean",
      "includeBlanksInRange?": "boolean",
      "nullComparator?": "NullComparator",
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "comparator?": "/** Required if the data for the column are not native JS `Date` objects. */",
      "browserDatePicker?": "/** This is only used if a date component is not provided.\n * By default the grid will use the browser date picker in Chrome and Firefox and a plain text box for all other browsers\n * (This is because Chrome and Firefox are the only current browsers providing a decent out-of-the-box date picker).\n * If this property is set to `true`, the browser date picker will be used regardless of the browser type.\n * If set to `false`, a plain text box will be used for all browsers. */",
      "minValidYear?": "/** This is the minimum year that must be entered in a date field for the value to be considered valid. Default: `1000` */",
      "inRangeInclusive?": "/** If `true`, the `'inRange'` filter option will include values equal to the start and end of the range. */",
      "includeBlanksInEquals?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'equals'` filter option. */",
      "includeBlanksInLessThan?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'lessThan'` and `'lessThanOrEqual'` filter options. */",
      "includeBlanksInGreaterThan?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'greaterThan'` and `'greaterThanOrEqual'` filter options. */",
      "includeBlanksInRange?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'inRange'` filter option. */",
      "nullComparator?": "/** @deprecated in v21\n */",
      "filterOptions?": "/** Array of filter options to present to the user. See [Filter Options](/filter-provided-simple/#simple-filter-options) for all options available to each filter type. */",
      "defaultOption?": "/** The default filter option to be selected. */",
      "defaultJoinOperator?": "/** By default, the two conditions are combined using `AND`.\n * You can change this default by setting this property.\n * Options: `AND`, `OR` */",
      "suppressAndOrCondition?": "/** If `true`, the filter will only allow one condition.\n * Default: `false` */",
      "alwaysShowBothConditions?": "/** By default, only one condition is shown, and a second is made visible once a first condition has been entered.\n * Set this to `true` to always show both conditions. \n * In this case the second condition will be disabled until a first condition has been entered.\n * Default: `false` */",
      "clearButton?": "/** @deprecated\n */",
      "resetButton?": "/** @deprecated\n */",
      "applyButton?": "/** @deprecated\n */",
      "newRowsAction?": "/** @deprecated\n */",
      "column": "/** The column this filter is for. */",
      "colDef": "/** The column definition for the column. */",
      "rowModel": "/** The row model, helpful for looking up data values if needed.\n * If the filter needs to know which rows are\n * a) in the table,\n * b) currently visible (i.e. not already filtered),\n * c) which groups,\n * d) what order - all of this can be read from the rowModel. */",
      "filterChangedCallback": "/** A function callback to be called when the filter changes. The\n * grid will then respond by filtering the grid data. The callback\n * takes one optional parameter which, if included, will get merged\n * to the FilterChangedEvent object (useful for passing additional\n * information to anyone listening to this event, however such extra\n * attributes are not used by the grid). */",
      "filterModifiedCallback": "/** A function callback, to be optionally called, when the filter UI changes.\n * The grid will respond with emitting a FilterModifiedEvent.\n * Apart from emitting the event, the grid takes no further action. */",
      "valueGetter": "/** A function callback for the filter to get cell values from the row data.\n * Call with a node to be given the value for that filter's column for that node.\n * The callback takes care of selecting the right column definition and deciding whether to use valueGetter or field etc.\n * This is useful in, for example, creating an Excel style filter,\n * where the filter needs to lookup available values to allow the user to select from. */",
      "doesRowPassOtherFilter": "/** A function callback, call with a node to be told whether the node passes all filters except the current filter.\n * This is useful if you want to only present to the user values that this filter can filter given the status of the other filters.\n * The set filter uses this to remove from the list,\n * items that are no longer available due to the state of other filters (like Excel type filtering). */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "IDateComparatorFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "filterLocalDateAtMidnight": "Date", "cellValue": "any" },
      "returnType": "number"
    }
  },
  "NumberFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "'number'",
      "filter?": "number | null",
      "filterTo?": "number | null",
      "type?": "string | null"
    },
    "docs": {
      "filterType?": "/** Filter type is always `'number'` */",
      "filter?": "/** The number value(s) associated with the filter.\n * Custom filters can have no values (hence both are optional).\n * Range filter has two values (from and to). */",
      "filterTo?": "/** Range filter `to` value. */",
      "type?": "/** One of the filter options, e.g. `'equals'` */"
    }
  },
  "INumberFilterParams": {
    "meta": {},
    "type": {
      "allowedCharPattern?": "string",
      "numberParser?": "(text: string | null) => number",
      "inRangeInclusive?": "boolean",
      "includeBlanksInEquals?": "boolean",
      "includeBlanksInLessThan?": "boolean",
      "includeBlanksInGreaterThan?": "boolean",
      "includeBlanksInRange?": "boolean",
      "nullComparator?": "NullComparator",
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "allowedCharPattern?": "/** When specified, the input field will be of type `text` instead of `number`, and this will be used as a regex of all the characters that are allowed to be typed.\n * This will be compared against any typed character and prevent the character from appearing in the input if it does not match, in supported browsers (all except Safari). */",
      "numberParser?": "/** Typically used alongside `allowedCharPattern`, this provides a custom parser to convert the value entered in the filter inputs into a number that can be used for comparisons. */",
      "inRangeInclusive?": "/** If `true`, the `'inRange'` filter option will include values equal to the start and end of the range. */",
      "includeBlanksInEquals?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'equals'` filter option. */",
      "includeBlanksInLessThan?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'lessThan'` and `'lessThanOrEqual'` filter options. */",
      "includeBlanksInGreaterThan?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'greaterThan'` and `'greaterThanOrEqual'` filter options. */",
      "includeBlanksInRange?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'inRange'` filter option. */",
      "nullComparator?": "/** @deprecated in v21\n */",
      "filterOptions?": "/** Array of filter options to present to the user. See [Filter Options](/filter-provided-simple/#simple-filter-options) for all options available to each filter type. */",
      "defaultOption?": "/** The default filter option to be selected. */",
      "defaultJoinOperator?": "/** By default, the two conditions are combined using `AND`.\n * You can change this default by setting this property.\n * Options: `AND`, `OR` */",
      "suppressAndOrCondition?": "/** If `true`, the filter will only allow one condition.\n * Default: `false` */",
      "alwaysShowBothConditions?": "/** By default, only one condition is shown, and a second is made visible once a first condition has been entered.\n * Set this to `true` to always show both conditions. \n * In this case the second condition will be disabled until a first condition has been entered.\n * Default: `false` */",
      "clearButton?": "/** @deprecated\n */",
      "resetButton?": "/** @deprecated\n */",
      "applyButton?": "/** @deprecated\n */",
      "newRowsAction?": "/** @deprecated\n */",
      "column": "/** The column this filter is for. */",
      "colDef": "/** The column definition for the column. */",
      "rowModel": "/** The row model, helpful for looking up data values if needed.\n * If the filter needs to know which rows are\n * a) in the table,\n * b) currently visible (i.e. not already filtered),\n * c) which groups,\n * d) what order - all of this can be read from the rowModel. */",
      "filterChangedCallback": "/** A function callback to be called when the filter changes. The\n * grid will then respond by filtering the grid data. The callback\n * takes one optional parameter which, if included, will get merged\n * to the FilterChangedEvent object (useful for passing additional\n * information to anyone listening to this event, however such extra\n * attributes are not used by the grid). */",
      "filterModifiedCallback": "/** A function callback, to be optionally called, when the filter UI changes.\n * The grid will respond with emitting a FilterModifiedEvent.\n * Apart from emitting the event, the grid takes no further action. */",
      "valueGetter": "/** A function callback for the filter to get cell values from the row data.\n * Call with a node to be given the value for that filter's column for that node.\n * The callback takes care of selecting the right column definition and deciding whether to use valueGetter or field etc.\n * This is useful in, for example, creating an Excel style filter,\n * where the filter needs to lookup available values to allow the user to select from. */",
      "doesRowPassOtherFilter": "/** A function callback, call with a node to be told whether the node passes all filters except the current filter.\n * This is useful if you want to only present to the user values that this filter can filter given the status of the other filters.\n * The set filter uses this to remove from the list,\n * items that are no longer available due to the state of other filters (like Excel type filtering). */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "FilterButtonType": {
    "meta": { "isTypeAlias": true },
    "type": "'apply' | 'clear' | 'reset' | 'cancel'"
  },
  "IProvidedFilterParams": {
    "meta": {},
    "type": {
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "clearButton?": "/** @deprecated\n */",
      "resetButton?": "/** @deprecated\n */",
      "applyButton?": "/** @deprecated\n */",
      "newRowsAction?": "/** @deprecated\n */",
      "column": "/** The column this filter is for. */",
      "colDef": "/** The column definition for the column. */",
      "rowModel": "/** The row model, helpful for looking up data values if needed.\n * If the filter needs to know which rows are\n * a) in the table,\n * b) currently visible (i.e. not already filtered),\n * c) which groups,\n * d) what order - all of this can be read from the rowModel. */",
      "filterChangedCallback": "/** A function callback to be called when the filter changes. The\n * grid will then respond by filtering the grid data. The callback\n * takes one optional parameter which, if included, will get merged\n * to the FilterChangedEvent object (useful for passing additional\n * information to anyone listening to this event, however such extra\n * attributes are not used by the grid). */",
      "filterModifiedCallback": "/** A function callback, to be optionally called, when the filter UI changes.\n * The grid will respond with emitting a FilterModifiedEvent.\n * Apart from emitting the event, the grid takes no further action. */",
      "valueGetter": "/** A function callback for the filter to get cell values from the row data.\n * Call with a node to be given the value for that filter's column for that node.\n * The callback takes care of selecting the right column definition and deciding whether to use valueGetter or field etc.\n * This is useful in, for example, creating an Excel style filter,\n * where the filter needs to lookup available values to allow the user to select from. */",
      "doesRowPassOtherFilter": "/** A function callback, call with a node to be told whether the node passes all filters except the current filter.\n * This is useful if you want to only present to the user values that this filter can filter given the status of the other filters.\n * The set filter uses this to remove from the list,\n * items that are no longer available due to the state of other filters (like Excel type filtering). */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "NullComparator": {
    "meta": { "doc": "/** @deprecated in v21\n */" },
    "type": {
      "equals?": "boolean",
      "lessThan?": "boolean",
      "greaterThan?": "boolean"
    }
  },
  "IScalarFilterParams": {
    "meta": {},
    "type": {
      "inRangeInclusive?": "boolean",
      "includeBlanksInEquals?": "boolean",
      "includeBlanksInLessThan?": "boolean",
      "includeBlanksInGreaterThan?": "boolean",
      "includeBlanksInRange?": "boolean",
      "nullComparator?": "NullComparator",
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "inRangeInclusive?": "/** If `true`, the `'inRange'` filter option will include values equal to the start and end of the range. */",
      "includeBlanksInEquals?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'equals'` filter option. */",
      "includeBlanksInLessThan?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'lessThan'` and `'lessThanOrEqual'` filter options. */",
      "includeBlanksInGreaterThan?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'greaterThan'` and `'greaterThanOrEqual'` filter options. */",
      "includeBlanksInRange?": "/** If `true`, blank (`null` or `undefined`) values will pass the `'inRange'` filter option. */",
      "nullComparator?": "/** @deprecated in v21\n */",
      "filterOptions?": "/** Array of filter options to present to the user. See [Filter Options](/filter-provided-simple/#simple-filter-options) for all options available to each filter type. */",
      "defaultOption?": "/** The default filter option to be selected. */",
      "defaultJoinOperator?": "/** By default, the two conditions are combined using `AND`.\n * You can change this default by setting this property.\n * Options: `AND`, `OR` */",
      "suppressAndOrCondition?": "/** If `true`, the filter will only allow one condition.\n * Default: `false` */",
      "alwaysShowBothConditions?": "/** By default, only one condition is shown, and a second is made visible once a first condition has been entered.\n * Set this to `true` to always show both conditions. \n * In this case the second condition will be disabled until a first condition has been entered.\n * Default: `false` */",
      "clearButton?": "/** @deprecated\n */",
      "resetButton?": "/** @deprecated\n */",
      "applyButton?": "/** @deprecated\n */",
      "newRowsAction?": "/** @deprecated\n */",
      "column": "/** The column this filter is for. */",
      "colDef": "/** The column definition for the column. */",
      "rowModel": "/** The row model, helpful for looking up data values if needed.\n * If the filter needs to know which rows are\n * a) in the table,\n * b) currently visible (i.e. not already filtered),\n * c) which groups,\n * d) what order - all of this can be read from the rowModel. */",
      "filterChangedCallback": "/** A function callback to be called when the filter changes. The\n * grid will then respond by filtering the grid data. The callback\n * takes one optional parameter which, if included, will get merged\n * to the FilterChangedEvent object (useful for passing additional\n * information to anyone listening to this event, however such extra\n * attributes are not used by the grid). */",
      "filterModifiedCallback": "/** A function callback, to be optionally called, when the filter UI changes.\n * The grid will respond with emitting a FilterModifiedEvent.\n * Apart from emitting the event, the grid takes no further action. */",
      "valueGetter": "/** A function callback for the filter to get cell values from the row data.\n * Call with a node to be given the value for that filter's column for that node.\n * The callback takes care of selecting the right column definition and deciding whether to use valueGetter or field etc.\n * This is useful in, for example, creating an Excel style filter,\n * where the filter needs to lookup available values to allow the user to select from. */",
      "doesRowPassOtherFilter": "/** A function callback, call with a node to be told whether the node passes all filters except the current filter.\n * This is useful if you want to only present to the user values that this filter can filter given the status of the other filters.\n * The set filter uses this to remove from the list,\n * items that are no longer available due to the state of other filters (like Excel type filtering). */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "Comparator": {
    "meta": { "isCallSignature": true, "typeParams": ["T"] },
    "type": {
      "arguments": { "left": "T", "right": "T" },
      "returnType": "number"
    }
  },
  "JoinOperator": { "meta": { "isTypeAlias": true }, "type": "'AND' | 'OR'" },
  "ISimpleFilterParams": {
    "meta": {},
    "type": {
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "filterOptions?": "/** Array of filter options to present to the user. See [Filter Options](/filter-provided-simple/#simple-filter-options) for all options available to each filter type. */",
      "defaultOption?": "/** The default filter option to be selected. */",
      "defaultJoinOperator?": "/** By default, the two conditions are combined using `AND`.\n * You can change this default by setting this property.\n * Options: `AND`, `OR` */",
      "suppressAndOrCondition?": "/** If `true`, the filter will only allow one condition.\n * Default: `false` */",
      "alwaysShowBothConditions?": "/** By default, only one condition is shown, and a second is made visible once a first condition has been entered.\n * Set this to `true` to always show both conditions. \n * In this case the second condition will be disabled until a first condition has been entered.\n * Default: `false` */",
      "clearButton?": "/** @deprecated\n */",
      "resetButton?": "/** @deprecated\n */",
      "applyButton?": "/** @deprecated\n */",
      "newRowsAction?": "/** @deprecated\n */",
      "column": "/** The column this filter is for. */",
      "colDef": "/** The column definition for the column. */",
      "rowModel": "/** The row model, helpful for looking up data values if needed.\n * If the filter needs to know which rows are\n * a) in the table,\n * b) currently visible (i.e. not already filtered),\n * c) which groups,\n * d) what order - all of this can be read from the rowModel. */",
      "filterChangedCallback": "/** A function callback to be called when the filter changes. The\n * grid will then respond by filtering the grid data. The callback\n * takes one optional parameter which, if included, will get merged\n * to the FilterChangedEvent object (useful for passing additional\n * information to anyone listening to this event, however such extra\n * attributes are not used by the grid). */",
      "filterModifiedCallback": "/** A function callback, to be optionally called, when the filter UI changes.\n * The grid will respond with emitting a FilterModifiedEvent.\n * Apart from emitting the event, the grid takes no further action. */",
      "valueGetter": "/** A function callback for the filter to get cell values from the row data.\n * Call with a node to be given the value for that filter's column for that node.\n * The callback takes care of selecting the right column definition and deciding whether to use valueGetter or field etc.\n * This is useful in, for example, creating an Excel style filter,\n * where the filter needs to lookup available values to allow the user to select from. */",
      "doesRowPassOtherFilter": "/** A function callback, call with a node to be told whether the node passes all filters except the current filter.\n * This is useful if you want to only present to the user values that this filter can filter given the status of the other filters.\n * The set filter uses this to remove from the list,\n * items that are no longer available due to the state of other filters (like Excel type filtering). */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ISimpleFilterModel": {
    "meta": {},
    "type": { "type?": "string | null", "filterType?": "string" },
    "docs": { "type?": "/** One of the filter options, e.g. `'equals'` */" }
  },
  "ICombinedSimpleModel": {
    "meta": { "typeParams": ["M extends ISimpleFilterModel"] },
    "type": {
      "operator": "JoinOperator",
      "condition1": "M",
      "condition2": "M",
      "filterType?": "string"
    }
  },
  "ConditionPosition": {
    "meta": { "isEnum": true },
    "type": ["One", "Two"],
    "docs": [null, null]
  },
  "TextFilterModel": {
    "meta": {},
    "type": {
      "filterType?": "'text'",
      "filter?": "string | null",
      "type?": "string | null"
    },
    "docs": {
      "filterType?": "/** Filter type is always `'text'` */",
      "filter?": "/** The text value associated with the filter.\n * It's optional as custom filters may not have a text value. */",
      "type?": "/** One of the filter options, e.g. `'equals'` */"
    }
  },
  "TextComparator": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": {
        "filter": "string | null | undefined",
        "gridValue": "any",
        "filterText": "string | null"
      },
      "returnType": "boolean"
    }
  },
  "TextFormatter": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "from?": "string | null" },
      "returnType": "string | null"
    }
  },
  "ITextFilterParams": {
    "meta": {},
    "type": {
      "textCustomComparator?": "TextComparator",
      "caseSensitive?": "boolean",
      "textFormatter?": "(from: string) => string",
      "trimInput?": "boolean",
      "filterOptions?": "(IFilterOptionDef | string)[]",
      "defaultOption?": "string",
      "defaultJoinOperator?": "JoinOperator",
      "suppressAndOrCondition?": "boolean",
      "alwaysShowBothConditions?": "boolean",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "textCustomComparator?": "/** Used to override how to filter based on the user input. */",
      "caseSensitive?": "/** By default, text filtering is case-insensitive. Set this to `true` to make text filtering case-sensitive.\n * Default: `false` */",
      "textFormatter?": "/** Formats the text before applying the filter compare logic.\n * Useful if you want to substitute accented characters, for example. */",
      "trimInput?": "/** If `true`, the input that the user enters will be trimmed when the filter is applied, so any leading or trailing whitespace will be removed.\n * If only whitespace is entered, it will be left as-is.\n * If you enable `trimInput`, it is best to also increase the `debounceMs` to give users more time to enter text.\n * Default: `false` */",
      "filterOptions?": "/** Array of filter options to present to the user. See [Filter Options](/filter-provided-simple/#simple-filter-options) for all options available to each filter type. */",
      "defaultOption?": "/** The default filter option to be selected. */",
      "defaultJoinOperator?": "/** By default, the two conditions are combined using `AND`.\n * You can change this default by setting this property.\n * Options: `AND`, `OR` */",
      "suppressAndOrCondition?": "/** If `true`, the filter will only allow one condition.\n * Default: `false` */",
      "alwaysShowBothConditions?": "/** By default, only one condition is shown, and a second is made visible once a first condition has been entered.\n * Set this to `true` to always show both conditions. \n * In this case the second condition will be disabled until a first condition has been entered.\n * Default: `false` */",
      "clearButton?": "/** @deprecated\n */",
      "resetButton?": "/** @deprecated\n */",
      "applyButton?": "/** @deprecated\n */",
      "newRowsAction?": "/** @deprecated\n */",
      "column": "/** The column this filter is for. */",
      "colDef": "/** The column definition for the column. */",
      "rowModel": "/** The row model, helpful for looking up data values if needed.\n * If the filter needs to know which rows are\n * a) in the table,\n * b) currently visible (i.e. not already filtered),\n * c) which groups,\n * d) what order - all of this can be read from the rowModel. */",
      "filterChangedCallback": "/** A function callback to be called when the filter changes. The\n * grid will then respond by filtering the grid data. The callback\n * takes one optional parameter which, if included, will get merged\n * to the FilterChangedEvent object (useful for passing additional\n * information to anyone listening to this event, however such extra\n * attributes are not used by the grid). */",
      "filterModifiedCallback": "/** A function callback, to be optionally called, when the filter UI changes.\n * The grid will respond with emitting a FilterModifiedEvent.\n * Apart from emitting the event, the grid takes no further action. */",
      "valueGetter": "/** A function callback for the filter to get cell values from the row data.\n * Call with a node to be given the value for that filter's column for that node.\n * The callback takes care of selecting the right column definition and deciding whether to use valueGetter or field etc.\n * This is useful in, for example, creating an Excel style filter,\n * where the filter needs to lookup available values to allow the user to select from. */",
      "doesRowPassOtherFilter": "/** A function callback, call with a node to be told whether the node passes all filters except the current filter.\n * This is useful if you want to only present to the user values that this filter can filter given the status of the other filters.\n * The set filter uses this to remove from the list,\n * items that are no longer available due to the state of other filters (like Excel type filtering). */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "GridParams": {
    "meta": {},
    "type": {
      "globalEventListener?": "Function",
      "$scope?": "any",
      "$compile?": "any",
      "frameworkOverrides?": "IFrameworkOverrides",
      "providedBeanInstances?": "{ [key: string]: any; }",
      "modules?": "Module[]"
    }
  },
  "StartEditingCellParams": {
    "meta": {},
    "type": {
      "rowIndex": "number",
      "colKey": "string | Column",
      "rowPinned?": "string",
      "keyPress?": "number",
      "charPress?": "string"
    },
    "docs": {
      "rowIndex": "/** The row index of the row to start editing */",
      "colKey": "/** The column key of the row to start editing */",
      "rowPinned?": "/** Set to `'top'` or `'bottom'` to start editing a pinned row */",
      "keyPress?": "/** The keyPress to pass to the cell editor */",
      "charPress?": "/** The charPress to pass to the cell editor */"
    }
  },
  "GetCellsParams": {
    "meta": {},
    "type": { "rowNodes?": "RowNode[]", "columns?": "(string | Column)[]" },
    "docs": {
      "rowNodes?": "/** Optional list of row nodes to restrict operation to */",
      "columns?": "/** Optional list of columns to restrict operation to */"
    }
  },
  "RefreshCellsParams": {
    "meta": {},
    "type": {
      "force?": "boolean",
      "suppressFlash?": "boolean",
      "rowNodes?": "RowNode[]",
      "columns?": "(string | Column)[]"
    },
    "docs": {
      "force?": "/** Skip change detection, refresh everything. */",
      "suppressFlash?": "/** Skip cell flashing, if cell flashing is enabled. */",
      "rowNodes?": "/** Optional list of row nodes to restrict operation to */",
      "columns?": "/** Optional list of columns to restrict operation to */"
    }
  },
  "FlashCellsParams": {
    "meta": {},
    "type": {
      "flashDelay?": "number",
      "fadeDelay?": "number",
      "rowNodes?": "RowNode[]",
      "columns?": "(string | Column)[]"
    },
    "docs": {
      "rowNodes?": "/** Optional list of row nodes to restrict operation to */",
      "columns?": "/** Optional list of columns to restrict operation to */"
    }
  },
  "GetCellRendererInstancesParams": {
    "meta": {},
    "type": { "rowNodes?": "RowNode[]", "columns?": "(string | Column)[]" },
    "docs": {
      "rowNodes?": "/** Optional list of row nodes to restrict operation to */",
      "columns?": "/** Optional list of columns to restrict operation to */"
    }
  },
  "GetCellEditorInstancesParams": {
    "meta": {},
    "type": { "rowNodes?": "RowNode[]", "columns?": "(string | Column)[]" },
    "docs": {
      "rowNodes?": "/** Optional list of row nodes to restrict operation to */",
      "columns?": "/** Optional list of columns to restrict operation to */"
    }
  },
  "RedrawRowsParams": {
    "meta": {},
    "type": { "rowNodes?": "RowNode[]" },
    "docs": { "rowNodes?": "/** Row nodes to redraw */" }
  },
  "CreateChartParams": {
    "meta": {},
    "type": {
      "chartType": "ChartType",
      "chartThemeName?": "string",
      "chartContainer?": "HTMLElement",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean"
    },
    "docs": {
      "chartType": "/** The type of chart to create. */",
      "chartThemeName?": "/** The default theme to use, either a default option or your own custom theme. */",
      "chartContainer?": "/** Provide to display the chart outside of the grid in your own container. */",
      "chartThemeOverrides?": "/** Allows specific chart options in the current theme to be overridden. */",
      "unlinkChart?": "/** When enabled the chart will be unlinked from the grid after creation, any updates to the data will not be reflected in the chart. */"
    }
  },
  "CreateRangeChartParams": {
    "meta": {},
    "type": {
      "cellRange": "CellRangeParams",
      "suppressChartRanges?": "boolean",
      "aggFunc?": "string | IAggFunc",
      "processChartOptions?": "(params: ProcessChartOptionsParams) => ChartOptions<any>",
      "chartType": "ChartType",
      "chartThemeName?": "string",
      "chartContainer?": "HTMLElement",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean"
    },
    "docs": {
      "cellRange": "/** The range of cells to be charted. */",
      "suppressChartRanges?": "/** Suppress highlighting the selected range in the grid. */",
      "aggFunc?": "/** The aggregation function that should be applied to all series data. */",
      "processChartOptions?": "/** @deprecated since v24.0.0, use `chartThemeOverrides` instead\n */",
      "chartType": "/** The type of chart to create. */",
      "chartThemeName?": "/** The default theme to use, either a default option or your own custom theme. */",
      "chartContainer?": "/** Provide to display the chart outside of the grid in your own container. */",
      "chartThemeOverrides?": "/** Allows specific chart options in the current theme to be overridden. */",
      "unlinkChart?": "/** When enabled the chart will be unlinked from the grid after creation, any updates to the data will not be reflected in the chart. */"
    }
  },
  "CreateCrossFilterChartParams": {
    "meta": {},
    "type": {
      "cellRange": "CellRangeParams",
      "suppressChartRanges?": "boolean",
      "aggFunc?": "string | IAggFunc",
      "chartType": "ChartType",
      "chartThemeName?": "string",
      "chartContainer?": "HTMLElement",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean"
    },
    "docs": {
      "cellRange": "/** The range of cells to be charted. */",
      "suppressChartRanges?": "/** Suppress highlighting the selected range in the grid. */",
      "aggFunc?": "/** The aggregation function that should be applied to all series data. */",
      "chartType": "/** The type of chart to create. */",
      "chartThemeName?": "/** The default theme to use, either a default option or your own custom theme. */",
      "chartContainer?": "/** Provide to display the chart outside of the grid in your own container. */",
      "chartThemeOverrides?": "/** Allows specific chart options in the current theme to be overridden. */",
      "unlinkChart?": "/** When enabled the chart will be unlinked from the grid after creation, any updates to the data will not be reflected in the chart. */"
    }
  },
  "CreatePivotChartParams": {
    "meta": {},
    "type": {
      "processChartOptions?": "(params: ProcessChartOptionsParams) => ChartOptions<any>",
      "chartType": "ChartType",
      "chartThemeName?": "string",
      "chartContainer?": "HTMLElement",
      "chartThemeOverrides?": "AgChartThemeOverrides",
      "unlinkChart?": "boolean"
    },
    "docs": {
      "processChartOptions?": "/** @deprecated since v24.0.0, use `chartThemeOverrides` instead\n */",
      "chartType": "/** The type of chart to create. */",
      "chartThemeName?": "/** The default theme to use, either a default option or your own custom theme. */",
      "chartContainer?": "/** Provide to display the chart outside of the grid in your own container. */",
      "chartThemeOverrides?": "/** Allows specific chart options in the current theme to be overridden. */",
      "unlinkChart?": "/** When enabled the chart will be unlinked from the grid after creation, any updates to the data will not be reflected in the chart. */"
    }
  },
  "DetailGridInfo": {
    "meta": {},
    "type": { "id": "string", "api?": "GridApi", "columnApi?": "ColumnApi" },
    "docs": {
      "id": "/** Id of the detail grid, the format is `detail_<ROW_ID>`,\n * where ROW_ID is the `id` of the parent row. */",
      "api?": "/** Grid api of the detail grid. */",
      "columnApi?": "/** Column api of the detail grid. */"
    }
  },
  "IFakeHScrollComp": {
    "meta": {},
    "type": {
      "setHeight(height: number)": "void",
      "setViewportHeight(height: number)": "void",
      "setContainerHeight(height: number)": "void",
      "setRightSpacerFixedWidth(width: number)": "void",
      "setLeftSpacerFixedWidth(width: number)": "void",
      "setInvisibleStyles(isInvisible: boolean)": "void",
      "includeLeftSpacerScrollerCss(cssClass: string, include: boolean)": "void",
      "includeRightSpacerScrollerCss(cssClass: string, include: boolean)": "void"
    }
  },
  "RowAnimationCssClasses": {
    "meta": { "isEnum": true },
    "type": [
      "ANIMATION_ON = 'ag-row-animation'",
      "ANIMATION_OFF = 'ag-row-no-animation'"
    ],
    "docs": [null, null]
  },
  "IGridBodyComp": {
    "meta": {},
    "type": {
      "setColumnMovingCss(cssClass: string | null, on: boolean)": "void",
      "setCellSelectableCss(cssClass: string | null, on: boolean)": "void",
      "setTopHeight(height: number)": "void",
      "setTopDisplay(display: string)": "void",
      "setBottomHeight(height: number)": "void",
      "setBottomDisplay(display: string)": "void",
      "setColumnCount(count: number)": "void",
      "setRowCount(count: number)": "void",
      "setRowAnimationCssOnBodyViewport(cssClass: string, animate: boolean)": "void",
      "setAlwaysVerticalScrollClass(cssClass: string | null, on: boolean)": "void",
      "setPinnedTopBottomOverflowY(overflow: string)": "void",
      "registerBodyViewportResizeListener(listener: (() => void))": "void",
      "updateLayoutClasses(layoutClass: string, params: UpdateLayoutClassesParams)": "void"
    }
  },
  "NavigateParams": {
    "meta": {},
    "type": {
      "scrollIndex": "number",
      "scrollType": "'top' | 'bottom' | null",
      "scrollColumn": "Column | null",
      "focusIndex": "number",
      "focusColumn": "Column"
    },
    "docs": {
      "scrollIndex": "/** The rowIndex to vertically scroll to. */",
      "scrollType": "/** The position to put scroll index. */",
      "scrollColumn": "/** The column to horizontally scroll to. */",
      "focusIndex": "/** For page up/down, we want to scroll to one row/column but focus another (ie. scrollRow could be stub). */"
    }
  },
  "RenderParams": { "meta": {}, "type": { "rows": "RowNode" } },
  "RenderRowsFeature": {
    "meta": {},
    "type": { "render(rows: RowNode[])": "void" }
  },
  "RowContainerName": {
    "meta": { "isEnum": true },
    "type": [
      "LEFT = 'left'",
      "RIGHT = 'right'",
      "CENTER = 'center'",
      "FULL_WIDTH = 'fullWidth'",
      "TOP_LEFT = 'topLeft'",
      "TOP_RIGHT = 'topRight'",
      "TOP_CENTER = 'topCenter'",
      "TOP_FULL_WITH = 'topFullWidth'",
      "BOTTOM_LEFT = 'bottomLeft'",
      "BOTTOM_RIGHT = 'bottomRight'",
      "BOTTOM_CENTER = 'bottomCenter'",
      "BOTTOM_FULL_WITH = 'bottomFullWidth'"
    ],
    "docs": [
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null
    ]
  },
  "IRowContainerComp": {
    "meta": {},
    "type": {
      "setViewportHeight(height: string)": "void",
      "setRowCtrls(rowCtrls: RowCtrl[])": "void",
      "setDomOrder(domOrder: boolean)": "void",
      "setContainerWidth(width: string)": "void"
    }
  },
  "RowDropZoneEvents": {
    "meta": {},
    "type": {
      "onDragEnter?": "(params: RowDragEnterEvent) => void",
      "onDragLeave?": "(params: RowDragLeaveEvent) => void",
      "onDragging?": "(params: RowDragMoveEvent) => void",
      "onDragStop?": "(params: RowDragEndEvent) => void"
    },
    "docs": {
      "onDragEnter?": "/** Callback function that will be executed when the rowDrag enters the target. */",
      "onDragLeave?": "/** Callback function that will be executed when the rowDrag leaves the target */",
      "onDragging?": "/** Callback function that will be executed when the rowDrag is dragged inside the target.\n * Note: this gets called multiple times. */",
      "onDragStop?": "/** Callback function that will be executed when the rowDrag drops rows within the target. */"
    }
  },
  "RowDropZoneParams": {
    "meta": {},
    "type": {
      "getContainer": "() => HTMLElement",
      "onDragEnter?": "(params: RowDragEnterEvent) => void",
      "onDragLeave?": "(params: RowDragLeaveEvent) => void",
      "onDragging?": "(params: RowDragMoveEvent) => void",
      "onDragStop?": "(params: RowDragEndEvent) => void"
    },
    "docs": {
      "getContainer": "/** A callback method that returns the DropZone HTMLElement. */",
      "onDragEnter?": "/** Callback function that will be executed when the rowDrag enters the target. */",
      "onDragLeave?": "/** Callback function that will be executed when the rowDrag leaves the target */",
      "onDragging?": "/** Callback function that will be executed when the rowDrag is dragged inside the target.\n * Note: this gets called multiple times. */",
      "onDragStop?": "/** Callback function that will be executed when the rowDrag drops rows within the target. */"
    }
  },
  "SetScrollsVisibleParams": {
    "meta": {},
    "type": {
      "horizontalScrollShowing": "boolean",
      "verticalScrollShowing": "boolean"
    }
  },
  "IGridComp": {
    "meta": {},
    "type": {
      "setRtlClass(cssClass: string)": "void",
      "destroyGridUi()": "void",
      "forceFocusOutOfContainer(up: boolean)": "void",
      "addOrRemoveKeyboardFocusClass(value: boolean)": "void",
      "getFocusableContainers()": "HTMLElement[]",
      "setCursor(value: string | null)": "void",
      "setUserSelect(value: string | null)": "void",
      "updateLayoutClasses(layoutClass: string, params: UpdateLayoutClassesParams)": "void"
    }
  },
  "PropertyChangedEvent": {
    "meta": {},
    "type": { "currentValue": "any", "previousValue": "any", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "IAbstractHeaderCellComp": { "meta": {}, "type": {} },
  "IHeaderCellComp": {
    "meta": {},
    "type": {
      "setWidth(width: string)": "void",
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "setAriaSort(sort: ColumnSortState | undefined)": "void",
      "setColId(id: string)": "void",
      "setAriaDescribedBy(id: string | undefined)": "void",
      "setUserCompDetails(compDetails: UserCompDetails)": "void",
      "getUserCompInstance()": "IHeader | undefined",
      "setTitle(title: string | undefined)": "void"
    }
  },
  "IHeaderParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "displayName": "string",
      "enableSorting": "boolean",
      "enableMenu": "boolean",
      "showColumnMenu": "(source: HTMLElement) => void",
      "progressSort": "(multiSort?: boolean) => void",
      "setSort": "(sort: string, multiSort?: boolean) => void",
      "template": "string",
      "eGridHeader": "HTMLElement",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "column": "/** The column the header is for. */",
      "displayName": "/** The name to display for the column. \n * If the column is using a headerValueGetter, the displayName will take this into account. */",
      "enableSorting": "/** Whether sorting is enabled for the column. \n * Only put sort logic into your header if this is true. */",
      "enableMenu": "/** Whether menu is enabled for the column.\n * Only display a menu button in your header if this is true. */",
      "showColumnMenu": "/** Callback to request the grid to show the column menu.\n * Pass in the html element of the column menu to have the\n *   grid position the menu over the button. */",
      "progressSort": "/** Callback to progress the sort for this column.\n * The grid will decide the next sort direction eg ascending, descending or 'no sort'.\n * Pass `multiSort=true` if you want to do a multi sort (eg user has Shift held down when they click). */",
      "setSort": "/** Callback to set the sort for this column.\n * Pass the sort direction to use ignoring the current sort eg one of 'asc', 'desc' or null (for no sort).\n * Pass `multiSort=true` if you want to do a multi sort (eg user has Shift held down when they click) */",
      "eGridHeader": "/** The header the grid provides. \n * The custom header component is a child of the grid provided header.\n * The grid's header component is what contains the grid managed functionality such as resizing, keyboard navigation etc.\n * This is provided should you want to make changes to this cell,\n * eg add ARIA tags, or add keyboard event listener (as focus goes here when navigating to the header). */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "IHeader": {
    "meta": {},
    "type": { "refresh(params: IHeaderParams)": "boolean" },
    "docs": {
      "refresh(params: IHeaderParams)": "/** Get the header to refresh. Gets called whenever Column Defs are updated. */"
    }
  },
  "IHeaderComp": {
    "meta": {},
    "type": {
      "refresh(params: IHeaderParams)": "boolean",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: IHeaderParams)": "AgPromise<void> | void"
    },
    "docs": {
      "refresh(params: IHeaderParams)": "/** Get the header to refresh. Gets called whenever Column Defs are updated. */",
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: IHeaderParams)": "/** The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "SelectionCount": {
    "meta": {},
    "type": { "selected": "number", "notSelected": "number" }
  },
  "IHeaderGroupCellComp": {
    "meta": {},
    "type": {
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "addOrRemoveResizableCssClass(cssClassName: string, on: boolean)": "void",
      "setWidth(width: string)": "void",
      "setColId(id: string)": "void",
      "setAriaExpanded(expanded: 'true' | 'false' | undefined)": "void",
      "setUserCompDetails(compDetails: UserCompDetails)": "void",
      "setTitle(title: string | undefined)": "void"
    }
  },
  "IHeaderGroupParams": {
    "meta": {},
    "type": {
      "columnGroup": "ColumnGroup",
      "displayName": "string",
      "setExpanded": "(expanded: boolean) => void",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "columnGroup": "/** The column group the header is for. */",
      "displayName": "/** The text label to render.\n * If the column is using a headerValueGetter, the displayName will take this into account. */",
      "setExpanded": "/** Opens / closes the column group */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "IHeaderGroup": { "meta": {}, "type": {} },
  "IHeaderGroupComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: IHeaderGroupParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: IHeaderGroupParams)": "/** The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "IHeaderFilterCellComp": { "meta": {}, "type": {} },
  "DropListener": {
    "meta": {},
    "type": {
      "getIconName()": "string | null",
      "onDragEnter(params: DraggingEvent)": "void",
      "onDragLeave(params: DraggingEvent)": "void",
      "onDragging(params: DraggingEvent)": "void",
      "onDragStop(params: DraggingEvent)": "void"
    }
  },
  "HeaderNavigationDirection": {
    "meta": { "isEnum": true },
    "type": ["UP", "DOWN", "LEFT", "RIGHT"],
    "docs": [null, null, null, null]
  },
  "HeaderPosition": {
    "meta": {},
    "type": { "headerRowIndex": "number", "column": "Column | ColumnGroup" },
    "docs": {
      "headerRowIndex": "/** A number from 0 to n, where n is the last header row the grid is rendering */",
      "column": "/** The grid column or column group */"
    }
  },
  "HorizontalResizeParams": {
    "meta": {},
    "type": {
      "eResizeBar": "HTMLElement",
      "dragStartPixels?": "number",
      "onResizeStart": "(shiftKey: boolean) => void",
      "onResizing": "(delta: number) => void",
      "onResizeEnd": "(delta: number) => void"
    }
  },
  "IGridHeaderComp": {
    "meta": {},
    "type": {
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "setHeightAndMinHeight(height: string)": "void"
    }
  },
  "HeaderRowType": {
    "meta": { "isEnum": true },
    "type": [
      "COLUMN_GROUP = 'group'",
      "COLUMN = 'column'",
      "FLOATING_FILTER = 'filter'"
    ],
    "docs": [null, null, null]
  },
  "IHeaderRowComp": {
    "meta": {},
    "type": {
      "setTransform(transform: string)": "void",
      "setTop(top: string)": "void",
      "setHeight(height: string)": "void",
      "setHeaderCtrls(ctrls: AbstractHeaderCellCtrl[])": "void",
      "setWidth(width: string)": "void",
      "setAriaRowIndex(rowIndex: number)": "void"
    }
  },
  "IHeaderRowContainerComp": {
    "meta": {},
    "type": {
      "setCenterWidth(width: string)": "void",
      "setContainerTransform(transform: string)": "void",
      "setPinnedContainerWidth(width: string)": "void",
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "setCtrls(ctrls: HeaderRowCtrl[])": "void"
    }
  },
  "ILogger": { "meta": {}, "type": { "log(message: string)": "void" } },
  "BaseExportParams": {
    "meta": {},
    "type": {
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "fileName?": "string",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string",
      "columnGroups?": "boolean",
      "skipGroups?": "boolean",
      "skipHeader?": "boolean"
    },
    "docs": {
      "columnGroups?": "/** @deprecated\n */",
      "skipGroups?": "/** @deprecated\n */",
      "skipHeader?": "/** @deprecated\n */"
    }
  },
  "ExportParams": {
    "meta": { "typeParams": ["T"] },
    "type": {
      "prependContent?": "T",
      "appendContent?": "T",
      "customHeader?": "T",
      "customFooter?": "T",
      "getCustomContentBelowRow?": "(params: ProcessRowGroupForExportParams) => T | undefined",
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "fileName?": "string",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string",
      "columnGroups?": "boolean",
      "skipGroups?": "boolean",
      "skipHeader?": "boolean"
    },
    "docs": {
      "customHeader?": "/** @deprecated Use prependContent\n */",
      "customFooter?": "/** @deprecated Use appendContent\n */",
      "columnGroups?": "/** @deprecated\n */",
      "skipGroups?": "/** @deprecated\n */",
      "skipHeader?": "/** @deprecated\n */"
    }
  },
  "PackageFileParams": {
    "meta": { "isTypeAlias": true, "typeParams": ["T"] },
    "type": "T & { data: string[]; }"
  },
  "CsvCell": {
    "meta": {},
    "type": { "data": "CsvCellData", "mergeAcross?": "number" }
  },
  "CsvCellData": { "meta": {}, "type": { "value": "string | null" } },
  "CsvCustomContent": {
    "meta": { "isTypeAlias": true },
    "type": "CsvCell[][] | string"
  },
  "CsvExportParams": {
    "meta": {},
    "type": {
      "columnSeparator?": "string",
      "suppressQuotes?": "boolean",
      "prependContent?": "CsvCustomContent",
      "appendContent?": "CsvCustomContent",
      "customHeader?": "CsvCustomContent",
      "customFooter?": "CsvCustomContent",
      "getCustomContentBelowRow?": "(params: ProcessRowGroupForExportParams) => CsvCustomContent | undefined",
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "fileName?": "string",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string",
      "columnGroups?": "boolean",
      "skipGroups?": "boolean",
      "skipHeader?": "boolean"
    },
    "docs": {
      "customHeader?": "/** @deprecated Use prependContent\n */",
      "customFooter?": "/** @deprecated Use appendContent\n */",
      "columnGroups?": "/** @deprecated\n */",
      "skipGroups?": "/** @deprecated\n */",
      "skipHeader?": "/** @deprecated\n */"
    }
  },
  "ShouldRowBeSkippedParams": {
    "meta": {},
    "type": { "node": "RowNode", "api": "GridApi", "context": "any" },
    "docs": {
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ProcessCellForExportParams": {
    "meta": {},
    "type": {
      "value": "any",
      "accumulatedRowIndex?": "number",
      "node?": "RowNode | null",
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "type": "string"
    },
    "docs": {
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ProcessHeaderForExportParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ProcessGroupHeaderForExportParams": {
    "meta": {},
    "type": {
      "columnGroup": "ColumnGroup",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ProcessRowGroupForExportParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ContainerType": {
    "meta": { "isTypeAlias": true },
    "type": "'columnMenu' | 'contextMenu' | 'toolPanel' | 'floatingFilter'"
  },
  "IAfterGuiAttachedParams": {
    "meta": {},
    "type": {
      "container?": "ContainerType",
      "hidePopup?": "() => void",
      "suppressFocus?": "boolean"
    }
  },
  "FontStyle": {
    "meta": { "isTypeAlias": true },
    "type": "'normal' | 'italic' | 'oblique'"
  },
  "FontWeight": {
    "meta": { "isTypeAlias": true },
    "type": "'normal' | 'bold' | 'bolder' | 'lighter' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900'"
  },
  "AgChartThemeName": {
    "meta": { "isTypeAlias": true },
    "type": "'ag-default' | 'ag-default-dark' | 'ag-material' | 'ag-material-dark' | 'ag-pastel' | 'ag-pastel-dark' | 'ag-solar' | 'ag-solar-dark' | 'ag-vivid' | 'ag-vivid-dark'"
  },
  "AgChartThemePalette": {
    "meta": {},
    "type": { "fills": "string[]", "strokes": "string[]" }
  },
  "AgChartThemeOptions": {
    "meta": {},
    "type": {
      "palette?": "AgChartThemePalette",
      "overrides?": "AgChartThemeOverrides"
    }
  },
  "AgChartTheme": {
    "meta": {},
    "type": {
      "baseTheme?": "AgChartThemeName",
      "palette?": "AgChartThemePalette",
      "overrides?": "AgChartThemeOverrides"
    }
  },
  "AgChartThemeOverrides": {
    "meta": {},
    "type": {
      "cartesian?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgCartesianSeriesTheme>",
      "column?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgBarSeriesOptions>",
      "bar?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgBarSeriesOptions>",
      "line?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgLineSeriesOptions>",
      "area?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgAreaSeriesOptions>",
      "scatter?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgScatterSeriesOptions>",
      "histogram?": "AgCartesianChartOptions<AgCartesianAxesTheme, AgHistogramSeriesOptions>",
      "polar?": "AgPolarChartOptions<AgPolarAxesTheme, AgPolarSeriesTheme>",
      "pie?": "AgPolarChartOptions<AgPolarAxesTheme, AgPieSeriesOptions>",
      "common?": "any"
    }
  },
  "AgCartesianAxesTheme": {
    "meta": {},
    "type": {
      "number?": "Omit<AgNumberAxisOptions, 'type'>",
      "category?": "Omit<AgCategoryAxisOptions, 'type'>",
      "groupedCategory?": "Omit<AgGroupedCategoryAxisOptions, 'type'>",
      "time?": "Omit<AgTimeAxisOptions, 'type'>"
    }
  },
  "AgCartesianSeriesTheme": {
    "meta": {},
    "type": {
      "line?": "AgLineSeriesOptions",
      "scatter?": "AgScatterSeriesOptions",
      "area?": "AgAreaSeriesOptions",
      "bar?": "AgBarSeriesOptions",
      "histogram?": "AgHistogramSeriesOptions"
    }
  },
  "AgPolarAxesTheme": { "meta": {}, "type": {} },
  "AgPolarSeriesTheme": {
    "meta": {},
    "type": { "pie?": "AgPieSeriesOptions" }
  },
  "AgChartPaddingOptions": {
    "meta": {},
    "type": {
      "top?": "number",
      "right?": "number",
      "bottom?": "number",
      "left?": "number"
    }
  },
  "AgChartLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgDropShadowOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "color?": "string",
      "xOffset?": "number",
      "yOffset?": "number",
      "blue?": "number"
    }
  },
  "AgChartCaptionOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "padding?": "AgChartPaddingOptions",
      "text?": "string",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgNavigatorMaskOptions": {
    "meta": {},
    "type": {
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "fillOpacity?": "number"
    }
  },
  "AgNavigatorHandleOptions": {
    "meta": {},
    "type": {
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "width?": "number",
      "height?": "number",
      "gripLineGap?": "number",
      "gripLineLength?": "number"
    }
  },
  "AgNavigatorOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "height?": "number",
      "margin?": "number",
      "min?": "number",
      "max?": "number",
      "mask?": "AgNavigatorMaskOptions",
      "minHandle?": "AgNavigatorHandleOptions",
      "maxHandle?": "AgNavigatorHandleOptions"
    }
  },
  "AgChartLegendPosition": {
    "meta": { "isTypeAlias": true },
    "type": "'top' | 'right' | 'bottom' | 'left'"
  },
  "AgChartLegendMarkerOptions": {
    "meta": {},
    "type": {
      "size?": "number",
      "shape?": "string | (new () => any)",
      "padding?": "number",
      "strokeWidth?": "number"
    }
  },
  "AgChartLegendLabelOptions": {
    "meta": {},
    "type": {
      "color?": "string",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string"
    }
  },
  "AgChartLegendItemOptions": {
    "meta": {},
    "type": {
      "marker?": "AgChartLegendMarkerOptions",
      "label?": "AgChartLegendLabelOptions",
      "paddingX?": "number",
      "paddingY?": "number"
    }
  },
  "AgChartLegendOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "position?": "AgChartLegendPosition",
      "spacing?": "number",
      "item?": "AgChartLegendItemOptions",
      "layoutHorizontalSpacing?": "number",
      "layoutVerticalSpacing?": "number",
      "itemSpacing?": "number",
      "markerShape?": "string | (new () => any)",
      "markerSize?": "number",
      "strokeWidth?": "number",
      "color?": "string",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string"
    },
    "docs": {
      "layoutHorizontalSpacing?": "/** @deprecated\n */",
      "layoutVerticalSpacing?": "/** @deprecated\n */",
      "itemSpacing?": "/** @deprecated\n */",
      "markerShape?": "/** @deprecated\n */",
      "markerSize?": "/** @deprecated\n */",
      "strokeWidth?": "/** @deprecated\n */",
      "color?": "/** @deprecated\n */",
      "fontStyle?": "/** @deprecated\n */",
      "fontWeight?": "/** @deprecated\n */",
      "fontSize?": "/** @deprecated\n */",
      "fontFamily?": "/** @deprecated\n */"
    }
  },
  "AgBaseChartOptions": {
    "meta": {},
    "type": {
      "container?": "HTMLElement",
      "data?": "any[]",
      "width?": "number",
      "height?": "number",
      "autoSize?": "boolean",
      "padding?": "AgChartPaddingOptions",
      "background?": "{ visible?: boolean; fill?: string; }",
      "title?": "AgChartCaptionOptions",
      "subtitle?": "AgChartCaptionOptions",
      "tooltipClass?": "string",
      "tooltipTracking?": "boolean",
      "navigator?": "AgNavigatorOptions",
      "legend?": "AgChartLegendOptions",
      "listeners?": "{[key in string]: Function}",
      "theme?": "string | AgChartTheme"
    }
  },
  "AgBaseAxisOptions": { "meta": {}, "type": { "keys?": "string[]" } },
  "AgCartesianAxisPosition": {
    "meta": { "isTypeAlias": true },
    "type": "'top' | 'right' | 'bottom' | 'left'"
  },
  "AgAxisLineOptions": {
    "meta": {},
    "type": { "width?": "number", "color?": "string" }
  },
  "AgAxisTickOptions": {
    "meta": {},
    "type": {
      "width?": "number",
      "size?": "number",
      "color?": "string",
      "count?": "any"
    }
  },
  "AgAxisLabelFormatterParams": {
    "meta": {},
    "type": {
      "value": "any",
      "index": "number",
      "fractionDigits?": "number",
      "formatter?": "(x: any) => string"
    }
  },
  "AgAxisLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "padding?": "number",
      "color?": "string",
      "rotation?": "number",
      "format?": "string",
      "formatter?": "(params: AgAxisLabelFormatterParams) => string"
    }
  },
  "AgAxisGridStyle": {
    "meta": {},
    "type": { "stroke?": "string", "lineDash?": "number[]" }
  },
  "AgBaseCartesianAxisOptions": {
    "meta": {},
    "type": {
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]",
      "keys?": "string[]"
    }
  },
  "AgNumberAxisOptions": {
    "meta": {},
    "type": {
      "type": "'number'",
      "nice?": "boolean",
      "min?": "number",
      "max?": "number",
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]",
      "keys?": "string[]"
    }
  },
  "AgCategoryAxisOptions": {
    "meta": {},
    "type": {
      "type": "'category'",
      "paddingInner?": "number",
      "paddingOuter?": "number",
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]",
      "keys?": "string[]"
    }
  },
  "AgGroupedCategoryAxisOptions": {
    "meta": {},
    "type": {
      "type": "'groupedCategory'",
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]",
      "keys?": "string[]"
    }
  },
  "AgTimeAxisOptions": {
    "meta": {},
    "type": {
      "type": "'time'",
      "nice?": "boolean",
      "position?": "AgCartesianAxisPosition",
      "title?": "AgChartCaptionOptions",
      "line?": "AgAxisLineOptions",
      "tick?": "AgAxisTickOptions",
      "label?": "AgAxisLabelOptions",
      "gridStyle?": "AgAxisGridStyle[]",
      "keys?": "string[]"
    }
  },
  "AgCartesianAxisOptions": {
    "meta": { "isTypeAlias": true },
    "type": "AgNumberAxisOptions | AgCategoryAxisOptions | AgGroupedCategoryAxisOptions | AgTimeAxisOptions"
  },
  "AgPolarAxisOptions": { "meta": { "isTypeAlias": true }, "type": "any" },
  "AgBaseSeriesOptions": {
    "meta": {},
    "type": {
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "highlightStyle?": "{ fill?: string; stroke?: string; strokeWidth?: number; series?: { enabled?: boolean; dimOpacity?: number; strokeWidth?: number; }; }"
    }
  },
  "AgTooltipRendererResult": {
    "meta": {},
    "type": { "title?": "string", "content?": "string" }
  },
  "AgSeriesTooltipRendererParams": {
    "meta": {},
    "type": { "datum": "any", "title?": "string", "color?": "string" }
  },
  "AgCartesianSeriesTooltipRendererParams": {
    "meta": {},
    "type": {
      "xKey": "string",
      "xValue?": "any",
      "xName?": "string",
      "yKey": "string",
      "yValue?": "any",
      "yName?": "string",
      "datum": "any",
      "title?": "string",
      "color?": "string"
    }
  },
  "AgPolarSeriesTooltipRendererParams": {
    "meta": {},
    "type": {
      "angleKey": "string",
      "angleValue?": "any",
      "angleName?": "string",
      "radiusKey?": "string",
      "radiusValue?": "any",
      "radiusName?": "string",
      "datum": "any",
      "title?": "string",
      "color?": "string"
    }
  },
  "AgScatterSeriesTooltipRendererParams": {
    "meta": {},
    "type": {
      "sizeKey?": "string",
      "sizeName?": "string",
      "labelKey?": "string",
      "labelName?": "string",
      "xKey": "string",
      "xValue?": "any",
      "xName?": "string",
      "yKey": "string",
      "yValue?": "any",
      "yName?": "string",
      "datum": "any",
      "title?": "string",
      "color?": "string"
    }
  },
  "AgSeriesMarker": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "shape?": "string",
      "size?": "number",
      "maxSize?": "number",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number"
    }
  },
  "AgCartesianSeriesMarkerFormatterParams": {
    "meta": {},
    "type": { "xKey": "string", "yKey": "string" }
  },
  "AgCartesianSeriesMarkerFormat": {
    "meta": {},
    "type": {
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "size?": "number"
    }
  },
  "AgCartesianSeriesMarker": {
    "meta": {},
    "type": {
      "formatter?": "(params: AgCartesianSeriesMarkerFormatterParams) => AgCartesianSeriesMarkerFormat",
      "enabled?": "boolean",
      "shape?": "string",
      "size?": "number",
      "maxSize?": "number",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number"
    }
  },
  "AgSeriesTooltip": { "meta": {}, "type": { "enabled?": "boolean" } },
  "AgLineSeriesTooltip": {
    "meta": {},
    "type": {
      "renderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "enabled?": "boolean"
    }
  },
  "AgLineSeriesLabelOptions": {
    "meta": {},
    "type": {
      "formatter?": "(params: { value: any; }) => string",
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgLineSeriesOptions": {
    "meta": {},
    "type": {
      "type?": "'line'",
      "marker?": "AgCartesianSeriesMarker",
      "label?": "AgLineSeriesLabelOptions",
      "xKey?": "string",
      "yKey?": "string",
      "xName?": "string",
      "yName?": "string",
      "title?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "strokeOpacity?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "tooltip?": "AgLineSeriesTooltip",
      "tooltipRenderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "highlightStyle?": "{ fill?: string; stroke?: string; strokeWidth?: number; series?: { enabled?: boolean; dimOpacity?: number; strokeWidth?: number; }; }"
    }
  },
  "AgScatterSeriesTooltip": {
    "meta": {},
    "type": {
      "renderer?": "(params: AgScatterSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "enabled?": "boolean"
    }
  },
  "AgScatterSeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgScatterSeriesOptions": {
    "meta": {},
    "type": {
      "type?": "'scatter'",
      "marker?": "AgCartesianSeriesMarker",
      "label?": "AgScatterSeriesLabelOptions",
      "xKey?": "string",
      "yKey?": "string",
      "xName?": "string",
      "yName?": "string",
      "title?": "string",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "tooltip?": "AgScatterSeriesTooltip",
      "tooltipRenderer?": "(params: AgScatterSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "highlightStyle?": "{ fill?: string; stroke?: string; strokeWidth?: number; series?: { enabled?: boolean; dimOpacity?: number; strokeWidth?: number; }; }"
    }
  },
  "AgAreaSeriesTooltip": {
    "meta": {},
    "type": {
      "renderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "format?": "string",
      "enabled?": "boolean"
    }
  },
  "AgAreaSeriesLabelOptions": {
    "meta": {},
    "type": {
      "formatter?": "(params: { value: any; }) => string",
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgAreaSeriesOptions": {
    "meta": {},
    "type": {
      "type?": "'area'",
      "marker?": "AgCartesianSeriesMarker",
      "label?": "AgAreaSeriesLabelOptions",
      "xKey?": "string",
      "yKeys?": "string[]",
      "xName?": "string",
      "yNames?": "string[]",
      "fills?": "string[]",
      "strokes?": "string[]",
      "strokeWidth?": "number",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "shadow?": "AgDropShadowOptions",
      "tooltip?": "AgAreaSeriesTooltip",
      "tooltipRenderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "highlightStyle?": "{ fill?: string; stroke?: string; strokeWidth?: number; series?: { enabled?: boolean; dimOpacity?: number; strokeWidth?: number; }; }"
    }
  },
  "AgBarSeriesLabelOptions": {
    "meta": {},
    "type": {
      "formatter?": "(params: { value: number; }) => string",
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgBarSeriesFormatterParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth": "number",
      "highlighted": "boolean",
      "xKey": "string",
      "yKey": "string"
    }
  },
  "AgBarSeriesFormat": {
    "meta": {},
    "type": { "fill?": "string", "stroke?": "string", "strokeWidth?": "number" }
  },
  "AgBarSeriesTooltip": {
    "meta": {},
    "type": {
      "renderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "enabled?": "boolean"
    }
  },
  "AgBarSeriesOptions": {
    "meta": {},
    "type": {
      "type?": "'bar' | 'column'",
      "grouped?": "boolean",
      "normalizedTo?": "number",
      "xKey?": "string",
      "yKeys?": "string[] | string[][]",
      "xName?": "string",
      "yNames?": "string[] | { [key in string]: string; }",
      "fills?": "string[]",
      "strokes?": "string[]",
      "strokeWidth?": "number",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "shadow?": "AgDropShadowOptions",
      "label?": "AgBarSeriesLabelOptions",
      "tooltip?": "AgBarSeriesTooltip",
      "tooltipRenderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "formatter?": "(params: AgBarSeriesFormatterParams) => AgBarSeriesFormat",
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "highlightStyle?": "{ fill?: string; stroke?: string; strokeWidth?: number; series?: { enabled?: boolean; dimOpacity?: number; strokeWidth?: number; }; }"
    }
  },
  "AgHistogramSeriesLabelOptions": {
    "meta": {},
    "type": {
      "formatter?": "(params: { value: number; }) => string",
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgHistogramSeriesTooltip": {
    "meta": {},
    "type": {
      "renderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "enabled?": "boolean"
    }
  },
  "AgHistogramSeriesOptions": {
    "meta": {},
    "type": {
      "type?": "'histogram'",
      "fill?": "string",
      "stroke?": "string",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "strokeWidth?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "xKey?": "string",
      "xName?": "string",
      "yKey?": "string",
      "yName?": "string",
      "areaPlot?": "boolean",
      "bins?": "[number, number][]",
      "binCount?": "number",
      "aggregation?": "'count' | 'sum' | 'mean'",
      "shadow?": "AgDropShadowOptions",
      "label?": "AgHistogramSeriesLabelOptions",
      "tooltip?": "AgHistogramSeriesTooltip",
      "tooltipRenderer?": "(params: AgCartesianSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "highlightStyle?": "{ fill?: string; stroke?: string; strokeWidth?: number; series?: { enabled?: boolean; dimOpacity?: number; strokeWidth?: number; }; }"
    }
  },
  "AgPieSeriesLabelOptions": {
    "meta": {},
    "type": {
      "offset?": "number",
      "minAngle?": "number",
      "enabled?": "boolean",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgPieSeriesFormatterParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth": "number",
      "highlighted": "boolean",
      "angleKey": "string",
      "radiusKey?": "string"
    }
  },
  "AgPieSeriesFormat": {
    "meta": {},
    "type": { "fill?": "string", "stroke?": "string", "strokeWidth?": "number" }
  },
  "AgPieSeriesTooltip": {
    "meta": {},
    "type": {
      "renderer?": "(params: AgPieSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "enabled?": "boolean"
    }
  },
  "AgPieTitleOptions": {
    "meta": {},
    "type": {
      "showInLegend?": "boolean",
      "enabled?": "boolean",
      "padding?": "AgChartPaddingOptions",
      "text?": "string",
      "fontStyle?": "FontStyle",
      "fontWeight?": "FontWeight",
      "fontSize?": "number",
      "fontFamily?": "string",
      "color?": "string"
    }
  },
  "AgPieSeriesOptions": {
    "meta": {},
    "type": {
      "type?": "'pie'",
      "title?": "AgPieTitleOptions",
      "label?": "AgPieSeriesLabelOptions",
      "callout?": "{ colors?: string[]; length?: number; strokeWidth?: number; }",
      "angleKey?": "string",
      "angleName?": "string",
      "radiusKey?": "string",
      "radiusName?": "string",
      "labelKey?": "string",
      "labelName?": "string",
      "fills?": "string[]",
      "strokes?": "string[]",
      "fillOpacity?": "number",
      "strokeOpacity?": "number",
      "strokeWidth?": "number",
      "lineDash?": "number[]",
      "lineDashOffset?": "number",
      "rotation?": "number",
      "outerRadiusOffset?": "number",
      "innerRadiusOffset?": "number",
      "shadow?": "AgDropShadowOptions",
      "tooltip?": "AgPieSeriesTooltip",
      "tooltipRenderer?": "(params: AgPieSeriesTooltipRendererParams) => string | AgTooltipRendererResult",
      "formatter?": "(params: AgPieSeriesFormatterParams) => AgPieSeriesFormat",
      "tooltipEnabled?": "boolean",
      "data?": "any[]",
      "visible?": "boolean",
      "showInLegend?": "boolean",
      "listeners?": "{[key in string]: Function}",
      "highlightStyle?": "{ fill?: string; stroke?: string; strokeWidth?: number; series?: { enabled?: boolean; dimOpacity?: number; strokeWidth?: number; }; }"
    }
  },
  "AgPieSeriesTooltipRendererParams": {
    "meta": {},
    "type": {
      "labelKey?": "string",
      "labelName?": "string",
      "angleKey": "string",
      "angleValue?": "any",
      "angleName?": "string",
      "radiusKey?": "string",
      "radiusValue?": "any",
      "radiusName?": "string",
      "datum": "any",
      "title?": "string",
      "color?": "string"
    }
  },
  "AgCartesianSeriesOptions": {
    "meta": { "isTypeAlias": true },
    "type": "AgLineSeriesOptions | AgScatterSeriesOptions | AgAreaSeriesOptions | AgBarSeriesOptions | AgHistogramSeriesOptions"
  },
  "AgPolarSeriesOptions": {
    "meta": { "isTypeAlias": true },
    "type": "AgPieSeriesOptions"
  },
  "AgCartesianChartOptions": {
    "meta": { "typeParams": ["TAxisOptions", "TSeriesOptions"] },
    "type": {
      "type?": "'cartesian' | 'groupedCategory' | 'line' | 'bar' | 'column' | 'area' | 'scatter'",
      "axes?": "TAxisOptions",
      "series?": "TSeriesOptions",
      "container?": "HTMLElement",
      "data?": "any[]",
      "width?": "number",
      "height?": "number",
      "autoSize?": "boolean",
      "padding?": "AgChartPaddingOptions",
      "background?": "{ visible?: boolean; fill?: string; }",
      "title?": "AgChartCaptionOptions",
      "subtitle?": "AgChartCaptionOptions",
      "tooltipClass?": "string",
      "tooltipTracking?": "boolean",
      "navigator?": "AgNavigatorOptions",
      "legend?": "AgChartLegendOptions",
      "listeners?": "{[key in string]: Function}",
      "theme?": "string | AgChartTheme"
    }
  },
  "AgPolarChartOptions": {
    "meta": { "typeParams": ["TAxisOptions", "TSeriesOptions"] },
    "type": {
      "type?": "'polar' | 'pie'",
      "axes?": "TAxisOptions",
      "series?": "TSeriesOptions",
      "container?": "HTMLElement",
      "data?": "any[]",
      "width?": "number",
      "height?": "number",
      "autoSize?": "boolean",
      "padding?": "AgChartPaddingOptions",
      "background?": "{ visible?: boolean; fill?: string; }",
      "title?": "AgChartCaptionOptions",
      "subtitle?": "AgChartCaptionOptions",
      "tooltipClass?": "string",
      "tooltipTracking?": "boolean",
      "navigator?": "AgNavigatorOptions",
      "legend?": "AgChartLegendOptions",
      "listeners?": "{[key in string]: Function}",
      "theme?": "string | AgChartTheme"
    }
  },
  "AgChartOptions": {
    "meta": { "isTypeAlias": true },
    "type": "AgCartesianChartOptions | AgPolarChartOptions"
  },
  "IAggFuncService": {
    "meta": {},
    "type": {
      "addAggFuncs(aggFuncs: { [key: string]: IAggFunc; })": "void",
      "addAggFunc(key: string, aggFunc: IAggFunc)": "void",
      "clear()": "void",
      "getDefaultAggFunc(column: Column)": "string | null",
      "getFuncNames(column: Column)": "string[]"
    }
  },
  "IAggregationStage": {
    "meta": {},
    "type": {
      "aggregateValues(values: any[], aggFuncOrString: string | IAggFunc)": "any"
    }
  },
  "ICellEditor": {
    "meta": {},
    "type": {
      "getValue()": "any",
      "isPopup?()": "boolean",
      "getPopupPosition?()": "string | undefined",
      "isCancelBeforeStart?()": "boolean",
      "isCancelAfterEnd?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void",
      "getFrameworkComponentInstance?()": "any"
    },
    "docs": {
      "getValue()": "/** Return the final value - called by the grid once after editing is complete */",
      "isPopup?()": "/** Gets called once after initialised. If you return true, the editor will\n * appear in a popup, so is not constrained to the boundaries of the cell.\n * This is great if you want to, for example, provide you own custom dropdown list\n * for selection. Default is false (ie if you don't provide the method). */",
      "getPopupPosition?()": "/** Gets called once, only if isPopup() returns true. Return \"over\" if the popup\n * should cover the cell, or \"under\" if it should be positioned below leaving the\n * cell value visible. If this method is not present, the default is \"over\". */",
      "isCancelBeforeStart?()": "/** Gets called once after initialised. If you return true, the editor will not be\n * used and the grid will continue editing. Use this to make a decision on editing\n * inside the init() function, eg maybe you want to only start editing if the user\n * hits a numeric key, but not a letter, if the editor is for numbers. */",
      "isCancelAfterEnd?()": "/** Gets called once after editing is complete. If your return true, then the new\n * value will not be used. The editing will have no impact on the record. Use this\n * if you do not want a new value from your gui, i.e. you want to cancel the editing. */",
      "focusIn?()": "/** If doing full line edit, then gets called when focus should be put into the editor */",
      "focusOut?()": "/** If doing full line edit, then gets called when focus is leaving the editor */",
      "getFrameworkComponentInstance?()": "/** If using a framework this returns the underlying component instance, so you can call\n * methods on it if you want. */"
    }
  },
  "ICellEditorParams": {
    "meta": {},
    "type": {
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any"
    },
    "docs": {
      "value": "/** Current value of the cell */",
      "keyPress": "/** Key code of key that started the edit, eg 'Enter' or 'Delete' - non-printable\n * characters appear here */",
      "charPress": "/** The string that started the edit, eg 'a' if letter 'a' was pressed, or 'A' if\n * shift + letter 'a' only printable characters appear here */",
      "column": "/** Grid column */",
      "colDef": "/** Column definition */",
      "node": "/** Row node for the cell */",
      "data": "/** Row data */",
      "rowIndex": "/** Editing row index */",
      "cellStartedEdit": "/** If doing full row edit, this is true if the cell is the one that started the edit\n * (eg it is the cell the use double clicked on, or pressed a key on etc). */",
      "context": "/** Context  as set on gridOptions.context */",
      "$scope": "/** AngularJS scope - null if not using AngularJS, this is legacy and not used if not */",
      "onKeyDown": "/** callback to tell grid a key was pressed - useful to pass control key events (tab,\n * arrows etc) back to grid - however you do */",
      "stopEditing": "/** Callback to tell grid to stop editing the current cell. pass 'false' to prevent\n * navigation moving to the next cell if grid property `enterMovesDownAfterEdit=true` */",
      "eGridCell": "/** A reference to the DOM element representing the grid cell that your component\n * will live inside. Useful if you want to add event listeners or classes at this level.\n * This is the DOM element that gets browser focus when selecting cells. */",
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "formatValue": "/** Utility function to format a value using the column's `colDef.valueFormatter` */"
    }
  },
  "ICellEditorComp": {
    "meta": {},
    "type": {
      "getValue()": "any",
      "isPopup?()": "boolean",
      "getPopupPosition?()": "string | undefined",
      "isCancelBeforeStart?()": "boolean",
      "isCancelAfterEnd?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void",
      "getFrameworkComponentInstance?()": "any",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void"
    },
    "docs": {
      "getValue()": "/** Return the final value - called by the grid once after editing is complete */",
      "isPopup?()": "/** Gets called once after initialised. If you return true, the editor will\n * appear in a popup, so is not constrained to the boundaries of the cell.\n * This is great if you want to, for example, provide you own custom dropdown list\n * for selection. Default is false (ie if you don't provide the method). */",
      "getPopupPosition?()": "/** Gets called once, only if isPopup() returns true. Return \"over\" if the popup\n * should cover the cell, or \"under\" if it should be positioned below leaving the\n * cell value visible. If this method is not present, the default is \"over\". */",
      "isCancelBeforeStart?()": "/** Gets called once after initialised. If you return true, the editor will not be\n * used and the grid will continue editing. Use this to make a decision on editing\n * inside the init() function, eg maybe you want to only start editing if the user\n * hits a numeric key, but not a letter, if the editor is for numbers. */",
      "isCancelAfterEnd?()": "/** Gets called once after editing is complete. If your return true, then the new\n * value will not be used. The editing will have no impact on the record. Use this\n * if you do not want a new value from your gui, i.e. you want to cancel the editing. */",
      "focusIn?()": "/** If doing full line edit, then gets called when focus should be put into the editor */",
      "focusOut?()": "/** If doing full line edit, then gets called when focus is leaving the editor */",
      "getFrameworkComponentInstance?()": "/** If using a framework this returns the underlying component instance, so you can call\n * methods on it if you want. */",
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: T)": "/** The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "ChartType": {
    "meta": { "isEnum": true },
    "type": [
      "Column = 'column'",
      "GroupedColumn = 'groupedColumn'",
      "StackedColumn = 'stackedColumn'",
      "NormalizedColumn = 'normalizedColumn'",
      "Bar = 'bar'",
      "GroupedBar = 'groupedBar'",
      "StackedBar = 'stackedBar'",
      "NormalizedBar = 'normalizedBar'",
      "Line = 'line'",
      "Scatter = 'scatter'",
      "Bubble = 'bubble'",
      "Pie = 'pie'",
      "Doughnut = 'doughnut'",
      "Area = 'area'",
      "StackedArea = 'stackedArea'",
      "NormalizedArea = 'normalizedArea'",
      "Histogram = 'histogram'"
    ],
    "docs": [
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null
    ]
  },
  "ChartMenuOptions": {
    "meta": { "isTypeAlias": true },
    "type": "'chartSettings' | 'chartData' | 'chartFormat' | 'chartLink' | 'chartUnlink' | 'chartDownload'"
  },
  "SeriesOptions": {
    "meta": {},
    "type": {
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "ChartTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "class?": "string",
      "tracking?": "boolean",
      "delay?": "number"
    }
  },
  "ChartOptions": {
    "meta": { "typeParams": ["T extends SeriesOptions"] },
    "type": {
      "document?": "Document",
      "seriesDefaults": "T",
      "width?": "number",
      "height?": "number",
      "padding": "PaddingOptions",
      "background": "BackgroundOptions",
      "title": "CaptionOptions",
      "subtitle": "CaptionOptions",
      "navigator": "NavigatorOptions",
      "legend": "LegendOptions",
      "tooltip?": "ChartTooltip",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "PaddingOptions": {
    "meta": {},
    "type": {
      "top": "number",
      "right": "number",
      "bottom": "number",
      "left": "number"
    }
  },
  "BackgroundOptions": {
    "meta": {},
    "type": { "fill": "string", "visible": "boolean" }
  },
  "FontOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "CaptionOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "text?": "string",
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "LegendOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "position": "LegendPosition",
      "spacing": "number",
      "item": "LegendItemOptions"
    }
  },
  "LegendPosition": {
    "meta": { "isEnum": true },
    "type": [
      "Top = 'top'",
      "Right = 'right'",
      "Bottom = 'bottom'",
      "Left = 'left'"
    ],
    "docs": [null, null, null, null]
  },
  "LegendItemOptions": {
    "meta": {},
    "type": {
      "label": "LegendLabelOptions",
      "marker": "LegendMarkerOptions",
      "paddingX": "number",
      "paddingY": "number"
    }
  },
  "LegendLabelOptions": {
    "meta": {},
    "type": {
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "NavigatorOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "height": "number",
      "min": "number",
      "max": "number",
      "mask": "NavigatorMaskOptions",
      "minHandle": "NavigatorHandleOptions",
      "maxHandle": "NavigatorHandleOptions"
    }
  },
  "NavigatorMaskOptions": {
    "meta": {},
    "type": {
      "fill": "string",
      "stroke": "string",
      "strokeWidth": "number",
      "fillOpacity": "number"
    }
  },
  "NavigatorHandleOptions": {
    "meta": {},
    "type": {
      "fill": "string",
      "stroke": "string",
      "strokeWidth": "number",
      "width": "number",
      "height": "number",
      "gripLineGap": "number",
      "gripLineLength": "number"
    }
  },
  "MarkerShape": {
    "meta": { "isTypeAlias": true },
    "type": "'circle' | 'cross' | 'diamond' | 'plus' | 'square' | 'triangle'"
  },
  "LegendMarkerOptions": {
    "meta": {},
    "type": {
      "shape": "MarkerShape",
      "size": "number",
      "padding": "number",
      "strokeWidth": "number"
    }
  },
  "CartesianChartOptions": {
    "meta": { "typeParams": ["T extends SeriesOptions"] },
    "type": {
      "xAxis": "AxisOptions",
      "yAxis": "AxisOptions",
      "navigator": "NavigatorOptions",
      "document?": "Document",
      "seriesDefaults": "T",
      "width?": "number",
      "height?": "number",
      "padding": "PaddingOptions",
      "background": "BackgroundOptions",
      "title": "CaptionOptions",
      "subtitle": "CaptionOptions",
      "legend": "LegendOptions",
      "tooltip?": "ChartTooltip",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "PolarChartOptions": {
    "meta": { "typeParams": ["T extends SeriesOptions"] },
    "type": {
      "document?": "Document",
      "seriesDefaults": "T",
      "width?": "number",
      "height?": "number",
      "padding": "PaddingOptions",
      "background": "BackgroundOptions",
      "title": "CaptionOptions",
      "subtitle": "CaptionOptions",
      "navigator": "NavigatorOptions",
      "legend": "LegendOptions",
      "tooltip?": "ChartTooltip",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "AxisOptions": {
    "meta": {},
    "type": {
      "type?": "AxisType",
      "title": "CaptionOptions",
      "line": "AxisLineOptions",
      "tick": "AxisTickOptions",
      "label": "AxisLabelOptions",
      "gridStyle": "GridStyle[]"
    }
  },
  "AxisType": {
    "meta": { "isTypeAlias": true },
    "type": "'number' | 'category' | 'time'"
  },
  "AxisLineOptions": {
    "meta": {},
    "type": { "width": "number", "color": "string" }
  },
  "AxisTickOptions": {
    "meta": {},
    "type": { "width": "number", "size": "number", "color": "string" }
  },
  "AxisLabelFormatterParams": {
    "meta": {},
    "type": {
      "value": "any",
      "index": "number",
      "fractionDigits?": "number",
      "formatter?": "(x: any) => string"
    }
  },
  "AxisLabelOptions": {
    "meta": {},
    "type": {
      "padding": "number",
      "rotation": "number",
      "format?": "string",
      "formatter?": "(params: AxisLabelFormatterParams) => string",
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "GridStyle": {
    "meta": {},
    "type": { "stroke": "string", "lineDash?": "number[]" }
  },
  "HighlightOptions": {
    "meta": {},
    "type": {
      "fill": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "series?": "{ enabled?: boolean; dimOpacity?: number; strokeWidth?: number; }"
    }
  },
  "FillOptions": {
    "meta": {},
    "type": { "colors": "string[]", "opacity": "number" }
  },
  "StrokeOptions": {
    "meta": {},
    "type": { "colors": "string[]", "opacity": "number", "width": "number" }
  },
  "DropShadowOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "color": "string",
      "xOffset": "number",
      "yOffset": "number",
      "blur": "number"
    }
  },
  "SeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "TooltipRendererResult": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "content?": "string",
      "title?": "string",
      "color?": "string",
      "backgroundColor?": "string",
      "opacity?": "number"
    },
    "docs": {
      "enabled?": "/** Set to false to disable individual tooltip. */",
      "content?": "/** The content to display in each tooltip. */",
      "title?": "/** The title of the tooltip. */",
      "color?": "/** The CSS color for the title text. */",
      "backgroundColor?": "/** The CSS color for the background of the tooltip title. */",
      "opacity?": "/** The opacity of the background for the tooltip title. */"
    }
  },
  "TooltipOptions": {
    "meta": { "typeParams": ["TParams"] },
    "type": {
      "enabled": "boolean",
      "renderer?": "(params: TParams) => string | TooltipRendererResult"
    }
  },
  "TooltipRendererParams": {
    "meta": {},
    "type": {
      "context?": "any",
      "datum": "any",
      "xValue": "any",
      "yValue": "any"
    },
    "docs": {
      "context?": "/** The grid context, includes row data, giving access to data from other columns in the same row. */",
      "datum": "/** The raw datum associated with the point. */",
      "xValue": "/** The X value of the data point. */",
      "yValue": "/** The Y value of the data point. */"
    }
  },
  "CartesianTooltipRendererParams": {
    "meta": {},
    "type": {
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string",
      "context?": "any",
      "datum": "any"
    },
    "docs": {
      "context?": "/** The grid context, includes row data, giving access to data from other columns in the same row. */",
      "datum": "/** The raw datum associated with the point. */",
      "xValue": "/** The X value of the data point. */",
      "yValue": "/** The Y value of the data point. */"
    }
  },
  "BarSeriesOptions": {
    "meta": {},
    "type": {
      "shadow": "DropShadowOptions",
      "label": "BarSeriesLabelOptions",
      "tooltip": "TooltipOptions<BarTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number",
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "HistogramSeriesOptions": {
    "meta": {},
    "type": {
      "binCount?": "number",
      "shadow": "DropShadowOptions",
      "label": "BarSeriesLabelOptions",
      "tooltip": "TooltipOptions<BarTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number",
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "BarSeriesLabelOptions": {
    "meta": {},
    "type": {
      "formatter?": "(params: { value: number; }) => string",
      "enabled": "boolean",
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "BarTooltipRendererParams": {
    "meta": {},
    "type": {
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string",
      "context?": "any",
      "datum": "any"
    },
    "docs": {
      "context?": "/** The grid context, includes row data, giving access to data from other columns in the same row. */",
      "datum": "/** The raw datum associated with the point. */",
      "xValue": "/** The X value of the data point. */",
      "yValue": "/** The Y value of the data point. */"
    }
  },
  "LineSeriesOptions": {
    "meta": {},
    "type": {
      "marker": "MarkerOptions",
      "label": "LineSeriesLabelOptions",
      "tooltip": "TooltipOptions<LineTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number",
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "LineSeriesLabelOptions": {
    "meta": {},
    "type": {
      "formatter?": "(params: { value: any; }) => string",
      "enabled": "boolean",
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "MarkerOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "shape": "MarkerShape",
      "size": "number",
      "strokeWidth": "number",
      "formatter?": "Function"
    }
  },
  "LineTooltipRendererParams": {
    "meta": {},
    "type": {
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string",
      "context?": "any",
      "datum": "any"
    },
    "docs": {
      "context?": "/** The grid context, includes row data, giving access to data from other columns in the same row. */",
      "datum": "/** The raw datum associated with the point. */",
      "xValue": "/** The X value of the data point. */",
      "yValue": "/** The Y value of the data point. */"
    }
  },
  "ScatterSeriesLabelOptions": {
    "meta": {},
    "type": {
      "enabled": "boolean",
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "ScatterSeriesOptions": {
    "meta": {},
    "type": {
      "marker": "ScatterMarkerOptions",
      "label": "ScatterSeriesLabelOptions",
      "tooltip": "TooltipOptions<ScatterTooltipRendererParams>",
      "paired": "boolean",
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "ScatterMarkerOptions": {
    "meta": {},
    "type": {
      "maxSize?": "number",
      "enabled": "boolean",
      "shape": "MarkerShape",
      "size": "number",
      "strokeWidth": "number",
      "formatter?": "Function"
    }
  },
  "ScatterTooltipRendererParams": {
    "meta": {},
    "type": {
      "sizeKey?": "string",
      "sizeName?": "string",
      "labelKey?": "string",
      "labelName?": "string",
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string",
      "context?": "any",
      "datum": "any"
    },
    "docs": {
      "context?": "/** The grid context, includes row data, giving access to data from other columns in the same row. */",
      "datum": "/** The raw datum associated with the point. */",
      "xValue": "/** The X value of the data point. */",
      "yValue": "/** The Y value of the data point. */"
    }
  },
  "AreaSeriesLabelOptions": {
    "meta": {},
    "type": {
      "formatter?": "(params: { value: any; }) => string",
      "enabled": "boolean",
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "AreaSeriesOptions": {
    "meta": {},
    "type": {
      "marker": "MarkerOptions",
      "label": "AreaSeriesLabelOptions",
      "shadow": "DropShadowOptions",
      "tooltip": "TooltipOptions<AreaTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number",
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "AreaTooltipRendererParams": {
    "meta": {},
    "type": {
      "xKey": "string",
      "xValue": "any",
      "xName": "string",
      "yKey": "string",
      "yValue": "any",
      "yName": "string",
      "context?": "any",
      "datum": "any"
    },
    "docs": {
      "context?": "/** The grid context, includes row data, giving access to data from other columns in the same row. */",
      "datum": "/** The raw datum associated with the point. */",
      "xValue": "/** The X value of the data point. */",
      "yValue": "/** The Y value of the data point. */"
    }
  },
  "PieTitleOptions": {
    "meta": {},
    "type": {
      "showInLegend?": "boolean",
      "enabled": "boolean",
      "text?": "string",
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "PieSeriesOptions": {
    "meta": {},
    "type": {
      "title": "PieTitleOptions",
      "label": "PieSeriesLabelOptions",
      "callout": "PieSeriesCalloutOptions",
      "shadow": "DropShadowOptions",
      "tooltip": "TooltipOptions<PieTooltipRendererParams>",
      "lineDash": "number[]",
      "lineDashOffset": "number",
      "fill": "FillOptions",
      "stroke": "StrokeOptions",
      "highlightStyle": "HighlightOptions",
      "listeners?": "{[key in string]: Function}"
    }
  },
  "PieSeriesLabelOptions": {
    "meta": {},
    "type": {
      "minAngle": "number",
      "offset": "number",
      "enabled": "boolean",
      "fontStyle": "FontStyle",
      "fontWeight": "FontWeight",
      "fontSize": "number",
      "fontFamily": "string",
      "color": "string"
    }
  },
  "PieSeriesCalloutOptions": {
    "meta": {},
    "type": {
      "length": "number",
      "strokeWidth": "number",
      "colors": "string[]"
    }
  },
  "PieTooltipRendererParams": {
    "meta": {},
    "type": {
      "angleKey": "string",
      "angleValue": "any",
      "angleName?": "string",
      "labelKey?": "string",
      "labelName?": "string",
      "context?": "any",
      "datum": "any",
      "xValue": "any",
      "yValue": "any"
    },
    "docs": {
      "context?": "/** The grid context, includes row data, giving access to data from other columns in the same row. */",
      "datum": "/** The raw datum associated with the point. */",
      "xValue": "/** The X value of the data point. */",
      "yValue": "/** The Y value of the data point. */"
    }
  },
  "GetChartImageDataUrlParams": {
    "meta": {},
    "type": { "chartId": "string", "fileFormat?": "string" },
    "docs": {
      "chartId": "/** The id of the created chart. */",
      "fileFormat?": "/** A string indicating the image format.\n * The default format type is `image/png`.\n * Options: `image/png`, `image/jpeg` */"
    }
  },
  "ChartModelType": {
    "meta": { "isTypeAlias": true },
    "type": "'range' | 'pivot'"
  },
  "ChartModel": {
    "meta": {},
    "type": {
      "modelType": "ChartModelType",
      "chartId": "string",
      "chartType": "ChartType",
      "cellRange": "CellRangeParams",
      "chartThemeName?": "string",
      "chartOptions": "ChartOptions<any>",
      "suppressChartRanges?": "boolean",
      "aggFunc?": "string | IAggFunc",
      "unlinkChart?": "boolean"
    }
  },
  "IChartService": {
    "meta": {},
    "type": {
      "getChartModels()": "ChartModel[]",
      "getChartRef(chartId: string)": "ChartRef | undefined",
      "createRangeChart(params: CreateRangeChartParams)": "ChartRef | undefined",
      "createCrossFilterChart(params: CreateCrossFilterChartParams)": "ChartRef | undefined",
      "createChartFromCurrentRange(chartType: ChartType)": "ChartRef | undefined",
      "createPivotChart(params: CreatePivotChartParams)": "ChartRef | undefined",
      "restoreChart(model: ChartModel, chartContainer?: HTMLElement)": "ChartRef | undefined",
      "getChartImageDataURL(params: GetChartImageDataUrlParams)": "string | undefined"
    }
  },
  "ClientSideRowModelSteps": {
    "meta": { "isEnum": true },
    "type": [
      "EVERYTHING = 'group'",
      "FILTER = 'filter'",
      "SORT = 'sort'",
      "MAP = 'map'",
      "AGGREGATE = 'aggregate'",
      "PIVOT = 'pivot'",
      "NOTHING = 'nothing'"
    ],
    "docs": [null, null, null, null, null, null, null]
  },
  "IClientSideRowModel": {
    "meta": {},
    "type": {
      "onRowGroupOpened()": "void",
      "updateRowData(rowDataTran: RowDataTransaction, rowNodeOrder?: { [id: string]: number; } | null)": "RowNodeTransaction | null",
      "setRowData(rowData: any[])": "void",
      "refreshModel(params: RefreshModelParams)": "void",
      "expandOrCollapseAll(expand: boolean)": "void",
      "forEachLeafNode(callback: (node: RowNode, index: number) => void)": "void",
      "forEachNode(callback: (node: RowNode, index: number) => void)": "void",
      "forEachNodeAfterFilter(callback: (node: RowNode, index: number) => void)": "void",
      "forEachNodeAfterFilterAndSort(callback: (node: RowNode, index: number) => void)": "void",
      "resetRowHeights()": "void",
      "onRowHeightChanged()": "void",
      "batchUpdateRowData(rowDataTransaction: RowDataTransaction, callback?: (res: RowNodeTransaction) => void)": "void",
      "flushAsyncTransactions()": "void",
      "getRootNode()": "RowNode",
      "doAggregate(changedPath?: ChangedPath)": "void",
      "getTopLevelNodes()": "RowNode[] | null",
      "forEachPivotNode(callback: (node: RowNode, index: number) => void)": "void",
      "ensureRowsAtPixel(rowNode: RowNode[], pixel: number, increment: number)": "boolean",
      "highlightRowAtPixel(rowNode: RowNode | null, pixel?: number)": "void",
      "getHighlightPosition(pixel: number, rowNode?: RowNode)": "RowHighlightPosition",
      "getLastHighlightedRowNode()": "RowNode | null",
      "getRow(index: number)": "RowNode | undefined",
      "getRowNode(id: string)": "RowNode | undefined",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "void",
      "getType()": "string",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void"
    },
    "docs": {
      "getRow(index: number)": "/** Returns the rowNode at the given index. */",
      "getRowNode(id: string)": "/** Returns the rowNode for given id. */",
      "getRowCount()": "/** This is legacy, not used by AG Grid, but keeping for backward compatibility */",
      "getRowIndexAtPixel(pixel: number)": "/** Returns the row index at the given pixel */",
      "isRowPresent(rowNode: RowNode)": "/** Returns true if the provided rowNode is in the list of rows to render */",
      "getRowBounds(index: number)": "/** Returns row top and bottom for a given row */",
      "isEmpty()": "/** Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\n * out, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\n * don't show that overlay if the rows are just filtered out. */",
      "isRowsToRender()": "/** Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\n * uses to know if there are rows to render or not. */",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "/** Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\n * then no rows should be returned */",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "/** Iterate through each node. What this does depends on the model type. For clientSide, goes through\n * all nodes. For serverSide, goes through what's loaded in memory. */",
      "getType()": "/** The base class returns the type. We use this instead of 'instanceof' as the client might provide\n * their own implementation of the models in the future. */",
      "isLastRowIndexKnown()": "/** It tells us if this row model knows about the last row that it can produce. This is used by the\n * PaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\n * not shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel. */",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "/** Used by CSRM only - is makes sure there are now estimated row heights within the range. */",
      "start()": "/** Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\n * from gridOptions, the other row models will start calling their datasources. */"
    }
  },
  "RefreshModelParams": {
    "meta": {},
    "type": {
      "step": "ClientSideRowModelSteps",
      "groupState?": "any",
      "keepRenderedRows?": "boolean",
      "animate?": "boolean",
      "keepEditingRows?": "boolean",
      "rowNodeTransactions?": "RowNodeTransaction[]",
      "rowNodeOrder?": "{ [id: string]: number; }",
      "newData?": "boolean",
      "afterColumnsChanged?": "boolean"
    }
  },
  "IClipboardService": {
    "meta": {},
    "type": {
      "pasteFromClipboard()": "void",
      "copyToClipboard(includeHeader?: boolean)": "void",
      "copySelectedRowsToClipboard(includeHeader?: boolean, columnKeys?: (string | Column)[])": "void",
      "copySelectedRangeToClipboard(includeHeader?: boolean)": "void",
      "copyRangeDown()": "void"
    }
  },
  "IColumnToolPanel": {
    "meta": {},
    "type": {
      "expandColumnGroups(groupIds?: string[])": "void",
      "collapseColumnGroups(groupIds?: string[])": "void",
      "setColumnLayout(colDefs: (ColDef | ColGroupDef)[])": "void",
      "syncLayoutWithGrid()": "void",
      "setPivotModeSectionVisible(visible: boolean)": "void",
      "setRowGroupsSectionVisible(visible: boolean)": "void",
      "setValuesSectionVisible(visible: boolean)": "void",
      "setPivotSectionVisible(visible: boolean)": "void"
    }
  },
  "ColumnVO": {
    "meta": {},
    "type": {
      "id": "string",
      "displayName": "string",
      "field?": "string",
      "aggFunc?": "string"
    }
  },
  "IComponent": {
    "meta": {
      "typeParams": ["T"],
      "doc": "/** This is for User Components only, do not implement this for internal components. */"
    },
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: T)": "/** The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "IContextMenuFactory": {
    "meta": {},
    "type": {
      "onContextMenu(mouseEvent: MouseEvent | null, touchEvent: TouchEvent | null, rowNode: RowNode | null, column: Column | null, value: any, anchorToElement: HTMLElement)": "void",
      "hideActiveMenu()": "void"
    }
  },
  "ICsvCreator": {
    "meta": {},
    "type": {
      "getDataAsCsv(params?: CsvExportParams)": "string",
      "exportDataAsCsv(params?: CsvExportParams)": "string"
    }
  },
  "IDatasource": {
    "meta": {
      "doc": "/** Datasource used by both PaginationController and InfiniteRowModel */"
    },
    "type": {
      "rowCount?": "number",
      "getRows(params: IGetRowsParams)": "void",
      "destroy?()": "void"
    },
    "docs": {
      "rowCount?": "/** If you know up front how many rows are in the dataset, set it here. Otherwise leave blank. */",
      "getRows(params: IGetRowsParams)": "/** Callback the grid calls that you implement to fetch rows from the server. */",
      "destroy?()": "/** Optional destroy method, if your datasource has state it needs to clean up. */"
    }
  },
  "IGetRowsParams": {
    "meta": { "doc": "/** Params for the above IDatasource.getRows() */" },
    "type": {
      "startRow": "number",
      "endRow": "number",
      "successCallback(rowsThisBlock: any[], lastRow?: number)": "void",
      "failCallback()": "void",
      "sortModel": "any",
      "filterModel": "any",
      "context": "any"
    },
    "docs": {
      "startRow": "/** The first row index to get. */",
      "endRow": "/** The first row index to NOT get. */",
      "successCallback(rowsThisBlock: any[], lastRow?: number)": "/** Callback to call for the result when successful. */",
      "failCallback()": "/** Callback to call when the request fails. */",
      "sortModel": "/** If doing server side sorting, contains the sort model */",
      "filterModel": "/** If doing server side filtering, contains the filter model */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "IEventEmitter": {
    "meta": {},
    "type": {
      "addEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void",
      "removeEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void"
    }
  },
  "ExcelStyle": {
    "meta": {},
    "type": {
      "id": "string",
      "alignment?": "ExcelAlignment",
      "borders?": "ExcelBorders",
      "dataType?": "ExcelDataType",
      "font?": "ExcelFont",
      "interior?": "ExcelInterior",
      "numberFormat?": "ExcelNumberFormat",
      "protection?": "ExcelProtection",
      "name?": "string"
    },
    "docs": { "name?": "/** @deprecated Legacy property\n */" }
  },
  "ExcelAlignment": {
    "meta": {},
    "type": {
      "horizontal?": "'Automatic' | 'Left' | 'Center' | 'Right' | 'Fill' | 'Justify' | 'CenterAcrossSelection' | 'Distributed' | 'JustifyDistributed'",
      "indent?": "number",
      "readingOrder?": "'RightToLeft' | 'LeftToRight' | 'Context'",
      "rotate?": "number",
      "shrinkToFit?": "boolean",
      "vertical?": "'Automatic' | 'Top' | 'Bottom' | 'Center' | 'Justify' | 'Distributed' | 'JustifyDistributed'",
      "wrapText?": "boolean",
      "verticalText?": "boolean"
    },
    "docs": { "verticalText?": "/** @deprecated Legacy property\n */" }
  },
  "ExcelBorders": {
    "meta": {},
    "type": {
      "borderBottom?": "ExcelBorder",
      "borderLeft?": "ExcelBorder",
      "borderRight?": "ExcelBorder",
      "borderTop?": "ExcelBorder"
    }
  },
  "ExcelBorder": {
    "meta": {},
    "type": {
      "color?": "string",
      "lineStyle?": "'None' | 'Continuous' | 'Dash' | 'Dot' | 'DashDot' | 'DashDotDot' | 'SlantDashDot' | 'Double'",
      "weight?": "0 | 1 | 2 | 3"
    }
  },
  "ExcelFont": {
    "meta": {},
    "type": {
      "bold?": "boolean",
      "color?": "string",
      "family?": "string",
      "fontName?": "string",
      "italic?": "boolean",
      "outline?": "boolean",
      "shadow?": "boolean",
      "size?": "number",
      "strikeThrough?": "boolean",
      "underline?": "'Single' | 'Double'",
      "verticalAlign?": "'Superscript' | 'Subscript'",
      "charSet?": "number"
    },
    "docs": { "charSet?": "/** @deprecated Legacy property\n */" }
  },
  "ExcelInterior": {
    "meta": {},
    "type": {
      "color": "string",
      "pattern": "'None' | 'Solid' | 'Gray75' | 'Gray50' | 'Gray25' | 'Gray125' | 'Gray0625' | 'HorzStripe' | 'VertStripe' | 'ReverseDiagStripe' | 'DiagStripe' | 'DiagCross' | 'ThickDiagCross' | 'ThinHorzStripe' | 'ThinVertStripe' | 'ThinReverseDiagStripe' | 'ThinDiagStripe' | 'ThinHorzCross' | 'ThinDiagCross'",
      "patternColor": "string"
    }
  },
  "ExcelNumberFormat": { "meta": {}, "type": { "format": "string" } },
  "ExcelProtection": {
    "meta": {},
    "type": { "protected": "boolean", "hideFormula": "boolean" }
  },
  "ExcelWorksheet": {
    "meta": {},
    "type": { "name": "string", "table": "ExcelTable" }
  },
  "ExcelTable": {
    "meta": {},
    "type": { "columns": "ExcelColumn[]", "rows": "ExcelRow[]" }
  },
  "ExcelColumn": {
    "meta": {},
    "type": {
      "min?": "number",
      "max?": "number",
      "width?": "number",
      "s?": "number",
      "hidden?": "boolean",
      "bestFit?": "boolean"
    }
  },
  "ExcelRow": {
    "meta": {},
    "type": {
      "index?": "number",
      "collapsed?": "boolean",
      "hidden?": "boolean",
      "height?": "number",
      "outlineLevel?": "number",
      "s?": "number",
      "cells": "ExcelCell[]"
    }
  },
  "ExcelCell": {
    "meta": {},
    "type": {
      "ref?": "string",
      "styleId?": "string",
      "data": "ExcelData",
      "mergeAcross?": "number"
    }
  },
  "ExcelImage": {
    "meta": {},
    "type": {
      "id": "string",
      "base64": "string",
      "imageType": "'jpg' | 'png' | 'gif'",
      "altText?": "string",
      "fitCell?": "boolean",
      "transparency?": "number",
      "rotation?": "number",
      "recolor?": "'Grayscale' | 'Sepia' | 'Washout'",
      "width?": "number",
      "height?": "number",
      "position?": "{ row?: number; rowSpan?: number; column?: number; colSpan?: number; offsetX?: number; offsetY?: number; }"
    }
  },
  "ExcelDataType": {
    "meta": { "isTypeAlias": true },
    "type": "'String' | 'Formula' | 'Number' | 'Boolean' | 'DateTime' | 'Error'"
  },
  "ExcelOOXMLDataType": {
    "meta": { "isTypeAlias": true },
    "type": "'str' | 's' | 'f' | 'inlineStr' | 'n' | 'b' | 'd' | 'e' | 'empty'"
  },
  "ExcelData": {
    "meta": {},
    "type": {
      "type": "ExcelDataType | ExcelOOXMLDataType",
      "value": "string | null"
    }
  },
  "ExcelRelationship": {
    "meta": {},
    "type": { "Id": "string", "Type": "string", "Target": "string" }
  },
  "ExcelContentType": {
    "meta": {},
    "type": {
      "name": "'Default' | 'Override'",
      "ContentType": "string",
      "Extension?": "string",
      "PartName?": "string"
    }
  },
  "ExcelXMLTemplate": {
    "meta": {},
    "type": {
      "getTemplate(styleProperties?: ExcelStyle | ExcelWorksheet | ExcelColumn | ExcelRow | ExcelCell)": "XmlElement"
    }
  },
  "ExcelOOXMLTemplate": {
    "meta": {},
    "type": {
      "getTemplate(config?: any, idx?: number, currentSheet?: number)": "XmlElement",
      "convertType?(type: string)": "string"
    }
  },
  "ExcelFactoryMode": {
    "meta": { "isEnum": true },
    "type": ["SINGLE_SHEET", "MULTI_SHEET"],
    "docs": [null, null]
  },
  "ColumnWidthCallbackParams": {
    "meta": {},
    "type": { "column": "Column | null", "index": "number" }
  },
  "RowHeightCallbackParams": { "meta": {}, "type": { "rowIndex": "number" } },
  "ExcelExportParams": {
    "meta": {},
    "type": {
      "author?": "string",
      "autoConvertFormulas?": "boolean",
      "columnWidth?": "number | ((params: ColumnWidthCallbackParams) => number)",
      "exportMode?": "'xlsx' | 'xml'",
      "fontSize?": "number",
      "headerRowHeight?": "number | ((params: RowHeightCallbackParams) => number)",
      "rowHeight?": "number | ((params: RowHeightCallbackParams) => number)",
      "sheetName?": "string",
      "margins?": "ExcelSheetMargin",
      "pageSetup?": "ExcelSheetPageSetup",
      "headerFooterConfig?": "ExcelHeaderFooterConfig",
      "suppressTextAsCDATA?": "boolean",
      "addImageToCell?": "(rowIndex: number, column: Column, value: string) => { image: ExcelImage; value?: string; } | undefined",
      "prependContent?": "ExcelCell[][]",
      "appendContent?": "ExcelCell[][]",
      "customHeader?": "ExcelCell[][]",
      "customFooter?": "ExcelCell[][]",
      "getCustomContentBelowRow?": "(params: ProcessRowGroupForExportParams) => ExcelCell[][] | undefined",
      "allColumns?": "boolean",
      "columnKeys?": "(string | Column)[]",
      "fileName?": "string",
      "onlySelected?": "boolean",
      "onlySelectedAllPages?": "boolean",
      "skipColumnGroupHeaders?": "boolean",
      "skipColumnHeaders?": "boolean",
      "skipRowGroups?": "boolean",
      "skipPinnedTop?": "boolean",
      "skipPinnedBottom?": "boolean",
      "shouldRowBeSkipped?(params: ShouldRowBeSkippedParams)": "boolean",
      "processCellCallback?(params: ProcessCellForExportParams)": "string",
      "processHeaderCallback?(params: ProcessHeaderForExportParams)": "string",
      "processGroupHeaderCallback?(params: ProcessGroupHeaderForExportParams)": "string",
      "processRowGroupCallback?(params: ProcessRowGroupForExportParams)": "string",
      "columnGroups?": "boolean",
      "skipGroups?": "boolean",
      "skipHeader?": "boolean"
    },
    "docs": {
      "addImageToCell?": "/** Use to export an image for the gridCell in question. */",
      "customHeader?": "/** @deprecated Use prependContent\n */",
      "customFooter?": "/** @deprecated Use appendContent\n */",
      "columnGroups?": "/** @deprecated\n */",
      "skipGroups?": "/** @deprecated\n */",
      "skipHeader?": "/** @deprecated\n */"
    }
  },
  "ExcelExportMultipleSheetParams": {
    "meta": {},
    "type": {
      "author?": "string",
      "data": "string[]",
      "fileName?": "string",
      "fontSize?": "number"
    }
  },
  "ExcelHeaderFooterConfig": {
    "meta": {},
    "type": {
      "all?": "ExcelHeaderFooter",
      "first?": "ExcelHeaderFooter",
      "even?": "ExcelHeaderFooter"
    }
  },
  "ExcelHeaderFooter": {
    "meta": {},
    "type": {
      "header?": "ExcelHeaderFooterContent[]",
      "footer?": "ExcelHeaderFooterContent[]"
    }
  },
  "ExcelHeaderFooterContent": {
    "meta": {},
    "type": {
      "value": "string",
      "position?": "'Left' | 'Center' | 'Right'",
      "font?": "ExcelFont"
    }
  },
  "IExcelCreator": {
    "meta": {},
    "type": {
      "exportDataAsExcel(params?: ExcelExportParams)": "void",
      "getDataAsExcel(params?: ExcelExportParams)": "Blob | string | undefined",
      "getSheetDataForExcel(params?: ExcelExportParams)": "string",
      "getMultipleSheetsAsExcel(params: ExcelExportMultipleSheetParams)": "Blob | undefined",
      "exportMultipleSheetsAsExcel(params: ExcelExportMultipleSheetParams)": "void",
      "setFactoryMode(factoryMode: ExcelFactoryMode, exportMode: 'xml' | 'xlsx')": "void",
      "getFactoryMode(exportMode: 'xml' | 'xlsx')": "ExcelFactoryMode"
    },
    "docs": {
      "setFactoryMode(factoryMode: ExcelFactoryMode, exportMode: 'xml' | 'xlsx')": "/** private methods */"
    }
  },
  "ExcelSheetMargin": {
    "meta": {},
    "type": {
      "top?": "number",
      "right?": "number",
      "bottom?": "number",
      "left?": "number",
      "header?": "number",
      "footer?": "number"
    }
  },
  "ExcelSheetPageSetup": {
    "meta": {},
    "type": {
      "orientation?": "'Portrait' | 'Landscape'",
      "pageSize?": "'Letter' | 'Letter Small' | 'Tabloid' | 'Ledger' | 'Legal' | 'Statement' | 'Executive' | 'A3' | 'A4' | 'A4 Small' | 'A5' | 'A6' | 'B4' | 'B5' | 'Folio' | 'Envelope' | 'Envelope DL' | 'Envelope C5' | 'Envelope B5' | 'Envelope C3' | 'Envelope C4' | 'Envelope C6' | 'Envelope Monarch' | 'Japanese Postcard' | 'Japanese Double Postcard'"
    }
  },
  "IFilterType": {
    "meta": { "isTypeAlias": true },
    "type": "string | { new (): IFilterComp; } | boolean"
  },
  "IFloatingFilterType": {
    "meta": { "isTypeAlias": true },
    "type": "string | { new (): IFloatingFilterComp; }"
  },
  "IFilterDef": {
    "meta": {},
    "type": {
      "filter?": "IFilterType",
      "filterFramework?": "any",
      "filterParams?": "any",
      "floatingFilterComponent?": "IFloatingFilterType",
      "floatingFilterComponentParams?": "any",
      "floatingFilterComponentFramework?": "any"
    },
    "docs": {
      "filter?": "/** One of the built in filter names: [set, number, text, date], or a filter function */",
      "filterParams?": "/** The filter params are specific to each filter! */",
      "floatingFilterComponent?": "/** The custom component to be used for rendering the floating filter.\n * If none is specified the default AG Grid is used. */"
    }
  },
  "IFilter": {
    "meta": {},
    "type": {
      "isFilterActive()": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getFrameworkComponentInstance?()": "any",
      "getModelAsString?(model: any)": "string"
    },
    "docs": {
      "isFilterActive()": "/** This is used to let the grid know if the filter is active or not */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/** The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n * filter fails, then the row will be excluded from the final set. The method is provided a\n * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n * (the data object that you provided to the grid for that row). */",
      "getModel()": "/** Gets the filter state for storing */",
      "setModel(model: any)": "/** Restores the filter state. */",
      "onNewRowsLoaded?()": "/** Gets called when new rows are inserted into the grid. If the filter needs to change its\n * state after rows are loaded, it can do it here. For example the set filters uses this\n * to update the list of available values to select from (e.g. 'Ireland', 'UK' etc for\n * Country filter). To get the list of available values from within this method from the\n * Client Side Row Model, use gridApi.forEachLeafNode(callback). */",
      "onAnyFilterChanged?()": "/** Called whenever any filter is changed. */",
      "getFrameworkComponentInstance?()": "/** If using React or Angular 2, returns the underlying component instance, so you can call methods\n * on it if you want. */",
      "getModelAsString?(model: any)": "/** Optional method used by AG Grid when rendering floating filters and there isn't a floating filter\n * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n * filter. */"
    }
  },
  "ProvidedFilterModel": { "meta": {}, "type": { "filterType?": "string" } },
  "IFilterComp": {
    "meta": {},
    "type": {
      "isFilterActive()": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getFrameworkComponentInstance?()": "any",
      "getModelAsString?(model: any)": "string",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: IFilterParams)": "AgPromise<void> | void"
    },
    "docs": {
      "isFilterActive()": "/** This is used to let the grid know if the filter is active or not */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/** The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n * filter fails, then the row will be excluded from the final set. The method is provided a\n * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n * (the data object that you provided to the grid for that row). */",
      "getModel()": "/** Gets the filter state for storing */",
      "setModel(model: any)": "/** Restores the filter state. */",
      "onNewRowsLoaded?()": "/** Gets called when new rows are inserted into the grid. If the filter needs to change its\n * state after rows are loaded, it can do it here. For example the set filters uses this\n * to update the list of available values to select from (e.g. 'Ireland', 'UK' etc for\n * Country filter). To get the list of available values from within this method from the\n * Client Side Row Model, use gridApi.forEachLeafNode(callback). */",
      "onAnyFilterChanged?()": "/** Called whenever any filter is changed. */",
      "getFrameworkComponentInstance?()": "/** If using React or Angular 2, returns the underlying component instance, so you can call methods\n * on it if you want. */",
      "getModelAsString?(model: any)": "/** Optional method used by AG Grid when rendering floating filters and there isn't a floating filter\n * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n * filter. */",
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: IFilterParams)": "/** The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "IDoesFilterPassParams": {
    "meta": {},
    "type": { "node": "RowNode", "data": "any" },
    "docs": {
      "node": "/** The row node in question. */",
      "data": "/** The data part of the row node in question. */"
    }
  },
  "IFilterOptionDef": {
    "meta": {},
    "type": {
      "displayKey": "string",
      "displayName": "string",
      "test": "(filterValue: any, cellValue: any) => boolean",
      "hideFilterInput?": "boolean"
    },
    "docs": {
      "displayKey": "/** A unique key that does not clash with the built-in filter keys. */",
      "displayName": "/** Display name for the filter. Can be replaced by a locale-specific value using a `localeTextFunc`. */",
      "test": "/** Custom filter logic that returns a boolean based on the `filterValue` and `cellValue`. */",
      "hideFilterInput?": "/** Optionally hide the filter input field. */"
    }
  },
  "IFilterParams": {
    "meta": {},
    "type": {
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "column": "/** The column this filter is for. */",
      "colDef": "/** The column definition for the column. */",
      "rowModel": "/** The row model, helpful for looking up data values if needed.\n * If the filter needs to know which rows are\n * a) in the table,\n * b) currently visible (i.e. not already filtered),\n * c) which groups,\n * d) what order - all of this can be read from the rowModel. */",
      "filterChangedCallback": "/** A function callback to be called when the filter changes. The\n * grid will then respond by filtering the grid data. The callback\n * takes one optional parameter which, if included, will get merged\n * to the FilterChangedEvent object (useful for passing additional\n * information to anyone listening to this event, however such extra\n * attributes are not used by the grid). */",
      "filterModifiedCallback": "/** A function callback, to be optionally called, when the filter UI changes.\n * The grid will respond with emitting a FilterModifiedEvent.\n * Apart from emitting the event, the grid takes no further action. */",
      "valueGetter": "/** A function callback for the filter to get cell values from the row data.\n * Call with a node to be given the value for that filter's column for that node.\n * The callback takes care of selecting the right column definition and deciding whether to use valueGetter or field etc.\n * This is useful in, for example, creating an Excel style filter,\n * where the filter needs to lookup available values to allow the user to select from. */",
      "doesRowPassOtherFilter": "/** A function callback, call with a node to be told whether the node passes all filters except the current filter.\n * This is useful if you want to only present to the user values that this filter can filter given the status of the other filters.\n * The set filter uses this to remove from the list,\n * items that are no longer available due to the state of other filters (like Excel type filtering). */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "Filter": {
    "meta": { "doc": "/** @deprecated , use iFilter\n */" },
    "type": {
      "isFilterActive()": "boolean",
      "doesFilterPass(params: IDoesFilterPassParams)": "boolean",
      "getModel()": "any",
      "setModel(model: any)": "void | AgPromise<void>",
      "onNewRowsLoaded?()": "void",
      "onAnyFilterChanged?()": "void",
      "getFrameworkComponentInstance?()": "any",
      "getModelAsString?(model: any)": "string"
    },
    "docs": {
      "isFilterActive()": "/** This is used to let the grid know if the filter is active or not */",
      "doesFilterPass(params: IDoesFilterPassParams)": "/** The grid will ask each active filter, in turn, whether each row in the grid passes. If any\n * filter fails, then the row will be excluded from the final set. The method is provided a\n * params object with attributes node (the rodNode the grid creates that wraps the data) and data\n * (the data object that you provided to the grid for that row). */",
      "getModel()": "/** Gets the filter state for storing */",
      "setModel(model: any)": "/** Restores the filter state. */",
      "onNewRowsLoaded?()": "/** Gets called when new rows are inserted into the grid. If the filter needs to change its\n * state after rows are loaded, it can do it here. For example the set filters uses this\n * to update the list of available values to select from (e.g. 'Ireland', 'UK' etc for\n * Country filter). To get the list of available values from within this method from the\n * Client Side Row Model, use gridApi.forEachLeafNode(callback). */",
      "onAnyFilterChanged?()": "/** Called whenever any filter is changed. */",
      "getFrameworkComponentInstance?()": "/** If using React or Angular 2, returns the underlying component instance, so you can call methods\n * on it if you want. */",
      "getModelAsString?(model: any)": "/** Optional method used by AG Grid when rendering floating filters and there isn't a floating filter\n * associated for this filter, this will happen if you create a custom filter and NOT a custom floating\n * filter. */"
    }
  },
  "IFiltersToolPanel": {
    "meta": {},
    "type": {
      "setFilterLayout(colDefs: ColDef[])": "void",
      "expandFilterGroups(groupIds?: string[])": "void",
      "collapseFilterGroups(groupIds?: string[])": "void",
      "expandFilters(colIds?: string[])": "void",
      "collapseFilters(colIds?: string[])": "void",
      "syncLayoutWithGrid()": "void"
    }
  },
  "IFrameworkOverrides": {
    "meta": {},
    "type": {
      "setTimeout(action: any, timeout?: any)": "void",
      "setInterval(action: any, interval?: any)": "AgPromise<number>",
      "addEventListener(element: HTMLElement, type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions)": "void",
      "dispatchEvent(eventType: string, listener: () => {}, global: boolean)": "void",
      "frameworkComponent(name: string)": "any"
    },
    "docs": {
      "setTimeout(action: any, timeout?: any)": "/** Because Angular 2+ uses Zones, you should not use setTimeout or setInterval (as it'll keep angular constantly doing dirty checks etc\n * So to get around this, we allow the framework to specify how to execute setTimeout. The default is to just call the browser setTimeout(). */",
      "addEventListener(element: HTMLElement, type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions)": "/** Again because Angular uses Zones, we allow adding some events outside of Zone JS so that we do not kick off\n * the Angular change detection. We do this for some events ONLY, and not all events, just events that get fired\n * a lot (eg mouse move), but we need to make sure in AG Grid that we do NOT call any grid callbacks while processing\n * these events, as we will be outside of ZoneJS and hence Angular2 Change Detection won't work. However it's fine\n * for our code to result in AG Grid events (and Angular application action on these) as these go through\n * Event Emitter's.\n * \n * This was done by Niall and Sean. The problematic events are mouseover, mouseout, mouseenter and mouseleave. */"
    }
  },
  "IImmutableService": {
    "meta": {},
    "type": {
      "createTransactionForRowData(data: any[])": "([RowDataTransaction, { [id: string]: number; } | null]) | undefined"
    }
  },
  "IInfiniteRowModel": {
    "meta": {},
    "type": {
      "setDatasource(datasource: IDatasource | undefined)": "void",
      "refreshCache()": "void",
      "purgeCache()": "void",
      "setRowCount(rowCount: number, maxRowFound?: boolean)": "void",
      "getRow(index: number)": "RowNode | undefined",
      "getRowNode(id: string)": "RowNode | undefined",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "void",
      "getType()": "string",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void"
    },
    "docs": {
      "getRow(index: number)": "/** Returns the rowNode at the given index. */",
      "getRowNode(id: string)": "/** Returns the rowNode for given id. */",
      "getRowCount()": "/** This is legacy, not used by AG Grid, but keeping for backward compatibility */",
      "getRowIndexAtPixel(pixel: number)": "/** Returns the row index at the given pixel */",
      "isRowPresent(rowNode: RowNode)": "/** Returns true if the provided rowNode is in the list of rows to render */",
      "getRowBounds(index: number)": "/** Returns row top and bottom for a given row */",
      "isEmpty()": "/** Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\n * out, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\n * don't show that overlay if the rows are just filtered out. */",
      "isRowsToRender()": "/** Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\n * uses to know if there are rows to render or not. */",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "/** Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\n * then no rows should be returned */",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "/** Iterate through each node. What this does depends on the model type. For clientSide, goes through\n * all nodes. For serverSide, goes through what's loaded in memory. */",
      "getType()": "/** The base class returns the type. We use this instead of 'instanceof' as the client might provide\n * their own implementation of the models in the future. */",
      "isLastRowIndexKnown()": "/** It tells us if this row model knows about the last row that it can produce. This is used by the\n * PaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\n * not shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel. */",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "/** Used by CSRM only - is makes sure there are now estimated row heights within the range. */",
      "start()": "/** Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\n * from gridOptions, the other row models will start calling their datasources. */"
    }
  },
  "IMenu": { "meta": {}, "type": {} },
  "IMenuFactory": {
    "meta": {},
    "type": {
      "showMenuAfterButtonClick(column: Column | null, eventSource: HTMLElement, containerType: ContainerType, defaultTab?: string, restrictToTabs?: string[])": "void",
      "showMenuAfterMouseEvent(column: Column, mouseEvent: MouseEvent | Touch, defaultTab?: string, restrictToTabs?: string[])": "void",
      "isMenuEnabled(column: Column)": "boolean",
      "hideActiveMenu()": "void"
    }
  },
  "Module": {
    "meta": {},
    "type": {
      "moduleName": "string",
      "beans?": "any[]",
      "agStackComponents?": "ComponentMeta[]",
      "controllers?": "ControllerMeta[]",
      "userComponents?": "{ componentName: string; componentClass: any; }[]",
      "rowModels?": "{ [name: string]: { new (): IRowModel; }; }",
      "dependantModules?": "Module[]"
    }
  },
  "IPopupComponent": {
    "meta": { "typeParams": ["T"] },
    "type": {
      "isPopup?()": "boolean",
      "focusIn?()": "void",
      "focusOut?()": "void",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: T)": "AgPromise<void> | void"
    },
    "docs": {
      "isPopup?()": "/** Gets called once after initialised. If you return true, the component will appear in a popup, and it will be\n * constrained to the boundaries of the popupParent. This is great if you want to, for example, provide you own\n * custom dropdown list for selection. Default is false (ie if you don't provide the method). */",
      "focusIn?()": "/** Called when focus is within the component */",
      "focusOut?()": "/** Called when focus is leaving the component */",
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: T)": "/** The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "IRangeService": {
    "meta": {},
    "type": {
      "isEmpty()": "boolean",
      "removeAllCellRanges()": "void",
      "getCellRangeCount(cell: CellPosition)": "number",
      "isCellInAnyRange(cell: CellPosition)": "boolean",
      "isCellInSpecificRange(cell: CellPosition, range: CellRange)": "boolean",
      "isBottomRightCell(cellRange: CellRange, cell: CellPosition)": "boolean",
      "isContiguousRange(cellRange: CellRange)": "boolean",
      "isMoreThanOneCell()": "boolean",
      "onDragStart(mouseEvent: MouseEvent)": "void",
      "onDragStop()": "void",
      "onDragging(mouseEvent: MouseEvent)": "void",
      "getCellRanges()": "CellRange[]",
      "setRangeToCell(cell: CellPosition, appendRange?: boolean)": "void",
      "setCellRange(params: CellRangeParams)": "void",
      "addCellRange(params: CellRangeParams)": "void",
      "extendLatestRangeInDirection(key: number)": "CellPosition | undefined",
      "extendLatestRangeToCell(cell: CellPosition)": "void",
      "updateRangeEnd(cellRange: CellRange, cellPosition: CellPosition, silent?: boolean)": "void",
      "getRangeStartRow(cellRange: CellRange)": "RowPosition",
      "getRangeEndRow(cellRange: CellRange)": "RowPosition",
      "createCellRangeFromCellRangeParams(params: CellRangeParams)": "CellRange | undefined",
      "setCellRanges(cellRanges: CellRange[])": "void"
    }
  },
  "ISelectionHandle": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "getType()": "SelectionHandleType",
      "refresh(cellCtrl: CellCtrl)": "void"
    }
  },
  "ISelectionHandleFactory": {
    "meta": {},
    "type": {
      "createSelectionHandle(type: SelectionHandleType)": "ISelectionHandle"
    }
  },
  "SelectionHandleType": {
    "meta": { "isEnum": true },
    "type": ["FILL", "RANGE"],
    "docs": [null, null]
  },
  "CellRangeType": {
    "meta": { "isEnum": true },
    "type": ["VALUE", "DIMENSION"],
    "docs": [null, null]
  },
  "CellRange": {
    "meta": {},
    "type": {
      "id?": "string",
      "type?": "CellRangeType",
      "startRow?": "RowPosition",
      "endRow?": "RowPosition",
      "columns": "Column[]",
      "startColumn": "Column"
    },
    "docs": {
      "startRow?": "/** The start row of the range */",
      "endRow?": "/** The end row of the range */",
      "columns": "/** The columns in the range */",
      "startColumn": "/** The start column for the range */"
    }
  },
  "CellRangeParams": {
    "meta": {},
    "type": {
      "rowStartIndex": "number | null",
      "rowStartPinned?": "string | null",
      "rowEndIndex": "number | null",
      "rowEndPinned?": "string | null",
      "columnStart?": "string | Column",
      "columnEnd?": "string | Column",
      "columns?": "(string | Column)[]"
    },
    "docs": {
      "rowStartIndex": "/** Start row index */",
      "rowStartPinned?": "/** Pinned state of start row. Either 'top', 'bottom' or null */",
      "rowEndIndex": "/** End row index */",
      "rowEndPinned?": "/** Pinned state of end row. Either 'top', 'bottom' or null */",
      "columnStart?": "/** Starting column for range */",
      "columnEnd?": "/** End column for range */",
      "columns?": "/** Specify Columns to include instead of using `columnStart` and `columnEnd` */"
    }
  },
  "RangeSelection": {
    "meta": { "doc": "/** @deprecated\n */" },
    "type": {
      "start": "CellPosition",
      "end": "CellPosition",
      "columns": "Column[] | null"
    }
  },
  "AddRangeSelectionParams": {
    "meta": { "doc": "/** @deprecated\n */" },
    "type": {
      "rowStart": "number",
      "floatingStart": "string",
      "rowEnd": "number",
      "floatingEnd": "string",
      "columnStart": "string | Column",
      "columnEnd": "string | Column"
    }
  },
  "CellValue": {
    "meta": { "isTypeAlias": true },
    "type": "object | string | number"
  },
  "IRichCellEditorParams": {
    "meta": {},
    "type": {
      "values": "CellValue[]",
      "cellHeight": "number",
      "cellRenderer": "{ new (): ICellRendererComp; } | ICellRendererFunc | string",
      "searchDebounceDelay?": "number",
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any"
    },
    "docs": {
      "value": "/** Current value of the cell */",
      "keyPress": "/** Key code of key that started the edit, eg 'Enter' or 'Delete' - non-printable\n * characters appear here */",
      "charPress": "/** The string that started the edit, eg 'a' if letter 'a' was pressed, or 'A' if\n * shift + letter 'a' only printable characters appear here */",
      "column": "/** Grid column */",
      "colDef": "/** Column definition */",
      "node": "/** Row node for the cell */",
      "data": "/** Row data */",
      "rowIndex": "/** Editing row index */",
      "cellStartedEdit": "/** If doing full row edit, this is true if the cell is the one that started the edit\n * (eg it is the cell the use double clicked on, or pressed a key on etc). */",
      "context": "/** Context  as set on gridOptions.context */",
      "$scope": "/** AngularJS scope - null if not using AngularJS, this is legacy and not used if not */",
      "onKeyDown": "/** callback to tell grid a key was pressed - useful to pass control key events (tab,\n * arrows etc) back to grid - however you do */",
      "stopEditing": "/** Callback to tell grid to stop editing the current cell. pass 'false' to prevent\n * navigation moving to the next cell if grid property `enterMovesDownAfterEdit=true` */",
      "eGridCell": "/** A reference to the DOM element representing the grid cell that your component\n * will live inside. Useful if you want to add event listeners or classes at this level.\n * This is the DOM element that gets browser focus when selecting cells. */",
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "formatValue": "/** Utility function to format a value using the column's `colDef.valueFormatter` */"
    }
  },
  "RowBounds": {
    "meta": {},
    "type": { "rowTop": "number", "rowHeight": "number", "rowIndex?": "number" }
  },
  "IRowModel": {
    "meta": {},
    "type": {
      "getRow(index: number)": "RowNode | undefined",
      "getRowNode(id: string)": "RowNode | undefined",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "void",
      "getType()": "string",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void"
    },
    "docs": {
      "getRow(index: number)": "/** Returns the rowNode at the given index. */",
      "getRowNode(id: string)": "/** Returns the rowNode for given id. */",
      "getRowCount()": "/** This is legacy, not used by AG Grid, but keeping for backward compatibility */",
      "getRowIndexAtPixel(pixel: number)": "/** Returns the row index at the given pixel */",
      "isRowPresent(rowNode: RowNode)": "/** Returns true if the provided rowNode is in the list of rows to render */",
      "getRowBounds(index: number)": "/** Returns row top and bottom for a given row */",
      "isEmpty()": "/** Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\n * out, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\n * don't show that overlay if the rows are just filtered out. */",
      "isRowsToRender()": "/** Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\n * uses to know if there are rows to render or not. */",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "/** Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\n * then no rows should be returned */",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "/** Iterate through each node. What this does depends on the model type. For clientSide, goes through\n * all nodes. For serverSide, goes through what's loaded in memory. */",
      "getType()": "/** The base class returns the type. We use this instead of 'instanceof' as the client might provide\n * their own implementation of the models in the future. */",
      "isLastRowIndexKnown()": "/** It tells us if this row model knows about the last row that it can produce. This is used by the\n * PaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\n * not shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel. */",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "/** Used by CSRM only - is makes sure there are now estimated row heights within the range. */",
      "start()": "/** Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\n * from gridOptions, the other row models will start calling their datasources. */"
    }
  },
  "IRowNodeBlock": {
    "meta": {},
    "type": {
      "getDisplayIndexStart()": "number",
      "getDisplayIndexEnd()": "number",
      "getLastAccessed()": "number",
      "getState()": "string",
      "isAnyNodeOpen(rowCount: number)": "boolean",
      "getBlockNumber()": "number",
      "forEachNodeDeep(callback: (rowNode: RowNode, index: number) => void, sequence: NumberSequence, rowCount: number)": "void",
      "forEachNodeShallow(callback: (rowNode: RowNode, index: number) => void, sequence: NumberSequence, rowCount: number)": "void",
      "load()": "void",
      "addEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void",
      "removeEventListener(eventType: string, listener: EventListener, async?: boolean, options?: AddEventListenerOptions)": "void"
    }
  },
  "StageExecuteParams": {
    "meta": {},
    "type": {
      "rowNode": "RowNode",
      "rowNodeTransaction?": "RowNodeTransaction | null",
      "rowNodeTransactions?": "RowNodeTransaction[] | null",
      "rowNodeOrder?": "{ [id: string]: number; }",
      "changedPath?": "ChangedPath",
      "afterColumnsChanged?": "boolean"
    }
  },
  "IRowNodeStage": {
    "meta": {},
    "type": { "execute(params: StageExecuteParams)": "any" }
  },
  "IServerSideGetRowsRequest": {
    "meta": {},
    "type": {
      "startRow": "number | undefined",
      "endRow": "number | undefined",
      "rowGroupCols": "ColumnVO[]",
      "valueCols": "ColumnVO[]",
      "pivotCols": "ColumnVO[]",
      "pivotMode": "boolean",
      "groupKeys": "string[]",
      "filterModel": "any",
      "sortModel": "any"
    },
    "docs": {
      "startRow": "/** First row requested or undefined for all rows. */",
      "endRow": "/** Last row requested or undefined for all rows. */",
      "rowGroupCols": "/** Columns that are currently row grouped. */",
      "valueCols": "/** Columns that have aggregations on them. */",
      "pivotCols": "/** Columns that have pivot on them. */",
      "pivotMode": "/** Defines if pivot mode is on or off. */",
      "groupKeys": "/** What groups the user is viewing. */",
      "filterModel": "/** If filtering, what the filter model is. */",
      "sortModel": "/** If sorting, what the sort model is. */"
    }
  },
  "IServerSideGetRowsParams": {
    "meta": {},
    "type": {
      "request": "IServerSideGetRowsRequest",
      "parentNode": "RowNode",
      "successCallback(rowsThisPage: any[], lastRow: number)": "void",
      "success(params: LoadSuccessParams)": "void",
      "failCallback()": "void",
      "fail()": "void",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "request": "/** Details for the request. A simple object that can be converted to JSON. */",
      "parentNode": "/** The parent row node. The RootNode (level -1) if request is top level.\n * This is NOT part fo the request as it cannot be serialised to JSON (a rowNode has methods). */",
      "successCallback(rowsThisPage: any[], lastRow: number)": "/** @deprecated Use `success` method instead and return result as a `LoadSuccessParams` object.\n */",
      "success(params: LoadSuccessParams)": "/** Success callback, pass the rows back to the grid that were requested. */",
      "failCallback()": "/** @deprecated Use `fail` instead.\n */",
      "fail()": "/** Fail callback, tell the grid the call failed so it can adjust it's state. */"
    }
  },
  "IServerSideDatasource": {
    "meta": {},
    "type": {
      "getRows(params: IServerSideGetRowsParams)": "void",
      "destroy?()": "void"
    },
    "docs": {
      "getRows(params: IServerSideGetRowsParams)": "/** Grid calls `getRows` when it requires more rows as specified in the params. \n * Params object contains callbacks for responding to the request. */",
      "destroy?()": "/** Optional method, if your datasource has state it needs to clean up. */"
    }
  },
  "IServerSideRowModel": {
    "meta": {},
    "type": {
      "refreshStore(params: RefreshStoreParams)": "void",
      "onRowHeightChanged()": "void",
      "getStoreState()": "ServerSideStoreState[]",
      "retryLoads()": "void",
      "expandAll(value: boolean)": "void",
      "setDatasource(datasource: IServerSideDatasource)": "void",
      "forEachNodeAfterFilterAndSort(callback: (node: RowNode, index: number) => void)": "void",
      "getRow(index: number)": "RowNode | undefined",
      "getRowNode(id: string)": "RowNode | undefined",
      "getRowCount()": "number",
      "getTopLevelRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "getRowIndexAtPixel(pixel: number)": "number",
      "isRowPresent(rowNode: RowNode)": "boolean",
      "getRowBounds(index: number)": "RowBounds | null",
      "isEmpty()": "boolean",
      "isRowsToRender()": "boolean",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "RowNode[]",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "void",
      "getType()": "string",
      "isLastRowIndexKnown()": "boolean",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "boolean",
      "start()": "void"
    },
    "docs": {
      "getRow(index: number)": "/** Returns the rowNode at the given index. */",
      "getRowNode(id: string)": "/** Returns the rowNode for given id. */",
      "getRowCount()": "/** This is legacy, not used by AG Grid, but keeping for backward compatibility */",
      "getRowIndexAtPixel(pixel: number)": "/** Returns the row index at the given pixel */",
      "isRowPresent(rowNode: RowNode)": "/** Returns true if the provided rowNode is in the list of rows to render */",
      "getRowBounds(index: number)": "/** Returns row top and bottom for a given row */",
      "isEmpty()": "/** Returns true if this model has no rows, regardless of model filter. EG if rows present, but filtered\n * out, this still returns false. If it returns true, then the grid shows the 'no rows' overlay - but we\n * don't show that overlay if the rows are just filtered out. */",
      "isRowsToRender()": "/** Returns true if no rows (either no rows at all, or the rows are filtered out). This is what the grid\n * uses to know if there are rows to render or not. */",
      "getNodesInRangeForSelection(first: RowNode, last: RowNode | null)": "/** Returns all rows in range that should be selected. If there is a gap in range (non ClientSideRowModel) then\n * then no rows should be returned */",
      "forEachNode(callback: (rowNode: RowNode, index: number) => void)": "/** Iterate through each node. What this does depends on the model type. For clientSide, goes through\n * all nodes. For serverSide, goes through what's loaded in memory. */",
      "getType()": "/** The base class returns the type. We use this instead of 'instanceof' as the client might provide\n * their own implementation of the models in the future. */",
      "isLastRowIndexKnown()": "/** It tells us if this row model knows about the last row that it can produce. This is used by the\n * PaginationPanel, if last row is not found, then the 'last' button is disabled and the last page is\n * not shown. This is always true for ClientSideRowModel. It toggles for InfiniteRowModel. */",
      "ensureRowHeightsValid(startPixel: number, endPixel: number, startLimitIndex: number, endLimitIndex: number)": "/** Used by CSRM only - is makes sure there are now estimated row heights within the range. */",
      "start()": "/** Gets called after grid is initialised. What happens depends on row model. Client Side will take rowData\n * from gridOptions, the other row models will start calling their datasources. */"
    }
  },
  "IServerSideTransactionManager": {
    "meta": {},
    "type": {
      "applyTransaction(transaction: ServerSideTransaction)": "ServerSideTransactionResult | undefined",
      "applyTransactionAsync(transaction: ServerSideTransaction, callback?: (res: ServerSideTransactionResult) => void)": "void",
      "flushAsyncTransactions()": "void"
    }
  },
  "RefreshStoreParams": {
    "meta": {},
    "type": { "route?": "string[]", "purge?": "boolean" },
    "docs": {
      "route?": "/** List of group keys, pointing to the store to refresh.\n * For example, to purge the cache two levels down under 'Canada'and then '2002', pass in the string array ['Canada','2002'].\n * If no route is passed, or an empty array, then the top level store is refreshed. */",
      "purge?": "/** If true, then all rows at the level getting refreshed are immediately destroyed and 'loading' rows will appear.\n * If false, then all rows at the level getting refreshed are kept until rows are loaded (no 'loading' rows appear). */"
    }
  },
  "IServerSideStore": {
    "meta": {},
    "type": {
      "clearDisplayIndexes()": "void",
      "getDisplayIndexEnd()": "number | undefined",
      "isDisplayIndexInStore(displayIndex: number)": "boolean",
      "setDisplayIndexes(displayIndexSeq: NumberSequence, nextRowTop: { value: number; })": "void",
      "forEachNodeDeep(callback: (rowNode: RowNode, index: number) => void, sequence?: NumberSequence)": "void",
      "forEachNodeDeepAfterFilterAndSort(callback: (rowNode: RowNode, index: number) => void, sequence?: NumberSequence)": "void",
      "retryLoads()": "void",
      "getRowUsingDisplayIndex(displayRowIndex: number, dontCreateBlock?: boolean)": "RowNode | undefined",
      "getRowBounds(index: number)": "RowBounds | null",
      "isPixelInRange(pixel: number)": "boolean",
      "getRowIndexAtPixel(pixel: number)": "number | null",
      "getChildStore(keys: string[])": "IServerSideStore | null",
      "refreshAfterSort(params: StoreRefreshAfterParams)": "void",
      "refreshAfterFilter(params: StoreRefreshAfterParams)": "void",
      "applyTransaction(transaction: ServerSideTransaction)": "ServerSideTransactionResult",
      "refreshStore(purge: boolean)": "void",
      "getRowCount()": "number",
      "getTopLevelRowDisplayedIndex(topLevelIndex: number)": "number",
      "isLastRowIndexKnown()": "boolean",
      "getRowNodesInRange(firstInRange: RowNode, lastInRange: RowNode)": "RowNode[]",
      "addStoreStates(result: ServerSideStoreState[])": "void"
    }
  },
  "StoreRefreshAfterParams": {
    "meta": {},
    "type": {
      "valueColChanged": "boolean",
      "secondaryColChanged": "boolean",
      "alwaysReset": "boolean",
      "changedColumns": "string[]"
    }
  },
  "ServerSideStoreState": {
    "meta": {},
    "type": {
      "type": "ServerSideStoreType",
      "route": "string[]",
      "rowCount": "number",
      "lastRowIndexKnown?": "boolean",
      "info?": "any",
      "maxBlocksInCache?": "number",
      "cacheBlockSize?": "number"
    },
    "docs": {
      "type": "/** Store type, `partial` or `full` */",
      "route": "/** The route that identifies this store. */",
      "rowCount": "/** How many rows the store has. This includes 'loading rows'. */",
      "lastRowIndexKnown?": "/** Partial store only.\n * Whether the last row index is know. */",
      "info?": "/** Any extra info provided to the store, when data was loaded. */",
      "maxBlocksInCache?": "/** Partial store only.\n * Max blocks allowed in the store. */",
      "cacheBlockSize?": "/** Partial store only.\n * The size (number of rows) of each block. */"
    }
  },
  "SetFilterValuesFuncParams": {
    "meta": {},
    "type": { "success": "(values: string[]) => void", "colDef": "ColDef" },
    "docs": {
      "success": "/** The function to call with the values to load into the filter once they are ready. */",
      "colDef": "/** The column definition from which the set filter is invoked. */"
    }
  },
  "SetFilterValuesFunc": {
    "meta": { "isTypeAlias": true },
    "type": "(params: SetFilterValuesFuncParams) => void"
  },
  "SetFilterValues": {
    "meta": { "isTypeAlias": true },
    "type": "SetFilterValuesFunc | any[]"
  },
  "ISetFilterParams": {
    "meta": {},
    "type": {
      "values?": "SetFilterValues",
      "refreshValuesOnOpen?": "boolean",
      "cellHeight?": "number",
      "suppressSorting?": "boolean",
      "cellRenderer?": "{ new (): ICellRendererComp; } | ICellRendererFunc | string",
      "suppressMiniFilter?": "boolean",
      "applyMiniFilterWhileTyping?": "boolean",
      "suppressSelectAll?": "boolean",
      "defaultToNothingSelected?": "boolean",
      "comparator?": "(a: any, b: any) => number",
      "textFormatter?": "(from: string) => string",
      "valueFormatter?": "(params: ValueFormatterParams) => string",
      "showTooltips?": "boolean",
      "excelMode?": "'mac' | 'windows'",
      "suppressRemoveEntries?": "boolean",
      "suppressSyncValuesAfterDataChange?": "boolean",
      "selectAllOnMiniFilter?": "boolean",
      "syncValuesLikeExcel?": "boolean",
      "clearButton?": "boolean",
      "resetButton?": "boolean",
      "applyButton?": "boolean",
      "buttons?": "FilterButtonType[]",
      "closeOnApply?": "boolean",
      "newRowsAction?": "string",
      "debounceMs?": "number",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "values?": "/** The values to display in the Filter List.\n * If this is not set, the filter will takes its values from what is loaded in the table. */",
      "refreshValuesOnOpen?": "/** Refresh the values every time the Set filter is opened. */",
      "cellHeight?": "/** The height of values in the Filter List in pixels. */",
      "suppressSorting?": "/** If `true`, the Set Filter values will not be sorted.\n * Use this if you are providing your own values and don't want them sorted as you are providing in the order you want.\n * Default: false */",
      "cellRenderer?": "/** Similar to the Cell Renderer for the grid.\n * Setting it separately here allows for the value to be rendered differently in the filter. */",
      "suppressMiniFilter?": "/** Set to `true` to hide the Mini Filter.\n * Default: `false` */",
      "applyMiniFilterWhileTyping?": "/** Set to `true` to apply the Set Filter immediately when the user is typing in the Mini Filter.\n * Default: `false` */",
      "suppressSelectAll?": "/** Set to `true` to remove the Select All checkbox.\n * Default: `false` */",
      "defaultToNothingSelected?": "/** By default, when the Set Filter is opened all values are shown selected. Set this to `true` to instead show all values as de-selected by default. */",
      "comparator?": "/** Comparator for sorting.\n * If not provided, the Column Definition comparator is used.\n * If Column Definition comparator is also not provided, the default (grid provided) comparator is used. */",
      "textFormatter?": "/** If specified, this formats the text before applying the Mini Filter compare logic, useful for instance to substitute accented characters. */",
      "showTooltips?": "/** If `true`, hovering over a value in the Set Filter will show a tooltip containing the full, untruncated value.\n * Default: `false` */",
      "excelMode?": "/** Changes the behaviour of the Set Filter to match that of Excel's AutoFilter. */",
      "suppressRemoveEntries?": "/** @deprecated\n */",
      "suppressSyncValuesAfterDataChange?": "/** @deprecated\n */",
      "selectAllOnMiniFilter?": "/** @deprecated\n */",
      "syncValuesLikeExcel?": "/** @deprecated\n */",
      "clearButton?": "/** @deprecated\n */",
      "resetButton?": "/** @deprecated\n */",
      "applyButton?": "/** @deprecated\n */",
      "newRowsAction?": "/** @deprecated\n */",
      "column": "/** The column this filter is for. */",
      "colDef": "/** The column definition for the column. */",
      "rowModel": "/** The row model, helpful for looking up data values if needed.\n * If the filter needs to know which rows are\n * a) in the table,\n * b) currently visible (i.e. not already filtered),\n * c) which groups,\n * d) what order - all of this can be read from the rowModel. */",
      "filterChangedCallback": "/** A function callback to be called when the filter changes. The\n * grid will then respond by filtering the grid data. The callback\n * takes one optional parameter which, if included, will get merged\n * to the FilterChangedEvent object (useful for passing additional\n * information to anyone listening to this event, however such extra\n * attributes are not used by the grid). */",
      "filterModifiedCallback": "/** A function callback, to be optionally called, when the filter UI changes.\n * The grid will respond with emitting a FilterModifiedEvent.\n * Apart from emitting the event, the grid takes no further action. */",
      "valueGetter": "/** A function callback for the filter to get cell values from the row data.\n * Call with a node to be given the value for that filter's column for that node.\n * The callback takes care of selecting the right column definition and deciding whether to use valueGetter or field etc.\n * This is useful in, for example, creating an Excel style filter,\n * where the filter needs to lookup available values to allow the user to select from. */",
      "doesRowPassOtherFilter": "/** A function callback, call with a node to be told whether the node passes all filters except the current filter.\n * This is useful if you want to only present to the user values that this filter can filter given the status of the other filters.\n * The set filter uses this to remove from the list,\n * items that are no longer available due to the state of other filters (like Excel type filtering). */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ISideBar": {
    "meta": {},
    "type": {
      "refresh()": "void",
      "setDisplayed(show: boolean)": "void",
      "setSideBarPosition(position?: 'left' | 'right')": "void",
      "isToolPanelShowing()": "boolean",
      "openToolPanel(key: string)": "void",
      "getToolPanelInstance(key: string)": "IToolPanel | undefined",
      "close()": "void",
      "openedItem()": "string | null",
      "isDisplayed()": "boolean"
    }
  },
  "ISparklineCellRendererParams": {
    "meta": {},
    "type": {
      "sparklineOptions?": "SparklineOptions",
      "value": "any",
      "valueFormatted": "any",
      "fullWidth?": "boolean",
      "pinned?": "string | null",
      "data": "any",
      "node": "RowNode",
      "rowIndex": "number",
      "colDef?": "ColDef",
      "column?": "Column",
      "$scope": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => any",
      "setValue?": "(value: any) => void",
      "formatValue?": "(value: any) => any",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string, suppressVisibilityChange?: boolean) => void"
    },
    "docs": {
      "value": "/** Value to be rendered. */",
      "valueFormatted": "/** Formatted value to be rendered. */",
      "fullWidth?": "/** True if this is a full width row. */",
      "pinned?": "/** Pinned state of the cell. */",
      "data": "/** The row's data. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The current index of the row (this changes after filter and sort). */",
      "colDef?": "/** The cell's column definition. */",
      "column?": "/** The cell's column. */",
      "$scope": "/** AngularJS scope - null if not using AngularJS, this is legacy and not used if not */",
      "context": "/** The context as provided on `gridOptions.context`. */",
      "eGridCell": "/** The grid's cell, a DOM div element. */",
      "eParentOfValue": "/** The parent DOM item for the cell renderer, same as eGridCell unless using checkbox selection. */",
      "getValue?": "/** Convenience function to get most recent up to date value. */",
      "setValue?": "/** Convenience function to set the value. */",
      "formatValue?": "/** Convenience function to format a value using the column's formatter. */",
      "refreshCell?": "/** Convenience function to refresh the cell. */",
      "registerRowDragger": "/** registerRowDragger:\n * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n * @param suppressVisibilityChange Set to `true` to prevent the Grid from hiding the Row Dragger when it is disabled.\n */"
    }
  },
  "SparklineOptions": {
    "meta": { "isTypeAlias": true },
    "type": "LineSparklineOptions | AreaSparklineOptions | ColumnSparklineOptions"
  },
  "BaseSparklineOptions": {
    "meta": {},
    "type": {
      "xKey?": "string",
      "yKey?": "string",
      "padding?": "Padding",
      "axis?": "SparklineAxisOptions",
      "highlightStyle?": "HighlightStyle",
      "tooltip?": "SparklineTooltip"
    },
    "docs": {
      "xKey?": "/** The key to use to retrieve x-values from the data. This will only be used if the data array contains objects with key-value pairs.\n * Default: `'x'` */",
      "yKey?": "/** The key to use to retrieve y-values from the data. This will only be used if the data array contains objects with key-value pairs.\n * Default: `'y'` */",
      "padding?": "/** Configuration for the padding in pixels shown around the sparklines. */",
      "axis?": "/** The options for the horizontal axis line in the sparklines. */",
      "highlightStyle?": "/** The configuration for the highlighting used when the markers are hovered over. */",
      "tooltip?": "/** Configuration for the tooltips. */"
    }
  },
  "LineSparklineOptions": {
    "meta": {},
    "type": {
      "type?": "'line'",
      "line?": "SparklineLine",
      "marker?": "SparklineMarker",
      "xKey?": "string",
      "yKey?": "string",
      "padding?": "Padding",
      "axis?": "SparklineAxisOptions",
      "highlightStyle?": "HighlightStyle",
      "tooltip?": "SparklineTooltip"
    },
    "docs": {
      "type?": "/** The type of sparklines to create, in this case it would be `'line'`. */",
      "line?": "/** The configuration for the line. */",
      "marker?": "/** The configuration for the marker styles. */",
      "xKey?": "/** The key to use to retrieve x-values from the data. This will only be used if the data array contains objects with key-value pairs.\n * Default: `'x'` */",
      "yKey?": "/** The key to use to retrieve y-values from the data. This will only be used if the data array contains objects with key-value pairs.\n * Default: `'y'` */",
      "padding?": "/** Configuration for the padding in pixels shown around the sparklines. */",
      "axis?": "/** The options for the horizontal axis line in the sparklines. */",
      "highlightStyle?": "/** The configuration for the highlighting used when the markers are hovered over. */",
      "tooltip?": "/** Configuration for the tooltips. */"
    }
  },
  "AreaSparklineOptions": {
    "meta": {},
    "type": {
      "type?": "'area'",
      "fill?": "string",
      "line?": "SparklineLine",
      "marker?": "SparklineMarker",
      "xKey?": "string",
      "yKey?": "string",
      "padding?": "Padding",
      "axis?": "SparklineAxisOptions",
      "highlightStyle?": "HighlightStyle",
      "tooltip?": "SparklineTooltip"
    },
    "docs": {
      "type?": "/** The type of sparklines to create, in this case it would be `'area'`. */",
      "fill?": "/** The CSS colour value for the fill of the area.\n * Default: `'rgba(124, 181, 236, 0.25)'` */",
      "line?": "/** The configuration for the line. */",
      "marker?": "/** The configuration for the marker styles. */",
      "xKey?": "/** The key to use to retrieve x-values from the data. This will only be used if the data array contains objects with key-value pairs.\n * Default: `'x'` */",
      "yKey?": "/** The key to use to retrieve y-values from the data. This will only be used if the data array contains objects with key-value pairs.\n * Default: `'y'` */",
      "padding?": "/** Configuration for the padding in pixels shown around the sparklines. */",
      "axis?": "/** The options for the horizontal axis line in the sparklines. */",
      "highlightStyle?": "/** The configuration for the highlighting used when the markers are hovered over. */",
      "tooltip?": "/** Configuration for the tooltips. */"
    }
  },
  "ColumnSparklineOptions": {
    "meta": {},
    "type": {
      "type?": "'column'",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "paddingInner?": "number",
      "paddingOuter?": "number",
      "formatter?": "SparklineColumnFormatter",
      "xKey?": "string",
      "yKey?": "string",
      "padding?": "Padding",
      "axis?": "SparklineAxisOptions",
      "highlightStyle?": "HighlightStyle",
      "tooltip?": "SparklineTooltip"
    },
    "docs": {
      "type?": "/** The type of sparklines to create, in this case it would be `'column'`. */",
      "fill?": "/** The CSS colour value for the fill of the columns.\n * Default: `'rgb(124, 181, 236)'` */",
      "stroke?": "/** The CSS colour value for the outline of the columns.\n * Default `'silver'` */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the columns.\n * Default: `0` */",
      "paddingInner?": "/** The size of the gap between the columns as a proportion, between 0 and 1. This value is a fraction of the “step”, which is the interval between the start of a band and the start of the next band.\n * Default: `0.5` */",
      "paddingOuter?": "/** The padding on the outside i.e. left and right of the first and last columns, to leave some room for the axis. In association with `paddingInner`, this value can be between 0 and 1.\n * Default: `0.2` */",
      "formatter?": "/** A callback function to return format styles of type ColumnFormat, based on the data represented by individual columns. */",
      "xKey?": "/** The key to use to retrieve x-values from the data. This will only be used if the data array contains objects with key-value pairs.\n * Default: `'x'` */",
      "yKey?": "/** The key to use to retrieve y-values from the data. This will only be used if the data array contains objects with key-value pairs.\n * Default: `'y'` */",
      "padding?": "/** Configuration for the padding in pixels shown around the sparklines. */",
      "axis?": "/** The options for the horizontal axis line in the sparklines. */",
      "highlightStyle?": "/** The configuration for the highlighting used when the markers are hovered over. */",
      "tooltip?": "/** Configuration for the tooltips. */"
    }
  },
  "Padding": {
    "meta": {},
    "type": {
      "top?": "number",
      "right?": "number",
      "bottom?": "number",
      "left?": "number"
    },
    "docs": {
      "top?": "/** The number of pixels of padding at the top of the sparkline area.\n * Default: `3` */",
      "right?": "/** The number of pixels of padding at the right of the sparkline area.\n * Default: `3` */",
      "bottom?": "/** The number of pixels of padding at the bottom of the sparkline area.\n * Default: `3` */",
      "left?": "/** The number of pixels of padding at the left of the sparkline area.\n * Default\" `3` */"
    }
  },
  "SparklineAxisOptions": {
    "meta": {},
    "type": {
      "type?": "AxisType",
      "stroke?": "string",
      "strokeWidth?": "number"
    },
    "docs": {
      "type?": "/** The type of x-axis used to plot the data.\n * Default: `'category'` */",
      "stroke?": "/** The CSS colour value for the outline of the horizontal axis line.\n * Default: `'rgb(204, 214, 235)'` */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the horizontal axis line.\n * Default: `1` */"
    }
  },
  "SparklineTooltip": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "container?": "HTMLElement",
      "renderer?": "SparklineTooltipRenderer"
    },
    "docs": {
      "enabled?": "/** Set to false to disable tooltips. */",
      "container?": "/** The element to place the tooltip into. This can be used to confine the tooltip to a specific area which may be outside of the sparkline grid cell. */",
      "renderer?": "/** A callback function used to create the content for the tooltips. This function should return an object or a HTML string used to render the tooltip. */"
    }
  },
  "SparklineTooltipRenderer": {
    "meta": { "isTypeAlias": true },
    "type": "(params: TooltipRendererParams) => TooltipRendererResult"
  },
  "SparklineLine": {
    "meta": {},
    "type": { "stroke?": "string", "strokeWidth?": "number" },
    "docs": {
      "stroke?": "/** The CSS colour value for the line.\n * Default: `'rgb(124, 181, 236)'` */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the line.\n * Default: `1` */"
    }
  },
  "HighlightStyle": {
    "meta": {},
    "type": {
      "size?": "number",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number"
    },
    "docs": {
      "size?": "/** The width in pixels of the markers when hovered over. This is only for the Line and Area sparklines as Column sparklines do not have markers.\n * Default: `6` */",
      "fill?": "/** The fill colour of the markers or columns when hovered over. Use `undefined` for no highlight fill.\n * Default: `'yellow'` */",
      "stroke?": "/** The CSS colour value for the outline of the markers or columns when hovered over. Use `undefined` for no highlight stroke.\n * Default: `'yellow'` */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the markers or columns when hovered over.\n * Default: `1` */"
    }
  },
  "SparklineColumnFormatter": {
    "meta": { "isTypeAlias": true },
    "type": "(params: ColumnFormatterParams) => ColumnFormat"
  },
  "ColumnFormatterParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "xValue": "any",
      "yValue": "any",
      "width": "number",
      "height": "number",
      "min?": "boolean",
      "max?": "boolean",
      "first?": "boolean",
      "last?": "boolean",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth": "number",
      "highlighted": "boolean"
    },
    "docs": {
      "datum": "/** The raw data associated with the specific marker. */",
      "xValue": "/** The x value of the marker. */",
      "yValue": "/** The y value of the marker. */",
      "width": "/** The width of the column in pixels. */",
      "height": "/** The width of the column in pixels. */",
      "min?": "/** Whether or not the marker is a minimum point. */",
      "max?": "/** Whether or not the marker is a maximum point. */",
      "first?": "/** Whether or not the marker represents the first data point. */",
      "last?": "/** Whether or not the marker represents the last data point. */",
      "fill?": "/** The CSS colour value for the fill of the individual marker. */",
      "stroke?": "/** The CSS colour value for the outline of the individual marker. */",
      "strokeWidth": "/** The thickness in pixels for the stroke of the individual marker. */",
      "highlighted": "/** Whether or not the marker is highlighted. */"
    }
  },
  "ColumnFormat": {
    "meta": {},
    "type": {
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number"
    },
    "docs": {
      "fill?": "/** The CSS colour value for the fill of the individual column. */",
      "stroke?": "/** The CSS colour value for the outline of the individual column. */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the individual column. */"
    }
  },
  "SparklineMarker": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "shape?": "string",
      "size?": "number",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number",
      "formatter?": "SparklineMarkerFormatter"
    },
    "docs": {
      "enabled?": "/** By default this is set to `true` whilst marker size is set to `0`, which means the markers are present but not visible.\n * Default: `true` */",
      "shape?": "/** The shape of the markers.\n * Default: `'circle'` */",
      "size?": "/** The width in pixels of markers. By default this is `0`, increase the size to make markers visible.\n * Default: `0` */",
      "fill?": "/** The CSS colour value for the fill of the markers.\n * Default: `'rgb(124, 181, 236)'` */",
      "stroke?": "/** The CSS colour value for the outline of the markers.\n * Default: `'rgb(124, 181, 236)'` */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the markers.\n * Default: `1` */",
      "formatter?": "/** A callback function to return format styles for individual markers. */"
    }
  },
  "SparklineMarkerFormatter": {
    "meta": { "isTypeAlias": true },
    "type": "(params: MarkerFormatterParams) => MarkerFormat"
  },
  "MarkerFormatterParams": {
    "meta": {},
    "type": {
      "datum": "any",
      "xValue": "any",
      "yValue": "any",
      "min?": "boolean",
      "max?": "boolean",
      "first?": "boolean",
      "last?": "boolean",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth": "number",
      "size": "number",
      "highlighted": "boolean"
    },
    "docs": {
      "datum": "/** The raw data associated with the specific marker. */",
      "xValue": "/** The x value of the marker. */",
      "yValue": "/** The y value of the marker. */",
      "min?": "/** Whether or not the marker is a minimum point. */",
      "max?": "/** Whether or not the marker is a maximum point. */",
      "first?": "/** Whether or not the marker represents the first data point. */",
      "last?": "/** Whether or not the marker represents the last data point. */",
      "fill?": "/** The CSS colour value for the fill of the individual marker. */",
      "stroke?": "/** The CSS colour value for the outline of the individual marker. */",
      "strokeWidth": "/** The thickness in pixels for the stroke of the individual marker. */",
      "size": "/** The width in pixels of the individual marker. */",
      "highlighted": "/** Whether or not the marker is highlighted. */"
    }
  },
  "MarkerFormat": {
    "meta": {},
    "type": {
      "enabled?": "boolean",
      "size?": "number",
      "fill?": "string",
      "stroke?": "string",
      "strokeWidth?": "number"
    },
    "docs": {
      "enabled?": "/** Set to false to make marker invisible. */",
      "size?": "/** The width in pixels of the individual marker. */",
      "fill?": "/** The CSS colour value for the fill of the individual column. */",
      "stroke?": "/** The CSS colour value for the outline of the individual column. */",
      "strokeWidth?": "/** The thickness in pixels for the stroke of the individual column. */"
    }
  },
  "IStatusBarService": {
    "meta": {},
    "type": {
      "registerStatusPanel(key: string, component: IStatusPanelComp)": "void",
      "getStatusPanel(key: string)": "IStatusPanelComp"
    }
  },
  "StatusPanelDef": {
    "meta": {},
    "type": {
      "statusPanel?": "{ new (): IStatusPanelComp; } | string",
      "statusPanelFramework?": "any",
      "align?": "string",
      "key?": "string",
      "statusPanelParams?": "any"
    }
  },
  "IStatusPanelParams": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi", "context": "any" },
    "docs": {
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "IStatusPanel": {
    "meta": {},
    "type": { "getFrameworkComponentInstance?()": "any" },
    "docs": {
      "getFrameworkComponentInstance?()": "/** If using a framework, returns the underlying component instance, so you can call methods\n * on it if you want. */"
    }
  },
  "IStatusPanelComp": {
    "meta": {},
    "type": {
      "getFrameworkComponentInstance?()": "any",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: IStatusPanelParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getFrameworkComponentInstance?()": "/** If using a framework, returns the underlying component instance, so you can call methods\n * on it if you want. */",
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: IStatusPanelParams)": "/** The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "IToolPanelParams": {
    "meta": {},
    "type": { "api": "GridApi", "columnApi": "ColumnApi" }
  },
  "IToolPanel": { "meta": {}, "type": { "refresh()": "void" } },
  "IToolPanelComp": {
    "meta": {},
    "type": {
      "refresh()": "void",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: IToolPanelParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: IToolPanelParams)": "/** The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "ToolPanelColumnCompParams": {
    "meta": {},
    "type": {
      "suppressColumnMove": "boolean",
      "suppressRowGroups": "boolean",
      "suppressValues": "boolean",
      "suppressPivots": "boolean",
      "suppressPivotMode": "boolean",
      "suppressColumnFilter": "boolean",
      "suppressColumnSelectAll": "boolean",
      "suppressColumnExpandAll": "boolean",
      "contractColumnSelection": "boolean",
      "suppressSyncLayoutWithGrid": "boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "suppressColumnMove": "/** Suppress Column Move section */",
      "suppressRowGroups": "/** Suppress Row Groups section */",
      "suppressValues": "/** Suppress Values section */",
      "suppressPivots": "/** Suppress Column Labels (Pivot) section */",
      "suppressPivotMode": "/** Suppress Pivot Mode selection */",
      "suppressColumnFilter": "/** Suppress Column Filter section */",
      "suppressColumnSelectAll": "/** Suppress Select / Un-select all widget */",
      "suppressColumnExpandAll": "/** Suppress Expand / Collapse all widget */",
      "contractColumnSelection": "/** By default, column groups start expanded. Pass `true` to default to contracted groups */",
      "suppressSyncLayoutWithGrid": "/** Suppress updating the layout of columns as they are rearranged in the grid */"
    }
  },
  "IPrimaryColsPanel": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "init(allowDragging: boolean, params: ToolPanelColumnCompParams, eventType: ColumnEventType)": "void",
      "onExpandAll()": "void",
      "onCollapseAll()": "void",
      "expandGroups(groupIds?: string[])": "void",
      "collapseGroups(groupIds?: string[])": "void",
      "setColumnLayout(colDefs: (ColDef | ColGroupDef)[])": "void",
      "syncLayoutWithGrid()": "void"
    }
  },
  "IViewportDatasource": {
    "meta": {},
    "type": {
      "init(params: IViewportDatasourceParams)": "void",
      "setViewportRange(firstRow: number, lastRow: number)": "void",
      "destroy?()": "void"
    },
    "docs": {
      "init(params: IViewportDatasourceParams)": "/** Gets called exactly once before viewPort is used. Passes methods to be used to tell viewPort of data loads / changes. */",
      "setViewportRange(firstRow: number, lastRow: number)": "/** Tell the viewport what the scroll position of the grid is, so it knows what rows it has to get. */",
      "destroy?()": "/** Gets called once when viewPort is no longer used. If you need to do any cleanup, do it here. */"
    }
  },
  "IViewportDatasourceParams": {
    "meta": {},
    "type": {
      "setRowCount": "(count: number, keepRenderedRows: boolean) => void",
      "setRowData": "(rowData: { [key: number]: any; }) => void",
      "getRow": "(rowIndex: number) => RowNode"
    },
    "docs": {
      "setRowCount": "/** Datasource calls this method when the total row count changes. This in turn sets the height of the grids vertical scroll. */",
      "setRowData": "/** Datasource calls this when new data arrives. The grid then updates the provided rows. The rows are mapped [rowIndex]=>rowData]. */",
      "getRow": "/** Datasource calls this when it wants a row node - typically used when it wants to update the row node. */"
    }
  },
  "XmlElement": {
    "meta": {},
    "type": {
      "name": "string",
      "properties?": "XmlAttributes",
      "children?": "XmlElement[]",
      "textNode?": "string | null"
    }
  },
  "HeaderElement": {
    "meta": {},
    "type": {
      "[key: string]": "string | undefined",
      "version?": "string",
      "standalone?": "string",
      "encoding?": "string"
    }
  },
  "XmlAttributes": {
    "meta": {},
    "type": {
      "prefixedAttributes?": "PrefixedXmlAttributes[]",
      "rawMap?": "any"
    }
  },
  "PrefixedXmlAttributes": {
    "meta": {},
    "type": { "prefix": "string", "map": "any" }
  },
  "IDetailCellRenderer": {
    "meta": {},
    "type": {
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "addOrRemoveDetailGridCssClass(cssClassName: string, on: boolean)": "void",
      "setDetailGrid(gridOptions: GridOptions)": "void",
      "setRowData(rowData: any[])": "void"
    }
  },
  "IDetailCellRendererParams": {
    "meta": {},
    "type": {
      "detailGridOptions": "GridOptions",
      "getDetailRowData": "GetDetailRowData",
      "refreshStrategy": "'rows' | 'everything' | 'nothing'",
      "template": "string | TemplateFunc",
      "agGridReact": "any",
      "frameworkComponentWrapper": "any",
      "$compile": "any",
      "pinned": "string",
      "autoHeight": "boolean",
      "suppressRefresh": "boolean",
      "value": "any",
      "valueFormatted": "any",
      "fullWidth?": "boolean",
      "pinned?": "string | null",
      "data": "any",
      "node": "RowNode",
      "rowIndex": "number",
      "colDef?": "ColDef",
      "column?": "Column",
      "$scope": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => any",
      "setValue?": "(value: any) => void",
      "formatValue?": "(value: any) => any",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string, suppressVisibilityChange?: boolean) => void"
    },
    "docs": {
      "detailGridOptions": "/** Provide Grid Options to use for the Detail Grid. */",
      "getDetailRowData": "/** A function that provides what rows to display in the Detail Grid. */",
      "refreshStrategy": "/** Defines how to refresh the Detail Grids as data is changing in the Master Grid. */",
      "template": "/** Allows changing the template used around the Detail Grid. */",
      "autoHeight": "/** @deprecated\n */",
      "suppressRefresh": "/** @deprecated\n */",
      "value": "/** Value to be rendered. */",
      "valueFormatted": "/** Formatted value to be rendered. */",
      "fullWidth?": "/** True if this is a full width row. */",
      "pinned?": "/** Pinned state of the cell. */",
      "data": "/** The row's data. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The current index of the row (this changes after filter and sort). */",
      "colDef?": "/** The cell's column definition. */",
      "column?": "/** The cell's column. */",
      "$scope": "/** AngularJS scope - null if not using AngularJS, this is legacy and not used if not */",
      "context": "/** The context as provided on `gridOptions.context`. */",
      "eGridCell": "/** The grid's cell, a DOM div element. */",
      "eParentOfValue": "/** The parent DOM item for the cell renderer, same as eGridCell unless using checkbox selection. */",
      "getValue?": "/** Convenience function to get most recent up to date value. */",
      "setValue?": "/** Convenience function to set the value. */",
      "formatValue?": "/** Convenience function to format a value using the column's formatter. */",
      "refreshCell?": "/** Convenience function to refresh the cell. */",
      "registerRowDragger": "/** registerRowDragger:\n * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n * @param suppressVisibilityChange Set to `true` to prevent the Grid from hiding the Row Dragger when it is disabled.\n */"
    }
  },
  "GetDetailRowData": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "GetDetailRowDataParams" },
      "returnType": "void"
    }
  },
  "GetDetailRowDataParams": {
    "meta": {},
    "type": {
      "node": "RowNode",
      "data": "any",
      "successCallback(rowData: any[])": "void"
    },
    "docs": {
      "node": "/** Row node for the details request. */",
      "data": "/** Data for the current row. */",
      "successCallback(rowData: any[])": "/** Success callback: pass the rows back for the grid request. */"
    }
  },
  "TemplateFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ICellRendererParams" },
      "returnType": "string"
    }
  },
  "IDetailCellRendererCtrl": {
    "meta": {},
    "type": {
      "init(comp: IDetailCellRenderer, params: IDetailCellRendererParams)": "void",
      "registerDetailWithMaster(api: GridApi, columnApi: ColumnApi)": "void",
      "refresh()": "boolean"
    }
  },
  "RowDataTransaction": {
    "meta": {},
    "type": {
      "addIndex?": "number | null",
      "add?": "any[] | null",
      "remove?": "any[] | null",
      "update?": "any[] | null"
    },
    "docs": {
      "addIndex?": "/** Index to add rows */",
      "add?": "/** Rows to add */",
      "remove?": "/** Rows to remove */",
      "update?": "/** Rows to update */"
    }
  },
  "RowNodeTransaction": {
    "meta": {},
    "type": {
      "add": "RowNode[]",
      "remove": "RowNode[]",
      "update": "RowNode[]"
    },
    "docs": {
      "add": "/** Row nodes added */",
      "remove": "/** Row nodes removed */",
      "update": "/** Row nodes updated */"
    }
  },
  "ServerSideTransaction": {
    "meta": {},
    "type": {
      "route?": "string[]",
      "addIndex?": "number",
      "add?": "any[]",
      "remove?": "any[]",
      "update?": "any[]"
    },
    "docs": {
      "route?": "/** The Row Store to apply the transaction to, ie what group level.\n * eg ['Ireland','2002'] to update the child store found after expanding Ireland and 2002 groups. \n * Passing in blank to empty applies the transaction to the top level. */",
      "addIndex?": "/** Index position to add at. If missing, rows will be added to the end. */",
      "add?": "/** Rows to add */",
      "remove?": "/** Rows to remove */",
      "update?": "/** Rows to update */"
    }
  },
  "ServerSideTransactionResult": {
    "meta": {},
    "type": {
      "status": "ServerSideTransactionResultStatus",
      "add?": "RowNode[]",
      "remove?": "RowNode[]",
      "update?": "RowNode[]"
    },
    "docs": {
      "status": "/** The status of applying the transaction. */",
      "add?": "/** If rows were added, the newly created Row Nodes for those rows. */",
      "remove?": "/** If rows were removed, the deleted Row Nodes. */",
      "update?": "/** If rows were updated, the updated Row Nodes. */"
    }
  },
  "ServerSideTransactionResultStatus": {
    "meta": { "isEnum": true },
    "type": [
      "Applied = 'Applied'",
      "StoreNotFound = 'StoreNotFound'",
      "StoreLoading = 'StoreLoading'",
      "StoreWaitingToLoad = 'StoreWaitingToLoad'",
      "StoreLoadingFailed = 'StoreLoadingFailed'",
      "StoreWrongType = 'StoreWrongType'",
      "Cancelled = 'Cancelled'"
    ],
    "docs": [
      "/** Transaction was successfully applied */",
      "/** Store was not found, transaction not applied.\n * Either invalid route, or the parent row has not yet been expanded. */",
      "/** Store is loading, transaction not applied. */",
      "/** Store is loading (as max loads exceeded), transaction not applied. */",
      "/** Store load attempt failed, transaction not applied. */",
      "/** Store is type Partial, which doesn't accept transactions */",
      "/** Transaction was cancelled, due to grid.\n * Callback isApplyServerSideTransaction() returning false */"
    ]
  },
  "TabbedLayoutParams": {
    "meta": {},
    "type": {
      "items": "TabbedItem[]",
      "cssClass?": "string",
      "onItemClicked?": "Function",
      "onActiveItemClicked?": "Function"
    }
  },
  "TabbedItem": {
    "meta": {},
    "type": {
      "title": "Element",
      "titleLabel": "string",
      "bodyPromise": "AgPromise<HTMLElement>",
      "name": "string",
      "afterAttachedCallback?": "(params: IAfterGuiAttachedParams) => void"
    }
  },
  "TabbedItemWrapper": {
    "meta": {},
    "type": { "tabbedItem": "TabbedItem", "eHeaderButton": "HTMLElement" }
  },
  "TaskItem": {
    "meta": {},
    "type": { "task": "() => void", "index": "number", "createOrder": "number" }
  },
  "TaskList": {
    "meta": {},
    "type": { "list": "TaskItem[]", "sorted": "boolean" }
  },
  "SimpleHttpRequestParams": { "meta": {}, "type": { "url": "string" } },
  "ModuleNames": {
    "meta": { "isEnum": true },
    "type": [
      "CommunityCoreModule = \"@ag-grid-community/core\"",
      "CommunityAllModules = \"@ag-grid-community/all\"",
      "InfiniteRowModelModule = \"@ag-grid-community/infinite-row-model\"",
      "ClientSideRowModelModule = \"@ag-grid-community/client-side-row-model\"",
      "CsvExportModule = \"@ag-grid-community/csv-export\"",
      "EnterpriseCoreModule = \"@ag-grid-enterprise/core\"",
      "EnterpriseAllModules = \"@ag-grid-enterprise/all\"",
      "RowGroupingModule = \"@ag-grid-enterprise/row-grouping\"",
      "ColumnToolPanelModule = \"@ag-grid-enterprise/column-tool-panel\"",
      "FiltersToolPanelModule = \"@ag-grid-enterprise/filter-tool-panel\"",
      "MenuModule = \"@ag-grid-enterprise/menu\"",
      "SetFilterModule = \"@ag-grid-enterprise/set-filter\"",
      "MultiFilterModule = \"@ag-grid-enterprise/multi-filter\"",
      "StatusBarModule = \"@ag-grid-enterprise/status-bar\"",
      "SideBarModule = \"@ag-grid-enterprise/side-bar\"",
      "RangeSelectionModule = \"@ag-grid-enterprise/range-selection\"",
      "MasterDetailModule = \"@ag-grid-enterprise/master-detail\"",
      "RichSelectModule = \"@ag-grid-enterprise/rich-select\"",
      "GridChartsModule = \"@ag-grid-enterprise/charts\"",
      "ViewportRowModelModule = \"@ag-grid-enterprise/viewport-row-model\"",
      "ServerSideRowModelModule = \"@ag-grid-enterprise/server-side-row-model\"",
      "ExcelExportModule = \"@ag-grid-enterprise/excel-export\"",
      "ClipboardModule = \"@ag-grid-enterprise/clipboard\"",
      "SparklinesModule = \"@ag-grid-enterprise/sparklines\"",
      "AngularModule = \"@ag-grid-community/angular\"",
      "ReactModule = \"@ag-grid-community/react\"",
      "VueModule = \"@ag-grid-community/vue\"",
      "PolymerModule = \"@ag-grid-community/polymer\""
    ],
    "docs": [
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null,
      null
    ]
  },
  "ICellComp": {
    "meta": {},
    "type": {
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "setUserStyles(styles: any)": "void",
      "setAriaSelected(selected: boolean | undefined)": "void",
      "setAriaExpanded(expanded: boolean)": "void",
      "getFocusableElement()": "HTMLElement",
      "setLeft(left: string)": "void",
      "setWidth(width: string)": "void",
      "setAriaColIndex(index: number)": "void",
      "setHeight(height: string)": "void",
      "setZIndex(zIndex: string)": "void",
      "setTabIndex(tabIndex: number)": "void",
      "setRole(role: string)": "void",
      "setColId(colId: string)": "void",
      "setTitle(title: string | undefined)": "void",
      "setUnselectable(value: 'on' | null)": "void",
      "setTransition(value: string | undefined)": "void",
      "setIncludeSelection(include: boolean)": "void",
      "setIncludeRowDrag(include: boolean)": "void",
      "setIncludeDndSource(include: boolean)": "void",
      "setForceWrapper(force: boolean)": "void",
      "getCellEditor()": "ICellEditor | null",
      "getCellRenderer()": "ICellRenderer | null",
      "getParentOfValue()": "HTMLElement | null",
      "setRenderDetails(compDetails: UserCompDetails | undefined, valueToDisplay: any, forceNewCellRendererInstance: boolean)": "void",
      "setEditDetails(compDetails?: UserCompDetails, popup?: boolean, position?: string)": "void"
    }
  },
  "ILargeTextEditorParams": {
    "meta": {},
    "type": {
      "maxLength": "number",
      "rows": "number",
      "cols": "number",
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any"
    },
    "docs": {
      "value": "/** Current value of the cell */",
      "keyPress": "/** Key code of key that started the edit, eg 'Enter' or 'Delete' - non-printable\n * characters appear here */",
      "charPress": "/** The string that started the edit, eg 'a' if letter 'a' was pressed, or 'A' if\n * shift + letter 'a' only printable characters appear here */",
      "column": "/** Grid column */",
      "colDef": "/** Column definition */",
      "node": "/** Row node for the cell */",
      "data": "/** Row data */",
      "rowIndex": "/** Editing row index */",
      "cellStartedEdit": "/** If doing full row edit, this is true if the cell is the one that started the edit\n * (eg it is the cell the use double clicked on, or pressed a key on etc). */",
      "context": "/** Context  as set on gridOptions.context */",
      "$scope": "/** AngularJS scope - null if not using AngularJS, this is legacy and not used if not */",
      "onKeyDown": "/** callback to tell grid a key was pressed - useful to pass control key events (tab,\n * arrows etc) back to grid - however you do */",
      "stopEditing": "/** Callback to tell grid to stop editing the current cell. pass 'false' to prevent\n * navigation moving to the next cell if grid property `enterMovesDownAfterEdit=true` */",
      "eGridCell": "/** A reference to the DOM element representing the grid cell that your component\n * will live inside. Useful if you want to add event listeners or classes at this level.\n * This is the DOM element that gets browser focus when selecting cells. */",
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "formatValue": "/** Utility function to format a value using the column's `colDef.valueFormatter` */"
    }
  },
  "ISelectCellEditorParams": {
    "meta": {},
    "type": {
      "values": "any[]",
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any"
    },
    "docs": {
      "value": "/** Current value of the cell */",
      "keyPress": "/** Key code of key that started the edit, eg 'Enter' or 'Delete' - non-printable\n * characters appear here */",
      "charPress": "/** The string that started the edit, eg 'a' if letter 'a' was pressed, or 'A' if\n * shift + letter 'a' only printable characters appear here */",
      "column": "/** Grid column */",
      "colDef": "/** Column definition */",
      "node": "/** Row node for the cell */",
      "data": "/** Row data */",
      "rowIndex": "/** Editing row index */",
      "cellStartedEdit": "/** If doing full row edit, this is true if the cell is the one that started the edit\n * (eg it is the cell the use double clicked on, or pressed a key on etc). */",
      "context": "/** Context  as set on gridOptions.context */",
      "$scope": "/** AngularJS scope - null if not using AngularJS, this is legacy and not used if not */",
      "onKeyDown": "/** callback to tell grid a key was pressed - useful to pass control key events (tab,\n * arrows etc) back to grid - however you do */",
      "stopEditing": "/** Callback to tell grid to stop editing the current cell. pass 'false' to prevent\n * navigation moving to the next cell if grid property `enterMovesDownAfterEdit=true` */",
      "eGridCell": "/** A reference to the DOM element representing the grid cell that your component\n * will live inside. Useful if you want to add event listeners or classes at this level.\n * This is the DOM element that gets browser focus when selecting cells. */",
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "formatValue": "/** Utility function to format a value using the column's `colDef.valueFormatter` */"
    }
  },
  "ITextCellEditorParams": {
    "meta": {
      "doc": "/** useFormatter: used when the cell value needs formatting prior to editing, such as when using reference data and you\n *                want to display text rather than code. */"
    },
    "type": {
      "useFormatter": "boolean",
      "value": "any",
      "keyPress": "number | null",
      "charPress": "string | null",
      "column": "Column",
      "colDef": "ColDef",
      "node": "RowNode",
      "data": "any",
      "rowIndex": "number",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "cellStartedEdit": "boolean",
      "context": "any",
      "$scope": "any",
      "onKeyDown": "(event: KeyboardEvent) => void",
      "stopEditing": "(suppressNavigateAfterEdit?: boolean) => void",
      "eGridCell": "HTMLElement",
      "parseValue": "(value: any) => any",
      "formatValue": "(value: any) => any"
    },
    "docs": {
      "value": "/** Current value of the cell */",
      "keyPress": "/** Key code of key that started the edit, eg 'Enter' or 'Delete' - non-printable\n * characters appear here */",
      "charPress": "/** The string that started the edit, eg 'a' if letter 'a' was pressed, or 'A' if\n * shift + letter 'a' only printable characters appear here */",
      "column": "/** Grid column */",
      "colDef": "/** Column definition */",
      "node": "/** Row node for the cell */",
      "data": "/** Row data */",
      "rowIndex": "/** Editing row index */",
      "cellStartedEdit": "/** If doing full row edit, this is true if the cell is the one that started the edit\n * (eg it is the cell the use double clicked on, or pressed a key on etc). */",
      "context": "/** Context  as set on gridOptions.context */",
      "$scope": "/** AngularJS scope - null if not using AngularJS, this is legacy and not used if not */",
      "onKeyDown": "/** callback to tell grid a key was pressed - useful to pass control key events (tab,\n * arrows etc) back to grid - however you do */",
      "stopEditing": "/** Callback to tell grid to stop editing the current cell. pass 'false' to prevent\n * navigation moving to the next cell if grid property `enterMovesDownAfterEdit=true` */",
      "eGridCell": "/** A reference to the DOM element representing the grid cell that your component\n * will live inside. Useful if you want to add event listeners or classes at this level.\n * This is the DOM element that gets browser focus when selecting cells. */",
      "parseValue": "/** Utility function to parse a value using the column's `colDef.valueParser` */",
      "formatValue": "/** Utility function to format a value using the column's `colDef.valueFormatter` */"
    }
  },
  "IGroupCellRenderer": {
    "meta": {},
    "type": {
      "setInnerRenderer(compDetails: UserCompDetails | undefined, valueToDisplay: any)": "void",
      "setChildCount(count: string)": "void",
      "setCheckboxVisible(value: boolean)": "void",
      "setExpandedDisplayed(value: boolean)": "void",
      "setContractedDisplayed(value: boolean)": "void",
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void"
    }
  },
  "FooterValueGetterFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "GroupCellRendererParams" },
      "returnType": "any"
    }
  },
  "GroupCellRendererParams": {
    "meta": {},
    "type": {
      "pinned": "string",
      "fullWidth": "boolean",
      "suppressPadding": "boolean",
      "suppressDoubleClickExpand": "boolean",
      "suppressEnterExpand": "boolean",
      "footerValueGetter": "string | FooterValueGetterFunc",
      "suppressCount": "boolean",
      "checkbox": "any",
      "rowDrag?": "boolean",
      "innerRenderer?": "{ new (): ICellRendererComp; } | ICellRendererFunc | string",
      "innerRendererFramework?": "any",
      "innerRendererParams?": "any",
      "innerRendererSelector?": "CellRendererSelectorFunc",
      "scope": "any",
      "padding": "number",
      "value": "any",
      "valueFormatted": "any",
      "fullWidth?": "boolean",
      "pinned?": "string | null",
      "data": "any",
      "node": "RowNode",
      "rowIndex": "number",
      "colDef?": "ColDef",
      "column?": "Column",
      "$scope": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => any",
      "setValue?": "(value: any) => void",
      "formatValue?": "(value: any) => any",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string, suppressVisibilityChange?: boolean) => void"
    },
    "docs": {
      "pinned": "/** Only when in fullWidth, this gives whether the comp is pinned or not.\n * If not doing fullWidth, then this is not provided, as pinned can be got from the column. */",
      "fullWidth": "/** 'true' if comp is showing full width. */",
      "suppressPadding": "/** Set to `true` to not include any padding (indentation) in teh child rows. */",
      "suppressDoubleClickExpand": "/** Set to `true` to suppress expand on double click. */",
      "suppressEnterExpand": "/** Set to `true` to suppress expand on <kbd>Enter</kbd> */",
      "footerValueGetter": "/** The value getter for the footer text. Can be a function or expression. */",
      "suppressCount": "/** If `true`, count is not displayed beside the name. */",
      "checkbox": "/** If `true`, a selection checkbox is included. */",
      "innerRenderer?": "/** The renderer to use for inside the cell (after grouping functions are added) */",
      "innerRendererFramework?": "/** Same as `innerRenderer` but for a framework component. */",
      "innerRendererParams?": "/** Additional params to customise to the `innerRenderer`. */",
      "innerRendererSelector?": "/** Callback to enable different innerRenderers to be used based of value of params. */",
      "padding": "/** @deprecated\n */",
      "value": "/** Value to be rendered. */",
      "valueFormatted": "/** Formatted value to be rendered. */",
      "fullWidth?": "/** True if this is a full width row. */",
      "pinned?": "/** Pinned state of the cell. */",
      "data": "/** The row's data. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The current index of the row (this changes after filter and sort). */",
      "colDef?": "/** The cell's column definition. */",
      "column?": "/** The cell's column. */",
      "$scope": "/** AngularJS scope - null if not using AngularJS, this is legacy and not used if not */",
      "context": "/** The context as provided on `gridOptions.context`. */",
      "eGridCell": "/** The grid's cell, a DOM div element. */",
      "eParentOfValue": "/** The parent DOM item for the cell renderer, same as eGridCell unless using checkbox selection. */",
      "getValue?": "/** Convenience function to get most recent up to date value. */",
      "setValue?": "/** Convenience function to set the value. */",
      "formatValue?": "/** Convenience function to format a value using the column's formatter. */",
      "refreshCell?": "/** Convenience function to refresh the cell. */",
      "registerRowDragger": "/** registerRowDragger:\n * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n * @param suppressVisibilityChange Set to `true` to prevent the Grid from hiding the Row Dragger when it is disabled.\n */"
    }
  },
  "ICellRendererParams": {
    "meta": {},
    "type": {
      "value": "any",
      "valueFormatted": "any",
      "fullWidth?": "boolean",
      "pinned?": "string | null",
      "data": "any",
      "node": "RowNode",
      "rowIndex": "number",
      "colDef?": "ColDef",
      "column?": "Column",
      "$scope": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => any",
      "setValue?": "(value: any) => void",
      "formatValue?": "(value: any) => any",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string, suppressVisibilityChange?: boolean) => void"
    },
    "docs": {
      "value": "/** Value to be rendered. */",
      "valueFormatted": "/** Formatted value to be rendered. */",
      "fullWidth?": "/** True if this is a full width row. */",
      "pinned?": "/** Pinned state of the cell. */",
      "data": "/** The row's data. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The current index of the row (this changes after filter and sort). */",
      "colDef?": "/** The cell's column definition. */",
      "column?": "/** The cell's column. */",
      "$scope": "/** AngularJS scope - null if not using AngularJS, this is legacy and not used if not */",
      "context": "/** The context as provided on `gridOptions.context`. */",
      "eGridCell": "/** The grid's cell, a DOM div element. */",
      "eParentOfValue": "/** The parent DOM item for the cell renderer, same as eGridCell unless using checkbox selection. */",
      "getValue?": "/** Convenience function to get most recent up to date value. */",
      "setValue?": "/** Convenience function to set the value. */",
      "formatValue?": "/** Convenience function to format a value using the column's formatter. */",
      "refreshCell?": "/** Convenience function to refresh the cell. */",
      "registerRowDragger": "/** registerRowDragger:\n * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n * @param suppressVisibilityChange Set to `true` to prevent the Grid from hiding the Row Dragger when it is disabled.\n */"
    }
  },
  "ISetFilterCellRendererParams": {
    "meta": {},
    "type": {
      "value": "any",
      "valueFormatted": "any",
      "api": "GridApi",
      "context": "any"
    },
    "docs": {
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "ICellRenderer": {
    "meta": {},
    "type": { "refresh(params: ICellRendererParams)": "boolean" },
    "docs": {
      "refresh(params: ICellRendererParams)": "/** Get the cell to refresh. Return true if successful. Return false if not (or you don't have refresh logic),\n * then the grid will refresh the cell for you. */"
    }
  },
  "ICellRendererComp": {
    "meta": {},
    "type": {
      "refresh(params: ICellRendererParams)": "boolean",
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: ICellRendererParams)": "AgPromise<void> | void"
    },
    "docs": {
      "refresh(params: ICellRendererParams)": "/** Get the cell to refresh. Return true if successful. Return false if not (or you don't have refresh logic),\n * then the grid will refresh the cell for you. */",
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: ICellRendererParams)": "/** The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "ICellRendererFunc": {
    "meta": { "isCallSignature": true },
    "type": {
      "arguments": { "params": "ICellRendererParams" },
      "returnType": "HTMLElement | string"
    }
  },
  "ILoadingCellRendererParams": {
    "meta": {},
    "type": {
      "value": "any",
      "valueFormatted": "any",
      "fullWidth?": "boolean",
      "pinned?": "string | null",
      "data": "any",
      "node": "RowNode",
      "rowIndex": "number",
      "colDef?": "ColDef",
      "column?": "Column",
      "$scope": "any",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any",
      "eGridCell": "HTMLElement",
      "eParentOfValue": "HTMLElement",
      "getValue?": "() => any",
      "setValue?": "(value: any) => void",
      "formatValue?": "(value: any) => any",
      "refreshCell?": "() => void",
      "registerRowDragger": "(rowDraggerElement: HTMLElement, dragStartPixels?: number, value?: string, suppressVisibilityChange?: boolean) => void"
    },
    "docs": {
      "value": "/** Value to be rendered. */",
      "valueFormatted": "/** Formatted value to be rendered. */",
      "fullWidth?": "/** True if this is a full width row. */",
      "pinned?": "/** Pinned state of the cell. */",
      "data": "/** The row's data. */",
      "node": "/** The row node. */",
      "rowIndex": "/** The current index of the row (this changes after filter and sort). */",
      "colDef?": "/** The cell's column definition. */",
      "column?": "/** The cell's column. */",
      "$scope": "/** AngularJS scope - null if not using AngularJS, this is legacy and not used if not */",
      "context": "/** The context as provided on `gridOptions.context`. */",
      "eGridCell": "/** The grid's cell, a DOM div element. */",
      "eParentOfValue": "/** The parent DOM item for the cell renderer, same as eGridCell unless using checkbox selection. */",
      "getValue?": "/** Convenience function to get most recent up to date value. */",
      "setValue?": "/** Convenience function to set the value. */",
      "formatValue?": "/** Convenience function to format a value using the column's formatter. */",
      "refreshCell?": "/** Convenience function to refresh the cell. */",
      "registerRowDragger": "/** registerRowDragger:\n * @param rowDraggerElement The HTMLElement to be used as Row Dragger\n * @param dragStartPixels The amount of pixels required to start the drag (Default: 4)\n * @param value The value to be displayed while dragging. Note: Only relevant with Full Width Rows.\n * @param suppressVisibilityChange Set to `true` to prevent the Grid from hiding the Row Dragger when it is disabled.\n */"
    }
  },
  "ILoadingCellRenderer": {
    "meta": {},
    "type": { "refresh(params: ICellRendererParams)": "boolean" },
    "docs": {
      "refresh(params: ICellRendererParams)": "/** Get the cell to refresh. Return true if successful. Return false if not (or you don't have refresh logic),\n * then the grid will refresh the cell for you. */"
    }
  },
  "IDate": {
    "meta": {},
    "type": {
      "getDate()": "Date | null",
      "setDate(date: Date | null)": "void",
      "setInputPlaceholder?(placeholder: string)": "void",
      "setInputAriaLabel?(placeholder: string)": "void"
    },
    "docs": {
      "getDate()": "/** Returns the current date represented by this editor */",
      "setDate(date: Date | null)": "/** Sets the date represented by this component */"
    }
  },
  "IDateParams": {
    "meta": {},
    "type": {
      "onDateChanged": "() => void",
      "filterParams": "IDateFilterParams"
    },
    "docs": {
      "onDateChanged": "/** Method for component to tell AG Grid that the date has changed. */"
    }
  },
  "IDateComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: IDateParams)": "AgPromise<void> | void",
      "getDate()": "Date | null",
      "setDate(date: Date | null)": "void",
      "setInputPlaceholder?(placeholder: string)": "void",
      "setInputAriaLabel?(placeholder: string)": "void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: IDateParams)": "/** The init(params) method is called on the component once. See below for details on the parameters. */",
      "getDate()": "/** Returns the current date represented by this editor */",
      "setDate(date: Date | null)": "/** Sets the date represented by this component */"
    }
  },
  "PositionableOptions": {
    "meta": {},
    "type": {
      "popup?": "boolean",
      "minWidth?": "number | null",
      "width?": "number | string | null",
      "minHeight?": "number | null",
      "height?": "number | string | null",
      "centered?": "boolean | null",
      "calculateTopBuffer?": "() => number",
      "forcePopupParentAsOffsetParent?": "boolean",
      "x?": "number | null",
      "y?": "number | null"
    },
    "docs": {
      "forcePopupParentAsOffsetParent?": "/** Used for when a popup needs to be resized by an element within itself\n * In that case, the feature will configured as `popup=false` but the offsetParent\n * needs to be the popupParent. */"
    }
  },
  "ResizableSides": {
    "meta": { "isTypeAlias": true },
    "type": "'topLeft' | 'top' | 'topRight' | 'right' | 'bottomRight' | 'bottom' | 'bottomLeft' | 'left'"
  },
  "ResizableStructure": {
    "meta": { "isTypeAlias": true },
    "type": "{[key in ResizableSides]?: boolean}"
  },
  "MappedResizer": {
    "meta": {},
    "type": { "element": "HTMLElement", "dragSource?": "DragListenerParams" }
  },
  "ILoadingOverlayParams": { "meta": {}, "type": { "api": "GridApi" } },
  "ILoadingOverlayComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: ILoadingOverlayParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: ILoadingOverlayParams)": "/** The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "INoRowsOverlayParams": { "meta": {}, "type": { "api": "GridApi" } },
  "INoRowsOverlayComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: INoRowsOverlayParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: INoRowsOverlayParams)": "/** The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "LoadingType": {
    "meta": { "isEnum": true },
    "type": ["Loading", "NoRows"],
    "docs": [null, null]
  },
  "RowCssClassCalculatorParams": {
    "meta": {},
    "type": {
      "rowNode": "RowNode",
      "rowIsEven": "boolean",
      "rowLevel": "number",
      "fullWidthRow?": "boolean",
      "firstRowOnPage": "boolean",
      "lastRowOnPage": "boolean",
      "printLayout": "boolean",
      "expandable": "boolean",
      "pinned?": "string | null",
      "extraCssClass?": "string",
      "rowFocused?": "boolean",
      "fadeRowIn?": "boolean",
      "scope?": "any"
    }
  },
  "RowType": {
    "meta": { "isEnum": true },
    "type": [
      "Normal = 'Normal'",
      "FullWidth = 'FullWidth'",
      "FullWidthLoading = 'FullWidthLoading'",
      "FullWidthGroup = 'FullWidthGroup'",
      "FullWidthDetail = 'FullWidthDetail'"
    ],
    "docs": [null, null, null, null, null]
  },
  "IRowComp": {
    "meta": {},
    "type": {
      "setDisplay(value?: string)": "void",
      "setDomOrder(domOrder: boolean)": "void",
      "addOrRemoveCssClass(cssClassName: string, on: boolean)": "void",
      "setCellCtrls(cellCtrls: CellCtrl[])": "void",
      "showFullWidth(compDetails: UserCompDetails)": "void",
      "getFullWidthCellRenderer()": "ICellRenderer | null | undefined",
      "setAriaExpanded(on: boolean)": "void",
      "setAriaSelected(selected: boolean | undefined)": "void",
      "setHeight(height: string)": "void",
      "setTop(top: string)": "void",
      "setTransform(transform: string)": "void",
      "setRowIndex(rowIndex: string)": "void",
      "setAriaRowIndex(rowIndex: number)": "void",
      "setRowId(rowId: string)": "void",
      "setRowBusinessKey(businessKey: string)": "void",
      "setTabIndex(tabIndex: number)": "void",
      "setAriaLabel(label: string | undefined)": "void",
      "setUserStyles(styles: any)": "void",
      "setRole(role: string)": "void"
    }
  },
  "RowGui": {
    "meta": {},
    "type": {
      "rowComp": "IRowComp",
      "element": "HTMLElement",
      "pinned": "string | null"
    }
  },
  "CellCtrlListAndMap": {
    "meta": {},
    "type": { "list": "CellCtrl[]", "map": "{ [key: string]: CellCtrl; }" }
  },
  "IRowDragItem": {
    "meta": {},
    "type": {
      "defaultTextValue": "string",
      "rowNode?": "RowNode",
      "rowNodes?": "RowNode[]",
      "columns?": "Column[]",
      "visibleState?": "{ [key: string]: boolean; }"
    },
    "docs": {
      "defaultTextValue": "/** The default text that would be applied to this Drag Element */",
      "rowNode?": "/** When dragging a row, this contains the row node being dragged\n * When dragging multiple rows, this contains the row that started the drag. */",
      "rowNodes?": "/** When dragging multiple rows, this contains all rows being dragged */",
      "columns?": "/** When dragging columns, this contains the columns being dragged */",
      "visibleState?": "/** When dragging columns, this contains the visible state of the columns */"
    }
  },
  "RowCtrlMap": { "meta": {}, "type": { "[key: string]": "RowCtrl" } },
  "RefreshViewParams": {
    "meta": {},
    "type": {
      "recycleRows?": "boolean",
      "animate?": "boolean",
      "suppressKeepFocus?": "boolean",
      "onlyBody?": "boolean",
      "newData?": "boolean",
      "newPage?": "boolean"
    }
  },
  "ITooltipParams": {
    "meta": {},
    "type": {
      "location": "string",
      "value?": "any",
      "valueFormatted?": "any",
      "colDef?": "ColDef | ColGroupDef | null",
      "column?": "Column | ColumnGroup",
      "rowIndex?": "number",
      "node?": "RowNode",
      "data?": "any",
      "context?": "any",
      "api?": "GridApi",
      "columnApi?": "ColumnApi"
    },
    "docs": {
      "location": "/** What part of the application is showing the tooltip, e.g. 'cell', 'header', 'menuItem' etc */",
      "value?": "/** The value to be rendered by the tooltip. */",
      "valueFormatted?": "/** The formatted value to be rendered by the tooltip. */",
      "colDef?": "/** Column / ColumnGroup definition. */",
      "column?": "/** Column / ColumnGroup */",
      "rowIndex?": "/** The index of the row containing the cell rendering the tooltip. */",
      "node?": "/** The row node. */",
      "data?": "/** Data for the row node in question. */",
      "context?": "/** Context as set on gridOptions.context. */"
    }
  },
  "ITooltipComp": {
    "meta": {},
    "type": {
      "getGui()": "HTMLElement",
      "destroy?()": "void",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "void",
      "init?(params: ITooltipParams)": "AgPromise<void> | void"
    },
    "docs": {
      "getGui()": "/** Return the DOM element of your component, this is what the grid puts into the DOM */",
      "destroy?()": "/** Gets called once by grid when the component is being removed; if your component needs to do any cleanup, do it here */",
      "afterGuiAttached?(params?: IAfterGuiAttachedParams)": "/** A hook to perform any necessary operation just after the GUI for this component has been rendered\n * on the screen.\n * If a parent popup is closed and reopened (e.g. for filters), this method is called each time the component is shown.\n * This is useful for any\n * logic that requires attachment before executing, such as putting focus on a particular DOM\n * element. The params has one callback method 'hidePopup', which you can call at any later\n * point to hide the popup - good if you have an 'Apply' button and you want to hide the popup\n * after it is pressed. */",
      "init?(params: ITooltipParams)": "/** The init(params) method is called on the component once. See below for details on the parameters. */"
    }
  },
  "LoadCompleteEvent": {
    "meta": {},
    "type": { "success": "boolean", "block": "RowNodeBlock", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "LoadSuccessParams": {
    "meta": {},
    "type": { "rowData": "any[]", "rowCount?": "number", "storeInfo?": "any" },
    "docs": {
      "rowData": "/** Data retrieved from the server as requested by the grid. */",
      "rowCount?": "/** The last row, if known, to help Infinite Scroll (i.e Partial Store) and Pagination. */",
      "storeInfo?": "/** Any extra information for the grid to associate with this load. */"
    }
  },
  "SortOption": {
    "meta": {},
    "type": { "sort": "string", "column": "Column" }
  },
  "SortedRowNode": {
    "meta": {},
    "type": { "currentPos": "number", "rowNode": "RowNode" }
  },
  "SortModelItem": {
    "meta": {},
    "type": { "colId": "string", "sort": "string" }
  },
  "LayoutView": {
    "meta": {},
    "type": {
      "updateLayoutClasses(layoutClass: string, params: UpdateLayoutClassesParams)": "void"
    }
  },
  "LayoutCssClasses": {
    "meta": { "isEnum": true },
    "type": [
      "AUTO_HEIGHT = 'ag-layout-auto-height'",
      "NORMAL = 'ag-layout-normal'",
      "PRINT = 'ag-layout-print'"
    ],
    "docs": [null, null, null]
  },
  "UpdateLayoutClassesParams": {
    "meta": {},
    "type": { "autoHeight": "boolean", "normal": "boolean", "print": "boolean" }
  },
  "GenericFunction": {
    "meta": { "isTypeAlias": true },
    "type": "(...args: any[]) => any"
  },
  "PickByTypeKeyFilter": {
    "meta": { "isTypeAlias": true, "typeParams": ["T", "C"] },
    "type": "{[K in keyof T]: T[K] extends C ? K : never}"
  },
  "KeysByType": {
    "meta": { "isTypeAlias": true, "typeParams": ["T", "C"] },
    "type": "PickByTypeKeyFilter<T, C>[keyof T]"
  },
  "ValuesByType": {
    "meta": { "isTypeAlias": true, "typeParams": ["T", "C"] },
    "type": "{[K in keyof T]: T[K] extends C ? T[K] : never}"
  },
  "PickByType": {
    "meta": { "isTypeAlias": true, "typeParams": ["T", "C"] },
    "type": "Pick<ValuesByType<T, C>, KeysByType<T, C>>"
  },
  "MethodsOf": {
    "meta": { "isTypeAlias": true, "typeParams": ["T"] },
    "type": "KeysByType<Required<T>, GenericFunction>"
  },
  "InterfaceOf": {
    "meta": { "isTypeAlias": true, "typeParams": ["T"] },
    "type": "PickByType<T, GenericFunction>"
  },
  "PartiallyMockedInterfaceOf": {
    "meta": { "isTypeAlias": true, "typeParams": ["T"] },
    "type": "{[K in MethodsOf<T>]?: jest.Mock<InterfaceOf<T>[K]>}"
  },
  "CellValueChange": {
    "meta": {},
    "type": {
      "rowPinned": "string | null",
      "rowIndex": "number",
      "columnId": "string",
      "oldValue": "any",
      "newValue": "any"
    }
  },
  "LastFocusedCell": {
    "meta": {},
    "type": {
      "rowPinned?": "string | null",
      "rowIndex": "number",
      "columnId": "string"
    }
  },
  "ColumnSortState": {
    "meta": { "isTypeAlias": true },
    "type": "'ascending' | 'descending' | 'none'"
  },
  "PathItem": {
    "meta": {},
    "type": { "rowNode": "RowNode", "children": "PathItem[] | null" }
  },
  "ResolveAndRejectCallback": {
    "meta": { "isTypeAlias": true, "typeParams": ["T"] },
    "type": "(resolve: (value: T | null) => void, reject: (params: any) => void) => void"
  },
  "AgPromiseStatus": {
    "meta": { "isEnum": true },
    "type": ["IN_PROGRESS", "RESOLVED"],
    "docs": [null, null]
  },
  "FieldElement": {
    "meta": { "isTypeAlias": true },
    "type": "HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement"
  },
  "IInputField": {
    "meta": {},
    "type": {
      "value?": "any",
      "width?": "number",
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment"
    }
  },
  "LabelAlignment": {
    "meta": { "isTypeAlias": true },
    "type": "'left' | 'right' | 'top'"
  },
  "IAgLabel": {
    "meta": {},
    "type": {
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment"
    }
  },
  "ChangeEvent": {
    "meta": {},
    "type": { "selected": "boolean", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "ColorPickerConfig": {
    "meta": {},
    "type": {
      "color": "string",
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment"
    }
  },
  "DialogOptions": {
    "meta": {},
    "type": {
      "eWrapper?": "HTMLElement",
      "modal?": "boolean",
      "movable?": "boolean",
      "alwaysOnTop?": "boolean",
      "maximizable?": "boolean",
      "component?": "Component",
      "hideTitleBar?": "boolean | null",
      "closable?": "boolean | null",
      "resizable?": "boolean | ResizableStructure",
      "title?": "string | null",
      "cssIdentifier?": "string | null",
      "popup?": "boolean",
      "minWidth?": "number | null",
      "width?": "number | string | null",
      "minHeight?": "number | null",
      "height?": "number | string | null",
      "centered?": "boolean | null",
      "calculateTopBuffer?": "() => number",
      "forcePopupParentAsOffsetParent?": "boolean",
      "x?": "number | null",
      "y?": "number | null"
    },
    "docs": {
      "forcePopupParentAsOffsetParent?": "/** Used for when a popup needs to be resized by an element within itself\n * In that case, the feature will configured as `popup=false` but the offsetParent\n * needs to be the popupParent. */"
    }
  },
  "GroupItem": {
    "meta": { "isTypeAlias": true },
    "type": "Component | HTMLElement"
  },
  "Align": {
    "meta": { "isTypeAlias": true },
    "type": "'start' | 'end' | 'center' | 'stretch'"
  },
  "Direction": {
    "meta": { "isTypeAlias": true },
    "type": "'horizontal' | 'vertical'"
  },
  "AgGroupComponentParams": {
    "meta": {},
    "type": {
      "title?": "string",
      "enabled?": "boolean",
      "suppressEnabledCheckbox?": "boolean",
      "suppressOpenCloseIcons?": "boolean",
      "cssIdentifier?": "string",
      "items?": "GroupItem[]",
      "alignItems?": "Align",
      "direction?": "Direction"
    }
  },
  "IInputRange": {
    "meta": {},
    "type": {
      "min?": "number",
      "max?": "number",
      "step?": "number",
      "value?": "any",
      "width?": "number",
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment"
    }
  },
  "ITextInputField": {
    "meta": {},
    "type": {
      "allowedCharPattern?": "string",
      "value?": "any",
      "width?": "number",
      "label?": "HTMLElement | string",
      "labelWidth?": "number | 'flex'",
      "labelSeparator?": "string",
      "labelAlignment?": "LabelAlignment"
    }
  },
  "ListOption": {
    "meta": {},
    "type": { "value": "string", "text?": "string" }
  },
  "PanelOptions": {
    "meta": {},
    "type": {
      "component?": "Component",
      "hideTitleBar?": "boolean | null",
      "closable?": "boolean | null",
      "resizable?": "boolean | ResizableStructure",
      "title?": "string | null",
      "cssIdentifier?": "string | null",
      "popup?": "boolean",
      "minWidth?": "number | null",
      "width?": "number | string | null",
      "minHeight?": "number | null",
      "height?": "number | string | null",
      "centered?": "boolean | null",
      "calculateTopBuffer?": "() => number",
      "forcePopupParentAsOffsetParent?": "boolean",
      "x?": "number | null",
      "y?": "number | null"
    },
    "docs": {
      "forcePopupParentAsOffsetParent?": "/** Used for when a popup needs to be resized by an element within itself\n * In that case, the feature will configured as `popup=false` but the offsetParent\n * needs to be the popupParent. */"
    }
  },
  "VisibleChangedEvent": {
    "meta": {},
    "type": { "visible": "boolean", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "TooltipParentComp": {
    "meta": {},
    "type": {
      "getTooltipParams()": "ITooltipParams",
      "getGui()": "HTMLElement"
    }
  },
  "TooltipStates": {
    "meta": { "isEnum": true },
    "type": ["NOTHING", "WAITING_TO_SHOW", "SHOWING"],
    "docs": [null, null, null]
  },
  "ManagedFocusCallbacks": {
    "meta": {},
    "type": {
      "shouldStopEventPropagation?": "(e: KeyboardEvent) => boolean",
      "onTabKeyDown?": "(e: KeyboardEvent) => void",
      "handleKeyDown?": "(e: KeyboardEvent) => void",
      "onFocusIn?": "(e: FocusEvent) => void",
      "onFocusOut?": "(e: FocusEvent) => void"
    }
  },
  "PopupEventParams": {
    "meta": {},
    "type": {
      "originalMouseEvent?": "MouseEvent | Touch | null",
      "mouseEvent?": "MouseEvent",
      "touchEvent?": "TouchEvent",
      "keyboardEvent?": "KeyboardEvent"
    }
  },
  "AgPopup": {
    "meta": {},
    "type": {
      "element": "HTMLElement",
      "wrapper": "HTMLElement",
      "hideFunc": "() => void",
      "stopAnchoringPromise": "AgPromise<Function>",
      "instanceId": "number"
    }
  },
  "Rect": {
    "meta": {},
    "type": {
      "top": "number",
      "left": "number",
      "right": "number",
      "bottom": "number"
    }
  },
  "DIRECTION": {
    "meta": { "isEnum": true },
    "type": ["vertical", "horizontal"],
    "docs": [null, null]
  },
  "AddPopupParams": {
    "meta": {},
    "type": {
      "modal?": "boolean",
      "eChild": "any",
      "closeOnEsc?": "boolean",
      "closedCallback?": "(e?: MouseEvent | TouchEvent | KeyboardEvent) => void",
      "click?": "MouseEvent | Touch | null",
      "alwaysOnTop?": "boolean",
      "afterGuiAttached?": "(params: IAfterGuiAttachedParams) => void",
      "positionCallback?": "() => void",
      "anchorToElement?": "HTMLElement",
      "ariaLabel": "string"
    }
  },
  "AddPopupResult": {
    "meta": {},
    "type": {
      "hideFunc": "() => void",
      "stopAnchoringPromise": "AgPromise<Function>"
    }
  },
  "ITabGuard": {
    "meta": {},
    "type": { "setTabIndex(tabIndex?: string)": "void" }
  },
  "ITooltipFeatureCtrl": {
    "meta": {},
    "type": {
      "getTooltipValue()": "any",
      "getGui()": "HTMLElement",
      "getLocation()": "string",
      "getColumn?()": "Column | ColumnGroup",
      "getColDef?()": "ColDef | ColGroupDef",
      "getRowIndex?()": "number",
      "getRowNode?()": "RowNode",
      "getValueFormatted?()": "string"
    }
  },
  "ITooltipFeatureComp": {
    "meta": {},
    "type": { "setTitle(title: string | undefined)": "void" }
  },
  "TapEvent": {
    "meta": {},
    "type": { "touchStart": "Touch", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "LongTapEvent": {
    "meta": {},
    "type": {
      "touchStart": "Touch",
      "touchEvent": "TouchEvent",
      "type": "string"
    },
    "docs": { "type": "/** Event identifier */" }
  },
  "VirtualListModel": {
    "meta": {},
    "type": {
      "getRowCount()": "number",
      "getRow(index: number)": "any",
      "isRowSelected?(index: number)": "boolean | undefined"
    }
  },
  "ISetFilterLocaleText": {
    "meta": {},
    "type": {
      "loadingOoo": "string",
      "blanks": "string",
      "searchOoo": "string",
      "selectAll": "string",
      "selectAllSearchResults": "string",
      "noMatches": "string"
    }
  },
  "SetFilterListItemSelectionChangedEvent": {
    "meta": {},
    "type": { "isSelected": "boolean", "type": "string" },
    "docs": { "type": "/** Event identifier */" }
  },
  "SetFilterModelValue": {
    "meta": { "isTypeAlias": true },
    "type": "(string | null)[]"
  },
  "SetFilterModel": {
    "meta": {},
    "type": { "filterType?": "'set'", "values": "SetFilterModelValue" }
  },
  "SetFilterModelValuesType": {
    "meta": { "isEnum": true },
    "type": ["PROVIDED_LIST", "PROVIDED_CALLBACK", "TAKEN_FROM_GRID_VALUES"],
    "docs": [null, null, null]
  },
  "ToolPanelFiltersCompParams": {
    "meta": {},
    "type": {
      "suppressExpandAll": "boolean",
      "suppressFilterSearch": "boolean",
      "suppressSyncLayoutWithGrid": "boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi"
    },
    "docs": {
      "suppressExpandAll": "/** To suppress Expand / Collapse All */",
      "suppressFilterSearch": "/** To suppress the Filter Search */",
      "suppressSyncLayoutWithGrid": "/** Suppress updating the layout of columns as they are rearranged in the grid */"
    }
  },
  "EXPAND_STATE": {
    "meta": { "isEnum": true },
    "type": ["EXPANDED", "COLLAPSED", "INDETERMINATE"],
    "docs": [null, null, null]
  },
  "ToolPanelFilterItem": {
    "meta": { "isTypeAlias": true },
    "type": "ToolPanelFilterGroupComp | ToolPanelFilterComp"
  },
  "IMultiFilterDef": {
    "meta": {},
    "type": {
      "display?": "'inline' | 'accordion' | 'subMenu'",
      "title?": "string",
      "filter?": "IFilterType",
      "filterFramework?": "any",
      "filterParams?": "any",
      "floatingFilterComponent?": "IFloatingFilterType",
      "floatingFilterComponentParams?": "any",
      "floatingFilterComponentFramework?": "any"
    },
    "docs": {
      "display?": "/** Configures how the filter is shown in the Multi Filter.\n * Default: `inline` */",
      "title?": "/** The title to be used when a filter is displayed inside a sub-menu or accordion. */",
      "filter?": "/** One of the built in filter names: [set, number, text, date], or a filter function */",
      "filterParams?": "/** The filter params are specific to each filter! */",
      "floatingFilterComponent?": "/** The custom component to be used for rendering the floating filter.\n * If none is specified the default AG Grid is used. */"
    }
  },
  "IMultiFilterParams": {
    "meta": {},
    "type": {
      "filters?": "IMultiFilterDef[]",
      "column": "Column",
      "colDef": "ColDef",
      "rowModel": "IRowModel",
      "filterChangedCallback": "(additionalEventAttributes?: any) => void",
      "filterModifiedCallback": "() => void",
      "valueGetter": "(rowNode: RowNode) => any",
      "doesRowPassOtherFilter": "(rowNode: RowNode) => boolean",
      "api": "GridApi",
      "columnApi": "ColumnApi",
      "context": "any"
    },
    "docs": {
      "filters?": "/** An array of filter definition objects. */",
      "column": "/** The column this filter is for. */",
      "colDef": "/** The column definition for the column. */",
      "rowModel": "/** The row model, helpful for looking up data values if needed.\n * If the filter needs to know which rows are\n * a) in the table,\n * b) currently visible (i.e. not already filtered),\n * c) which groups,\n * d) what order - all of this can be read from the rowModel. */",
      "filterChangedCallback": "/** A function callback to be called when the filter changes. The\n * grid will then respond by filtering the grid data. The callback\n * takes one optional parameter which, if included, will get merged\n * to the FilterChangedEvent object (useful for passing additional\n * information to anyone listening to this event, however such extra\n * attributes are not used by the grid). */",
      "filterModifiedCallback": "/** A function callback, to be optionally called, when the filter UI changes.\n * The grid will respond with emitting a FilterModifiedEvent.\n * Apart from emitting the event, the grid takes no further action. */",
      "valueGetter": "/** A function callback for the filter to get cell values from the row data.\n * Call with a node to be given the value for that filter's column for that node.\n * The callback takes care of selecting the right column definition and deciding whether to use valueGetter or field etc.\n * This is useful in, for example, creating an Excel style filter,\n * where the filter needs to lookup available values to allow the user to select from. */",
      "doesRowPassOtherFilter": "/** A function callback, call with a node to be told whether the node passes all filters except the current filter.\n * This is useful if you want to only present to the user values that this filter can filter given the status of the other filters.\n * The set filter uses this to remove from the list,\n * items that are no longer available due to the state of other filters (like Excel type filtering). */",
      "context": "/** The context as provided on `gridOptions.context` */"
    }
  },
  "IMultiFilterModel": {
    "meta": {},
    "type": { "filterType?": "'multi'", "filterModels": "any[] | null" },
    "docs": {
      "filterType?": "/** Multi filter type. */",
      "filterModels": "/** Child filter models in the same order as the filters are specified in `filterParams`. */"
    }
  }
}
